p2p$.ns("com.player");
p2p$.com.player.BasePlayer = JClass.extend_({
params_:{},
// properties
video_:null,//video对象
context_ : null,
url_ : null,
config_:null,
http_ : null,
player_ : null,
stream_ : null,//流加载对象
firstSeekTime_:0,
creator_:null,
tag_:"com::player::BasePlayer",
/*各种状态说明
1.VIDEO.PLAY.ERROR 错误信息
2.VIDEO.GSLB.LOADING 调度加载
3.VIDEO.GSLB.LOADED 调度加载结束
4.VIDEO.META.LOADING meta加载
5.VIDEO.META.LOADED meta加载结束
6.VIDEO.PLAY.START 视频开始
7.VIDEO.META.INFO meta信息加载
8.VIDEO.PLAY.LOAD
9.VIDEO.PLAY.FIRST 首次起播
10.VIDEO.PLAY.SEEKING  seek开始
11.VIDEO.PLAY.SEEKED seek结束
12.VIDEO.BUFFER.START  缓冲开始
13.VIDEO.BUFFER.END 缓冲结束
14.VIDEO.PLAY.END 播放结束
15.VIDEO.BUFFER.RANGR SourceBuffer中缓冲的数据
* */

init:function(video)
{
this.config_ = p2p$.com.selector.Config;
this.video_ = video;
this.http_ = null;
this.url_ = this.config_.playUrl;
},
sendStatus_:function(params)
{
P2P_ULOG_INFO(P2P_ULOG_FMT("{0::sendStatus params({1})",this.tag_,JSON.stringify(params)));
if(typeof (this.config_.callback) == "function")
{
this.config_.callback(params_);
}
else if(typeof (this.config_.callback) == "string")
{
try{
eval(this.config_.callback+"("+JSON.stringify(params)+")");
}
catch(e){
P2P_ULOG_WARNING(P2P_ULOG_FMT("{0::sendStatus callback({1} has no function)",this.tag_,this.config_.callback));
}
}
}
});
p2p$.ns("com.player");
p2p$.com.player.MediaPlayer = p2p$.com.player.BasePlayer.extend_({
init:function(video)
{
this._super(video);
this.tag_="com::player::MediaPlayer";
},
start:function()
{
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} start url({1})",this.tag_,this.url_));
if (!this.url_) {
return;
}
this.stream_ = p2p$.com.webp2p.core.entrance.VideoStream;
this.stream_.init();
this.creator_ = new p2p$.com.webp2p.core.player.Creator();
this.creator_.initialize_(this, this.url_, this.video_, this.stream_);
this.player_ = this.creator_.createPlayer_();
},
pause:function()
{
if (!this.url_) {
return;
}
if (!this.creator_) {
return;
}
if (this.player_) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::pause...",this.tag_));
this.player_.pause();
}
},
resume:function()
{

},
openUrl_:function(url)
{
this.url_=url;
if(!this.creator_){
this.start();
return;
}
this.creator_.changeChannel_(url);
this.player_ = this.creator_.createPlayer_();
}
});
p2p$.ns("com.player");
p2p$.com.player.SystemPlayer = p2p$.com.player.BasePlayer.extend_({

init : function(video) {
this._super(video);
this.tag_="com::player::SystemPlayer";
},
start : function() {
if (this.http_) {
this.http_.abort();
this.http_ = null;
}
var urlInfo = new p2p$.com.common.Url();
urlInfo.fromString_(this.url_);
urlInfo.params_.set('format', '1');
urlInfo.params_.set('expect', '3');
urlInfo.params_.set('ajax', '1');
if (!urlInfo.params_.has('stream_id')) {
urlInfo.params_.set('tss', 'no');
}
var gslbUrl = urlInfo.toString();
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Start download gslb url: {1} ...",this.tag_,gslbUrl));

var loader = new p2p$.com.loaders.HttpDownLoader({url_:gslbUrl,scope_:this,type_:"json"});
loader.load_();

var env = p2p$.com.selector.Enviroment;
var report = new p2p$.com.common.Url();
report.protocol_ = "http";
report.host_ = env.getHostDomain_("s.webp2p.letv.com");
report.file_ = "/ClientStageInfo";
report.params_.set("act", "0");
report.params_.set("err", "1");
report.params_.set("utime",0);
report.params_.set("type", urlInfo.params_.has("stream_id") ? "liv" : "vod");
report.params_.set("termid", urlInfo.params_.get("termid"));
report.params_.set("platid", urlInfo.params_.get("platid"));
report.params_.set("splatid", urlInfo.params_.get("splatid"));
report.params_.set("vtype", urlInfo.params_.get("vtype") || "0");
report.params_.set("streamid", urlInfo.params_.get("stream_id") || "");
report.params_.set("ch", urlInfo.params_.get("ch") || "");
report.params_.set("p1", urlInfo.params_.get("p1") || "");
report.params_.set("p2", urlInfo.params_.get("p2") || "");
report.params_.set("p3", urlInfo.params_.get("p3") || "");
report.params_.set("uuid", urlInfo.params_.get("uuid") || "");
report.params_.set("p2p", "0");
report.params_.set("appid", env.externalAppId_);
report.params_.set("cdeid", env.moduleId_);
report.params_.set("package", env.externalAppPackageName_);
},
onHttpDownloadCompleted_ : function(downloader) {

var data_ = downloader.responseData_;
var code_ = downloader.responseCode_;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Download gslb {1}: {2} ...",this.tag_,data_!="" ? 'success' : 'failed', code_));
if (!data_) {
this.sendStatus_({type:"VIDEO.PLAY.ERROR",code:code_,info:"no data!"});
return;
}

try {
var gslbData = (typeof (data_) == "string") ? eval("(" + data_ + ")") : data_;
var mediaUrl = gslbData.location;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Gslb responsed, error code({1}), details({2}), user ip({3}), url({4})",this.tag_,gslbData.ercode,
gslbData.errinfo || '', gslbData.remote, mediaUrl));
this.video_.src = mediaUrl;
this.addVideoEvent_(this.video_);
this.video_.play();
} catch (e) {
this.sendStatus_({type:"VIDEO.PLAY.ERROR",code:code_,info:e.toString()|""});
}
}
});
p2p$.ns("com.webp2p.core.common");

p2p$.com.webp2p.core.common.META_DATA_TYPE = {
kMetaDataTypeVod : 0,
kMetaDataTypeLive : 1,
kMetaDataTypeDownload : 2,
kMetaDataTypeRtlStream : 3
};

p2p$.com.webp2p.core.common.META_PIECE_TYPE = {
kMetaPieceTypeTn : 0,
kMetaPieceTypePn : 1
};

p2p$.com.webp2p.core.common.ERROR_CODE = {
kErrorSuccess : 0,
kErrorAccessDenied : 1,
kErrorInvalidParameters : 2,
kErrorInternalError : 3,
kErrorDestUnreachable : 4,
kErrorServiceBusy : 5,
kErrorNetworkUnreachable : 6,
kErrorAlreadyExists : 7,
kErrorNoSuchGroup : 8,
kErrorNoSuchGroupItem : 9,
kErrorNoSuchSession : 10,
kErrorNoSuchItem : 11,
kErrorNetworkFailed : 12,
kErrorTimeout : 13,
kErrorNotReady : 14,
kErrorStreamIdIsEmpty : 15,
kErrorCanceled : 16,
kErrorAuthFailed : 17,
kErrorNoPrivileges : 18,
kErrorAlreadyLogin : 19,
kErrorServiceOffline : 20,
kErrorNotSupported : 21,
kErrorPasswordExpired : 22,
kErrorCodeMax : 23,
};

p2p$.com.webp2p.core.common.SERVER_TYPES = {
kServerTypeReserved : 0,
kServerTypeControl : 1,
kServerTypeStorage : 2,
kServerTypeRtmfp : 4,
kServerTypeWebRTC : 8,
kServerTypeHttpTracker : 16,
kServerTypeReserved5 : 32,
kServerTypeStunServer : 64,
kServerTypeSelector : 128,
};

p2p$.com.webp2p.core.common.Enum = {
getMetaTypeName_ : function(type) {
switch (type) {
case p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeVod:
return "vod";
case p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeLive:
return "live";
case p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeDownload:
return "download";
case p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeRtlStream:
return "stream";
default:
return "unknown";
}
},

getPieceTypeName_ : function(type) {
switch (type) {
case p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn:
return "tn";
case p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypePn:
return "pn";
default:
return "unknown";
}
}
};
p2p$.ns('com.webp2p.core.common');

/*
* A JavaScript implementation of the RSA Data Security, Inc. MD5 Message Digest Algorithm, as defined in RFC 1321. Version 2.1 Copyright (C) Paul Johnston 1999 -
* 2002. Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet Distributed under the BSD License See http://pajhome.org.uk/crypt/md5 for more info.
*/

/*
* Configurable variables. You may need to tweak these to be compatible with the server-side, but the defaults work in most cases.
*/
p2p$.com.webp2p.core.common.Md5 = {
hexcase : 0, /* hex output format. 0 - lowercase; 1 - uppercase */
chrsz : 8, /* bits per input character. 8 - ASCII; 16 - Unicode */

/*
* These are the functions you'll usually want to call They take string arguments and return either hex or base-64 encoded strings
*/
hexString_ : function(s) {
return this.binl2hex_(this.core_md5_(this.str2binl_(s), s.length * this.chrsz));
},

/*
* Calculate the MD5 of an array of little-endian words, and a bit length
*/
core_md5_ : function(x, len) {
/* append padding */
x[len >> 5] |= 0x80 << ((len) % 32);
x[(((len + 64) >>> 9) << 4) + 14] = len;

var a = 1732584193;
var b = -271733879;
var c = -1732584194;
var d = 271733878;

for ( var i = 0; i < x.length; i += 16) {
var olda = a;
var oldb = b;
var oldc = c;
var oldd = d;

a = this.ff(a, b, c, d, x[i + 0], 7, -680876936);
d = this.ff(d, a, b, c, x[i + 1], 12, -389564586);
c = this.ff(c, d, a, b, x[i + 2], 17, 606105819);
b = this.ff(b, c, d, a, x[i + 3], 22, -1044525330);
a = this.ff(a, b, c, d, x[i + 4], 7, -176418897);
d = this.ff(d, a, b, c, x[i + 5], 12, 1200080426);
c = this.ff(c, d, a, b, x[i + 6], 17, -1473231341);
b = this.ff(b, c, d, a, x[i + 7], 22, -45705983);
a = this.ff(a, b, c, d, x[i + 8], 7, 1770035416);
d = this.ff(d, a, b, c, x[i + 9], 12, -1958414417);
c = this.ff(c, d, a, b, x[i + 10], 17, -42063);
b = this.ff(b, c, d, a, x[i + 11], 22, -1990404162);
a = this.ff(a, b, c, d, x[i + 12], 7, 1804603682);
d = this.ff(d, a, b, c, x[i + 13], 12, -40341101);
c = this.ff(c, d, a, b, x[i + 14], 17, -1502002290);
b = this.ff(b, c, d, a, x[i + 15], 22, 1236535329);

a = this.gg(a, b, c, d, x[i + 1], 5, -165796510);
d = this.gg(d, a, b, c, x[i + 6], 9, -1069501632);
c = this.gg(c, d, a, b, x[i + 11], 14, 643717713);
b = this.gg(b, c, d, a, x[i + 0], 20, -373897302);
a = this.gg(a, b, c, d, x[i + 5], 5, -701558691);
d = this.gg(d, a, b, c, x[i + 10], 9, 38016083);
c = this.gg(c, d, a, b, x[i + 15], 14, -660478335);
b = this.gg(b, c, d, a, x[i + 4], 20, -405537848);
a = this.gg(a, b, c, d, x[i + 9], 5, 568446438);
d = this.gg(d, a, b, c, x[i + 14], 9, -1019803690);
c = this.gg(c, d, a, b, x[i + 3], 14, -187363961);
b = this.gg(b, c, d, a, x[i + 8], 20, 1163531501);
a = this.gg(a, b, c, d, x[i + 13], 5, -1444681467);
d = this.gg(d, a, b, c, x[i + 2], 9, -51403784);
c = this.gg(c, d, a, b, x[i + 7], 14, 1735328473);
b = this.gg(b, c, d, a, x[i + 12], 20, -1926607734);

a = this.hh(a, b, c, d, x[i + 5], 4, -378558);
d = this.hh(d, a, b, c, x[i + 8], 11, -2022574463);
c = this.hh(c, d, a, b, x[i + 11], 16, 1839030562);
b = this.hh(b, c, d, a, x[i + 14], 23, -35309556);
a = this.hh(a, b, c, d, x[i + 1], 4, -1530992060);
d = this.hh(d, a, b, c, x[i + 4], 11, 1272893353);
c = this.hh(c, d, a, b, x[i + 7], 16, -155497632);
b = this.hh(b, c, d, a, x[i + 10], 23, -1094730640);
a = this.hh(a, b, c, d, x[i + 13], 4, 681279174);
d = this.hh(d, a, b, c, x[i + 0], 11, -358537222);
c = this.hh(c, d, a, b, x[i + 3], 16, -722521979);
b = this.hh(b, c, d, a, x[i + 6], 23, 76029189);
a = this.hh(a, b, c, d, x[i + 9], 4, -640364487);
d = this.hh(d, a, b, c, x[i + 12], 11, -421815835);
c = this.hh(c, d, a, b, x[i + 15], 16, 530742520);
b = this.hh(b, c, d, a, x[i + 2], 23, -995338651);

a = this.ii(a, b, c, d, x[i + 0], 6, -198630844);
d = this.ii(d, a, b, c, x[i + 7], 10, 1126891415);
c = this.ii(c, d, a, b, x[i + 14], 15, -1416354905);
b = this.ii(b, c, d, a, x[i + 5], 21, -57434055);
a = this.ii(a, b, c, d, x[i + 12], 6, 1700485571);
d = this.ii(d, a, b, c, x[i + 3], 10, -1894986606);
c = this.ii(c, d, a, b, x[i + 10], 15, -1051523);
b = this.ii(b, c, d, a, x[i + 1], 21, -2054922799);
a = this.ii(a, b, c, d, x[i + 8], 6, 1873313359);
d = this.ii(d, a, b, c, x[i + 15], 10, -30611744);
c = this.ii(c, d, a, b, x[i + 6], 15, -1560198380);
b = this.ii(b, c, d, a, x[i + 13], 21, 1309151649);
a = this.ii(a, b, c, d, x[i + 4], 6, -145523070);
d = this.ii(d, a, b, c, x[i + 11], 10, -1120210379);
c = this.ii(c, d, a, b, x[i + 2], 15, 718787259);
b = this.ii(b, c, d, a, x[i + 9], 21, -343485551);

a = this.add(a, olda);
b = this.add(b, oldb);
c = this.add(c, oldc);
d = this.add(d, oldd);
}
return Array(a, b, c, d);
},

/*
* These functions implement the four basic operations the algorithm uses.
*/
cmn : function(q, a, b, x, s, t) {
return this.add(this.br(this.add(this.add(a, q), this.add(x, t)), s), b);
},

ff : function(a, b, c, d, x, s, t) {
return this.cmn((b & c) | ((~b) & d), a, b, x, s, t);
},

gg : function(a, b, c, d, x, s, t) {
return this.cmn((b & d) | (c & (~d)), a, b, x, s, t);
},

hh : function(a, b, c, d, x, s, t) {
return this.cmn(b ^ c ^ d, a, b, x, s, t);
},

ii : function(a, b, c, d, x, s, t) {
return this.cmn(c ^ (b | (~d)), a, b, x, s, t);
},

/*
* Add integers, wrapping at 2^32. This uses 16-bit operations internally to work around bugs in some JS interpreters.
*/
add : function(x, y) {
var lsw = (x & 0xFFFF) + (y & 0xFFFF);
var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
return (msw << 16) | (lsw & 0xFFFF);
},

/*
* Bitwise rotate a 32-bit number to the left.
*/
br : function(num, cnt) {
return (num << cnt) | (num >>> (32 - cnt));
},

/*
* Convert a string to an array of little-endian words If chrsz is ASCII, characters >255 have their hi-byte silently ignored.
*/
str2binl_ : function(str) {
var bin = Array();
var mask = (1 << this.chrsz) - 1;
for ( var i = 0; i < str.length * this.chrsz; i += this.chrsz) {
bin[i >> 5] |= (str.charCodeAt(i / this.chrsz) & mask) << (i % 32);
}
return bin;
},

/*
* Convert an array of little-endian words to a string
*/
binl2str_ : function(bin) {
var str = "";
var mask = (1 << this.chrsz) - 1;
for ( var i = 0; i < bin.length * 32; i += this.chrsz) {
str += String.fromCharCode((bin[i >> 5] >>> (i % 32)) & mask);
}
return str;
},

/*
* Convert an array of little-endian words to a hex string.
*/
binl2hex_ : function(binarray) {
var hex_tab = this.hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
var str = "";
for ( var i = 0; i < binarray.length * 4; i++) {
str += hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8 + 4)) & 0xF) + hex_tab.charAt((binarray[i >> 2] >> ((i % 4) * 8)) & 0xF);
}
return str;
}
};
window.JSON = window.JSON || {};
window.URL = (window.URL || window.webkitURL || window.msURL || window.oURL);
window.RTCPeerConnection = (window.PeerConnection || window.webkitPeerConnection00 || window.webkitRTCPeerConnection || window.mozRTCPeerConnection);
window.RTCIceCandidate = (window.mozRTCIceCandidate || window.RTCIceCandidate);
window.RTCSessionDescription = (window.mozRTCSessionDescription || window.RTCSessionDescription); // order is very important: "RTCSessionDescription" defined

// in Nighly but useless
var CdeByteArray = function(data) {

this.length = 0;
this._position = 0;
this.uInt8Array = new Uint8Array();
if (data) {
this.uInt8Array = new Uint8Array(data);
}
this.writeBytes = function(bytes) {
var tempByteArray = null;
if (this.uInt8Array) {
tempByteArray = new Uint8Array(this.uInt8Array.length + bytes.length);
tempByteArray.set(this.uInt8Array, 0);
tempByteArray.set(bytes, this.uInt8Array.length);
} else {
tempByteArray = bytes;
}
this.uInt8Array = tempByteArray;
};
this.setBytes = function(int8) {
this.position = 0;
this.uInt8Array = int8;
};

this.readBytes = function(bytes, offset, length) {
offset = offset || 0;
length = length || this.uInt8Array.length;
if (length === 0) {
length = this.uInt8Array.length;
}
if ((offset === 0 || (offset > 0 && offset < bytes.uInt8Array.length)) && length > 0 && (this.position + length) <= this.uInt8Array.length) {
var tempBytes0 = new Uint8Array(offset);
tempBytes0 = bytes.uInt8Array.subarray(0, offset);

var tempBytes1 = new Uint8Array(tempBytes0.length + length);
var tempBytes2 = new Uint8Array(length);

tempBytes2 = this.uInt8Array.subarray(this.position, length);

tempBytes1.set(tempBytes0);
tempBytes1.set(tempBytes2, tempBytes0.length);
bytes.uInt8Array = new Uint8Array(tempBytes1);
} else {
console.log("readBytes error");
}

};
this.generationByteArray = function(int8) {
this.position = 0;
this.uInt8Array = int8;
};

this.clear = function() {
this.position = 0;
this.uInt8Array = new Uint8Array();
};

this.__defineGetter__("position", function() {
return this._position;
});

this.__defineSetter__("position", function(value) {
this._position = value;
});
this.__defineGetter__("length", function() {
return this.uInt8Array.length;
});
this.__defineGetter__("bytesAvailable", function() {
return this.length - this._position;
});

this.__defineGetter__("CdeByteArray", function() {
return this.uInt8Array;
});

};

JSON.stringify = JSON.stringify || function(obj) {
var t = typeof (obj);
if (t != "object" || obj === null) {
// simple data type
if (t == "string") {
obj = '"' + obj + '"';
}
return String(obj);
} else {
// recurse array or object
var n, v, json = [], arr = (obj && obj.constructor == Array);
for ( n in obj) {
v = obj[n];
t = typeof (v);
if (t == "string") {
v = '"' + v + '"';
} else if (t == "object" && v !== null) {
v = JSON.stringify(v);
}
json.push((arr ? "" : '"' + n + '":') + String(v));
}
return (arr ? "[" : "{") + String(json) + (arr ? "]" : "}");
}
};
p2p$.ns("com.webp2p.core.common");

p2p$.com.webp2p.core.common.Number = {
max : function(value1, value2) {
return value1 > value2 ? value1 : value2;
},

min : function(value1, value2) {
return value1 > value2 ? value2 : value1;
},

maxUnsignedValue_ : function() {
return -1 >>> 0;
},

convertToBit_ : function(size, data, _array) {
var __uint8 = null;
switch (size) {
case "2":
__uint8 = new Uint8Array(2);
__uint8[0] = (parseInt(data) >> 8) & 0xff;
__uint8[1] = parseInt(data) & 0xff;
_array.push(__uint8);
break;
case "4":
__uint8 = new Uint8Array(4);
__uint8[0] = (parseInt(data) >> 24) & 0xff;
__uint8[1] = (parseInt(data) >> 16) & 0xff;
__uint8[2] = (parseInt(data) >> 8) & 0xff;
__uint8[3] = parseInt(data) & 0xff;
_array.push(__uint8);
break;
case "8":
__uint8 = new Uint8Array(8);
var data1 = Math.floor(data / 0x100000000);
__uint8[0] = (data1 >> 24) & 0xff;
__uint8[1] = (data1 >> 16) & 0xff;
__uint8[2] = (data1 >> 8) & 0xff;
__uint8[3] = (data1) & 0xff;
var data2 = Math.floor(data % 0x100000000);
__uint8[4] = (data2 >> 24) & 0xff;
__uint8[5] = (data2 >> 16) & 0xff;
__uint8[6] = (data2 >> 8) & 0xff;
__uint8[7] = (data2) & 0xff;
_array.push(__uint8);
break;
case "utf":
__uint8 = new Uint8Array(data.length);
for ( var i = 0; i < data.length; i++) {
__uint8[i] = data.charCodeAt(i);
}
_array.push(__uint8);
break;
case "d":
if (data && data.length > 0) {
_array.push(data);
}
break;
}
},

convertToValue_ : function(size, byteArray, position, len) {
var value1;
var value2;
var value3;
var value4;
var value = null;
switch (size) {
case "2":
value1 = byteArray[position];
value2 = byteArray[position + 1];
value = (value1 << 8) + value2;
break;
case "4":
value1 = byteArray[position];
value2 = byteArray[position + 1];
value3 = byteArray[position + 2];
value4 = byteArray[position + 3];
value = (value1 * Math.pow(2, 24)) + (value2 << 16) + (value3 << 8) + value4;
break;
case "8":
value1 = byteArray[position];
value2 = byteArray[position + 1];
value3 = byteArray[position + 2];
value4 = byteArray[position + 3];

var high = (value1 * Math.pow(2, 24)) + (value2 << 16) + (value3 << 8) + value4;
value1 = byteArray[position + 4];
value2 = byteArray[position + 5];
value3 = byteArray[position + 6];
value4 = byteArray[position + 7];
var low = (value1 * Math.pow(2, 24)) + (value2 << 16) + (value3 << 8) + value4;
value = (high * 0x100000000) + low;
break;
case "utf":
var str = "";
for ( var i = 0; i < len; i++) {
str += String.fromCharCode(byteArray[position + i]);
}
value = str;
break;
case "d":
value = byteArray.subarray(position, position + len);
break;
}
return value;
}
};
p2p$.ns('com.webp2p.core.entrance');

p2p$.com.webp2p.core.entrance.VideoStream = {
initialized_ : false,
channelManager_ : null,
pool_ : null,
enviroment_ : null,
connectionType_ : "",
strings_:null,
platForms_:[["Win32","Windows"],["Mac68K","MacPPC","Macintosh","MacIntel"]],
tag_:"com::webp2p::core::entrance::VideoStream",

init : function() {
if (this.initialized_) {
return;
}
this.strings_ = p2p$.com.common.String;
this.connectionType_ = "";
this.initialized_ = true;
this.enviroment_ = p2p$.com.selector.Enviroment;
this.checkNetwork_();
this.channelManager_ = new p2p$.com.webp2p.logic.base.Manager(this.enviroment_);
this.pool_ = p2p$.com.webp2p.core.storage.Pool;
this.pool_.initialize_(this.channelManager_);
this.setCheckTimer_(5000);
},

checkNetwork_ : function() {
var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
if (connection) {
this.connectionType_ = connection.type;
try {
var me = this;
// Register for event changes.
connection.onchange = function(e) {
me.onNetowrkTypeChanged_(e);
};
// Alternatively.
connection.addEventListener('change', function(e) {
me.onNetowrkTypeChanged_(e);
});
} catch (e) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Add network change event failed: {1}",this.tag_,(e || "").toString()));
}
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Check network, type: {1}",this.tag_,this.connectionType_));
} else {
var osType = this.enviroment_.getOSType_();
switch(osType)
{
case "Mac":
case "Unix":
case "Linux":
case "Win2000":
case "Win2003":
case "WinXP":
case "WinVista":
case "Win7":
case "Win":
case "other":
this.connectionType_ = "ethernet";
break;
case "iPhone":
case "Android":
this.connectionType_ = "mobile";
break;
default:
break;
}
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Check network not support, os {1} default as {2}",this.tag_,osType,this.connectionType_));
}
this.enviroment_.setNetworkType_(this.connectionType_);
},
onNetowrkTypeChanged_ : function(e) {
var temp = this.connectionType_;
this.connectionType_ = navigator.connection.type;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Network changed from ({1}) to ({2})",this.tag_, temp, this.connectionType_));
this.enviroment_.setNetworkType_(connectionType);
this.channelManager_.checkTimeout_();
},

onCheckTimeout_ : function() {
this.channelManager_.checkTimeout_();
this.setCheckTimer_(5000);
},

setCheckTimer_ : function(timeoutMs) {
var me = this;
this.checkTimer_ = setTimeout(function() {
me.onCheckTimeout_();
}, timeoutMs);
},

getConnectionParams_ : function(palyUrl, url) {
url.fromString_(palyUrl);
},

requestPlay_ : function(palyUrl) {
var channel = null;
var url = new p2p$.com.common.Url();
this.playUrl_ = palyUrl;
this.getConnectionParams_(palyUrl, url);
channel = this.channelManager_.openChannel_(this.playUrl_, url.params_, this);
if (channel) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Request play, url({1})", this.tag_,palyUrl));
return channel;
}
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Open channel failed",this.tag_));
return null;
},

requestPlaySlice_ : function(channelId, requestSegmentId, urgentSegmentId) {
var responseDetails = "";
var channel = this.channelManager_.getChannelById_(channelId);

if (channel == null) {
responseDetails = "Channel Not Found";
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Request play slice {1}",this.tag_, responseDetails));
return null;
}

var result = channel.requireSegmentData_(requestSegmentId, urgentSegmentId);
if (result.segment != null && result.stream != null) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Request play slice request urgent({1}) success",this.tag_, requestSegmentId));
} else {
P2P_ULOG_TRACE(P2P_ULOG_FMT("{0}::Request play slice request urgent({1}) failed",this.tag_,requestSegmentId));
}
return result;
},

requestPlayStop_ : function(palyUrl) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Request stop {1}",this.tag_,palyUrl));
this.channelManager_.closeChannel_(palyUrl);
},

requestControlParams_ : function() {
},

getConnectionParams2_ : function(palyUrl) {
var urlParse = new p2p$.com.common.Url();
urlParse.fromString_(palyUrl);
return urlParse.params_;
},

requestStateCurrent_ : function(url) {
var params, result = {};
params = this.getConnectionParams2_(url);
var maxLogTime = 0;
this.getCurrentState_(params, result, maxLogTime);
return result;
},
getCurrentState_ : function(params, result, maxLogTime) {
// module
var moduleResult = result["module"] = {};
moduleResult["version"] = this.strings_.format("H5-{0}.{1}.{2}", p2p$.com.selector.Module.kH5MajorVersion,p2p$.com.selector.Module.kH5MinorVersion, p2p$.com.selector.Module.kH5BuildNumber);
moduleResult["buildTime"] = p2p$.com.selector.Module.kBuildTime;

// system
result["system"] = {};
this.getSystemInfoDetails_(params, result["system"]);

// enviroment
result["enviroment"] = {};
this.enviroment_.getAllStatus_(result["enviroment"]);
// this.supportSession_.getAllStatus_(result["support"]);

if (!params.get("ignoreChannels")) {
this.channelManager_.getAllStatus_(params, result);
}

// log pipes
if (params.get("needLogPipe")) {
var logResult = p2p$.com.common.Log.logPipe_.require(parseInt(params.get("logPipeId") || 0), parseInt(params.get("logPipeTime") || 0),
parseInt(params.get("logPipeLevel") || 255), params.get("logPipeFilter") || "", parseInt(params.get("logPipeLimit") || 1), maxLogTime);
maxLogTime = logResult.maxLogTime;
result["logs"] = logResult.records;
}

return maxLogTime;
},

getSystemInfoDetails_ : function(params, result) {
result["currentTime"] = new Date().getTime() / 1000;

// system:default bucket
var defaultBucket = p2p$.com.webp2p.core.storage.Pool.getDefaultBucket_();
var storageInfo = result["storage"] = {};
var defaultInfo = storageInfo["default"] = {};
defaultInfo["name"] = defaultBucket.getName_();
defaultInfo["dataSize"] = defaultBucket.getDataSize_();
defaultInfo["dataCapacity"] = defaultBucket.getDataCapacity_();
}
};
p2p$.ns('com.webp2p.core.player');
p2p$.com.webp2p.core.player.BasePlayer = JClass.extend_({
kNoFirstSeek : -1,
kFirstSeekInit : 0,
kFirstSeekWaitDownLoadSegment : 1,
kFirstSeekDownLoadSegmentOk : 2,
kFirstSeekStatusDone : 3,
errorReplayTime_:0,
firstSeekPosition_ : 0,

firstPlayTime_:-1,//执行playing时间
firstAddDataTime_:-1,//喂第一块数据时间
firstPlayingTime_:-1,//执行playing时间
seekingTime_:-1,//开始seek时间
seekedTime_:-1,//seek用时
rangeDalay_:0,
stream_ : null,
delayTime_:0,
wrapper_ : null,
url_ : "",
urgentSegment_ : 0,
mediaSource_ : null,
mediaOpened_ : false,
fectchInterval_ : 200,
channel_ : null,
video_ : null,
blockList_ : null,
sourceBuffer_ : null,
sourceIdle_ : true,
sourceMime_ : null,
toMp4_ : null,
initFnum_ : 0,
fetchTimer_ : null,
metaData_ : null,
nextSegmentId_ : 0,
playerContext_ : null,
preTime_ : 0,
preSegmentId_ : "",
breakTimes_ : 0,
bufferTimes_ : 0,
macSafariPattern_ : false,
videoDuration_ : 0,
actived_ : false,
maxErrorTimes_ : 0,
duration_ : 0,
global_:null,
strings_:null,
config_:null,
videoStatus_:null,
playerStatus_:null,
tag_:"com::webp2p::core::player::BasePlayer",

init : function(wrapper) {
this.wrapper_ = wrapper;
this.stream_ = null;
this.url_ = "";
this.mediaSource_ = null;
this.mediaOpened_ = false;
this.channel_ = null;
this.blockList_ = [];
this.sourceBuffer_ = null;
this.video_ = null;
this.strings_ = p2p$.com.common.String;
this.global_ = p2p$.com.common.Global;
this.config_ = p2p$.com.selector.Config;
this.videoStatus_ = p2p$.com.webp2p.core.player.VIDEO_STATUS;
this.playerStatus_ = p2p$.com.webp2p.core.player.PLAY_STATES;
this.toMp4_ = null;

this.initFnum_ = 0;
this.fetchTimer_ = null;
this.metaData_ = null;
this.nextSegmentId_ = 0;
this.playerContext_ = new p2p$.com.webp2p.core.player.Context();
this.preTime_ = 0;
this.preSegmentId_ = -1;
this.sourceIdle_ = true;
this.macSafariPattern_ = false;
this.actived_ = false;
// this.loop_ = 0;
this.urgentSegment_ = 0;
this.errorTimes_ = 0;
this.maxErrorTimes_ = 3;
this.duration_ = 0;
this.lastErrorTime_ = 0;
},

stopFetchTimer_ : function() {
if (this.fetchTimer_) {
clearInterval(this.fetchTimer_);
this.fetchTimer_ = null;
}
},

initialize_ : function(url, video, stream, channel) {
this.channel_ = channel;
this.channel_.setPlayer_(this);
this.url_ = url;
this.stream_ = stream;
this.video_ = video;
this.actived_ = true;
this.mediaOpened_ = false;

var mediaType = p2p$.com.selector.Enviroment.getMediaType_();
if (mediaType.mediasource) {
if (mediaType.ts&&this.config_.encode==0) {
this.macSafariPattern_ = true;
this.playerContext_.isEncode_ = false;
} else if (mediaType.mp4) {
this.toMp4_ = new p2p$.com.webp2p.segmentmp4.ToMp4();
this.playerContext_.isEncode_ = true;
}
}
this.firstPlayTime_=this.global_.getMilliTime_();
this.addVideoEvents_(this.video_);
this.startTimer_();
this.sendStatus_({type:"PLAYER.INIT"})
return true;
},
startTimer_ : function() {
this.onLoop_();
if (this.fetchTimer_) {
clearInterval(this.fetchTimer_);
}
this.fetchTimer_ = setInterval(this.onLoop_.bind(this), this.fectchInterval_);
},
play : function() {
if (!this.video_) {
return;
}
if (this.video_.paused) {
this.video_.play();
}
},
getBlock_:function()
{
return true;
},
onLoop_ : function() {
if (!this.metaData_) {
this.getMetaData_();
} else {
if (this.actived_) {
this.getSegment_();
this.playSegment_();
}
}
},

getMetaData_ : function() {
if ((this.channel_.metaData_ && this.channel_.metaData_.p2pGroupId_) || (this.channel_.metaData_ && this.channel_.onMetaCompleteCode_ == 302)) {
this.metaData_ = this.channel_.metaData_;
this.pictureHeight_ = this.metaData_.pictureHeight_;
this.pictureWidth_ = this.metaData_.pictureWidth_;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::getMetaData_: height={1},width={2}",this.tag_,this.pictureHeight_,this.pictureWidth_));
}
},

refreshUrgentSegment_ : function(segmentId) {
if (!this.playerContext_.bufferd_) {
return;
}
var vtime = this.video_.currentTime;
if (vtime > 1) {
var segment = this.getSegmentByVideoTime_(vtime);
if (segment) {
this.urgentSegment_ = segment.id_;
if(this.nextSegmentId_>0&&this.nextSegmentId_<this.urgentSegment_)
{
P2P_ULOG_WARNING(P2P_ULOG_FMT("{0} nextSegmentId({1}) need change for urgentSegment({2})",this.tag_,this.nextSegmentId_,this.urgentSegment_));
this.nextSegmentId_ = this.urgentSegment_+1;
}
return;
}
}
this.urgentSegment_ = segmentId;
},
getSegmentByVideoTime_ : function(time) {
time = time * 1000;
var temp = null;
for ( var n = 0; n < this.metaData_.segments_.length; n++) {
var segment = this.metaData_.segments_[n];
if (segment.timestamp_ <= time && time <= (segment.timestamp_ + segment.duration_)) {
temp = segment;
}
}
return temp;
},
getSegment_ : function() {
if (this.blockList_.length >= 1) {
return;
}
if (this.firstSeekStatus_ != undefined && this.firstSeekStatus_ == this.kFirstSeekInit) {
this.firstSeekStatus_ = this.kFirstSeekWaitDownLoadSegment;
var seek2Segment = this.findSegment_(this.firstSeekPosition_);
if (seek2Segment) {
this.nextSegmentId_ = seek2Segment.id_;
this.urgentSegment_ = this.nextSegmentId_;
this.preSeekTime_ = this.firstSeekPosition_;
} else {
}
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::getSegment({1}) seekPosition({2})",this.tag_,this.nextSegmentId_, this.firstSeekPosition_));
}

var tempBlock = this.getBlock_(this.nextSegmentId_);
if (!tempBlock) {
if (this.nextSegmentId_ != -1) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::getSegment({1}) return({2})",this.tag_,this.nextSegmentId_, tempBlock));
}
return;
}
this.refreshUrgentSegment_(tempBlock.id_);
var streamInfo = this.stream_.requestPlaySlice_(this.channel_.getId_(), tempBlock.id_, this.urgentSegment_);

if (!streamInfo || !streamInfo.stream) {
var nowTime = new Date().getTime();
if (!this.lastSegmentFailedLogTime_ || (this.lastSegmentFailedLogTime_ + 10000) < nowTime) {
this.lastSegmentFailedLogTime_ = nowTime;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::vtime({1}) requestSegment({2}) stream({3}) urgentSegment({4})",this.tag_,this.video_ ? this.video_.currentTime.toFixed(2) : 0, tempBlock.id_, (streamInfo.stream != null), this.urgentSegment_));
}
return null;
}
this.preSegmentId_ = tempBlock.id_;
this.nextSegmentId_ = tempBlock.nextId_;
if(this.nextSegmentId_!=(this.preSegmentId_+1))
{
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::getSegment nextSegment mable error! preId({1}),next({2})",this.tag_,this.preSegmentId_,this.nextSegmentId_));
}
var _params={
width : tempBlock.pictureWidth_ || 960,
height : tempBlock.pictureHeight_ || 400,
segmentIndex:this.initFnum_,
encode:this.playerContext_.isEncode_
};
var info = this.getStreamInfo_(streamInfo.stream,_params,tempBlock);
tempBlock.timestamp_ = info.start;
this.initFnum_++;
this.blockList_.push({
data : info.stream,
block : tempBlock,
mime : this.formatMimeTypeName_(this.playerContext_.avccName_, this.playerContext_.aacName_)
});
},
getStreamInfo_:function(stream,params,block){
var _stream = stream;
var _start = block.startTime_;
var startChangeTime = this.global_.getMilliTime_();
if(this.toMp4_)
{
_stream = this.toMp4_.processFileSegment_(stream,params);
this.playerContext_.avccName_ = this.toMp4_.getMediaStreamAvccName_();
this.playerContext_.aacName_ = this.toMp4_.getMediaStreamAacName_();
_start = this.toMp4_.startTime;
var endChangeTime = this.global_.getMilliTime_();
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} turn to mp4, segmentid({1}), before({2}), after({3}),timeuse({4}),playtime({5}),nextSegmentId({6}),startTime({7}),params({8})",this.tag_,block.id_, stream.length, _stream.length, ((endChangeTime - startChangeTime) / 1000).toFixed(1),this.video_ ? this.video_.currentTime.toFixed(2) : 0, this.nextSegmentId_,_start,JSON.stringify(params)));
}
return {"stream":_stream,"start":_start};
},
findSegment_ : function(time) {
var segment = null;
if (this.metaData_) {
for ( var n = 0; n < this.metaData_.segments_.length; n++) {
segment = this.metaData_.segments_[n];
if (segment.startTime_ <= time * 1000 && time * 1000 < segment.startTime_ + segment.duration_) {
return segment;
}
}
}
return null;
},

playSegment_ : function() {
},

calculateBufferLength_ : function() {
if (!this.video_) {
return;
}
var _st = 0;
var _ed = 0;
this.preTime_ = this.video_.currentTime;
this.playerContext_.bufferLength_ = 0;
if (!this.playerContext_.bufferd_) {
return;
}
var start_ = -1;
var end_ = -1;
for ( var i = 0; i < this.playerContext_.bufferd_.length; i++) {
_st = this.playerContext_.bufferd_.start(i);
_ed = this.playerContext_.bufferd_.end(i);

if (this.isFirstSegment_) {
this.playerContext_.bufferLength_ = _ed - _st;
this.isFirstSegment_ = false;
if (this.onErrorReplay_) {
this.onErrorReplay_ = false;
if (_st <= this.errorReplayTime_ && this.errorReplayTime_ <= _ed) {
this.video_.currentTime = this.errorReplayTime_;
} else {
this.video_.currentTime = _st;
}
}
if(this.macSafariPattern_){
this.resetSeekTo_=Math.ceil(_st*1000)/1000;
this.video_.currentTime = this.resetSeekTo_;
}
if(this.playerContext_.metaDataType_ == p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeLive){
this.video_.currentTime = _st;
this.onBufferEndAndOnPrepared_();
this.video_.play();
this.playNextVideo_ = null;
}
} else {
if(start_==-1)
{
start_ = _st;
end_ = _ed;
}
else
{
if(_st - end_ < 1)//小于1秒内的不连贯buffer属于误差范围，归为一个buffer长度
{
end_ = _ed;
}
else
{
start_ = _st;
end_ = _ed;
}
}
if(this.preTime_<start_&&start_<1){
this.playerContext_.bufferLength_=(end_-start_);
continue;
}
if(this.preTime_&&start_<=this.preTime_&&end_>=this.preTime_)
{
this.playerContext_.bufferLength_=(end_-this.preTime_);
continue;
}
}
}
},

existTime_ : function(value) {
var b = false;
for ( var i = 0; i < this.playerContext_.buffers_.length; i++) {
var _start = this.playerContext_.buffers_[i][0];
var _end = this.playerContext_.buffers_[i][1];
if (value >= _start && value <= _end) {
b = true;
break;
}
}
return b;
},

createMediaSource_ : function() {
var media = null;
try {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::createMediaSource...",this.tag_));
media = new MediaSource();
this.onMediaSourceOpenBinded_ = this.onMediaSourceOpen_.bind(this);
this.onMediaSourceEndedBinded_ = this.onMediaSourceEnded_.bind(this);
this.onMediaSourceClosedBinded_ = this.onMediaSourceClosed_.bind(this);
this.onMediaSourceErrorBinded_ = this.onMediaSourceError_.bind(this);

media.addEventListener('sourceopen', this.onMediaSourceOpenBinded_);
media.addEventListener('sourceended', this.onMediaSourceEndedBinded_);
media.addEventListener('sourceclose', this.onMediaSourceClosedBinded_);
media.addEventListener('error', this.onMediaSourceErrorBinded_);

this.actived_ = true;
} catch (e) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Add media source failed: {1}",this.tag_,(e || "").toString()));
}
return media;
},

removeSourceBuffer_ : function() {
if (!this.mediaSource_) {
return;
}
// this.mediaSource_.endOfStream();
try {
if (this.sourceBuffer_) {
this.sourceBuffer_.abort();
this.mediaSource_.removeSourceBuffer(this.sourceBuffer_);
this.removeSourceEvents_(this.sourceBuffer_);
this.sourceBuffer_ = null;
}
} catch (e) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::remove sourcebuffer failed: {1}",this.tag_,(e || "").toString()));
}
},

clearMediaSource_ : function() {
this.mediaOpened_ = false;
if (!this.mediaSource_) {
return;
}

try {
if (this.sourceBuffer_) {
if(this.mediaSource_.readyState=="open"){
this.sourceBuffer_.abort();
this.mediaSource_.removeSourceBuffer(this.sourceBuffer_);
}
this.removeSourceEvents_(this.sourceBuffer_);
this.sourceBuffer_ = null;
}
this.mediaSource_.endOfStream();
this.mediaSource_.removeEventListener('sourceopen', this.onMediaSourceOpenBinded_);
this.mediaSource_.removeEventListener('sourceended', this.onMediaSourceEndedBinded_);
this.mediaSource_.removeEventListener('sourceclose', this.onMediaSourceClosedBinded_);
this.mediaSource_.removeEventListener('error', this.onMediaSourceErrorBinded_);
this.mediaSource_ = null;
} catch (e) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Clear media source failed: {1}",this.tag_,(e || "").toString()));
}
},

formatMimeTypeName_ : function(avcc, aac) {
var typeName = 'video/mp2t; codecs="avc1.64001f"';
if (avcc) {
if (this.playerContext_.isEncode_) {
typeName = 'video/mp4; codecs="' + avcc + ', ' + aac + '"';
} else {
typeName = 'video/mp2t; codecs="' + avcc + '"';
}
}
return typeName;
},
addMediaSourceHeader_ : function() {
var _b = false;
var typeName = this.formatMimeTypeName_(this.playerContext_.avccName_, this.playerContext_.aacName_);
var mediaDescriptions = "";
if (this.mediaSource_) {
if(!this.sourceBuffer_)
{
try {
if (this.mediaSource_.sourceBuffers.length > 0) {
return true;
}
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Add media source header, type: {1}, medias: {2}",this.tag_,typeName, mediaDescriptions));
this.sourceBuffer_ = this.mediaSource_.addSourceBuffer(typeName);
this.sourceIdle_ = true;
this.sourceMime_ = typeName;
this.addSourceEvents_(this.sourceBuffer_);
_b = true;
} catch (err) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Add media source header, type: {1}, medias: {2}, error: {3}",this.tag_,typeName,mediaDescriptions, err.toString()));
this.clearMediaSource_();
_b = false;
}
}
}
return _b;
},

onMediaSourceOpen_ : function(evt) {
if (!this.mediaSource_ || this.mediaSource_ != evt.target) {
return;
}

P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onMediaSource open, {1} arguments",this.tag_,arguments.length));
if (this.playerContext_.metaDataType_ == p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeVod) {
this.mediaSource_.duration = this.channel_.metaData_.totalDuration_ / 1000;
}
this.mediaOpened_ = true;
this.addMediaSourceHeader_();
this.playSegment_();
},

onMediaSourceEnded_ : function(evt) {
if (!this.mediaSource_ || this.mediaSource_ != evt.target) {
return;
}
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onMediaSource end, {1} arguments,({2}),({3})",this.tag_,arguments.length, arguments[1], arguments[2]));
},

onMediaSourceClosed_ : function(evt) {
if (!this.mediaSource_ || this.mediaSource_ != evt.target) {
return;
}
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onMediaSource close, {1} arguments",this.tag_,arguments.length));
this.actived_ = false;
this.mediaOpened_ = false;
},

onMediaSourceError_ : function(evt) {
if (!this.mediaSource_ || this.mediaSource_ != evt.target) {
return;
}
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::onMediaSource error, {1} arguments",this.tag_,arguments.length));
this.actived_ = false;
this.mediaOpened_ = false;
},

addSourceBufferListEvent_ : function() {
var bufferlists = this.mediaSource_.sourceBuffers;
this.onRemoveSourceBufferBinded_ = this.onRemoveSourceBuffer_.bind(this);
this.onAddSourceBufferBinded_ = this.onAddSourceBuffer_.bind(this);
bufferlists.addEventListener('removesourcebuffer', this.onRemoveSourceBufferBinded_);
bufferlists.addEventListener('addsourcebuffer', this.onAddSourceBufferBinded_);
},

onRemoveSourceBuffer_ : function() {
this.sourceBufferRemoved_ = true;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::removesourcebuffer...",this.tag_));
},

onAddSourceBuffer_ : function() {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onAddSourceBuffer...",this.tag_));
},

addSourceEvents_ : function(source) {
try {

this.onSourceUpdateEndBinded_ = this.onSourceUpdateEnd_.bind(this);
this.onSourceUpdateBinded_ = this.onSourceUpdate_.bind(this);
this.onSourceUpdateStartBinded_ = this.onSourceUpdateStart_.bind(this);
this.onSourceUpdateErrorBinded_ = this.onSourceUpdateError_.bind(this);

source.addEventListener('updateend', this.onSourceUpdateEndBinded_);
source.addEventListener('update', this.onSourceUpdateBinded_);
source.addEventListener('updatestart', this.onSourceUpdateStartBinded_);
source.addEventListener('error', this.onSourceUpdateErrorBinded_);
} catch (e) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Add source event failed: {1}",this.tag_,(e || "").toString()));
}
},

removeSourceEvents_ : function(source) {
try {
source.removeEventListener('updateend', this.onSourceUpdateEndBinded_);
source.removeEventListener('update', this.onSourceUpdateBinded_);
source.removeEventListener('updatestart', this.onSourceUpdateStartBinded_);
source.removeEventListener('error', this.onSourceUpdateErrorBinded_);
} catch (e) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Remove source event failed: {1}",this.tag_,(e || "").toString()));
}
},

onSourceUpdateStart_ : function(evt) {
if (!this.sourceBuffer_ || this.sourceBuffer_ != evt.target) {
return;
}
// P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Source update start",this.tag_));
this.sourceIdle_ = false;
},

onSourceUpdate_ : function(evt) {
if (!this.sourceBuffer_ || this.sourceBuffer_ != evt.target) {
return;
}
//		P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Source onUpdate",this.tag_));
},

onSourceUpdateEnd_ : function(evt) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Source updatedEnd",this.tag_));
if (!this.sourceBuffer_ || this.sourceBuffer_ != evt.target) {
return;
}
this.sourceIdle_ = true;
if (this.firstSeekStatus_ != undefined && this.firstSeekStatus_ == this.kFirstSeekWaitDownLoadSegment) {
this.video_.currentTime = this.preSeekTime_;
this.firstSeekStatus_ = this.kFirstSeekDownLoadSegmentOk;
}

try {
if(this.sourceBuffer_){
this.playerContext_.bufferd_ = this.sourceBuffer_.buffered;
}
else
{
this.playerContext_.bufferd_ = null;
}
} catch (err) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0} buffered error ({1})",this.tag_,err));
}

var currenTime = this.video_.currentTime;
var ranges_=[];
if (this.playerContext_.bufferd_ && this.playerContext_.bufferd_.length > 0) {
for ( var i = 0; i < this.playerContext_.bufferd_.length; i++) {
ranges_.push([this.playerContext_.bufferd_.start(i),this.playerContext_.bufferd_.end(i)]);
}
this.sendStatus_({"type":"VIDEO.BUFFER.RANGE","range":ranges_,"dur":this.getDuration_(),"time":currenTime});
}
},

onSourceUpdateError_ : function(evt) {
if (!this.sourceBuffer_ || this.sourceBuffer_ != evt.target) {
return;
}
this.removeSourceEvents_(this.sourceBuffer_);
this.sendStatus_({"type":"VIDEO.PLAY.ERROR","code":50001,"info":"update Source error!"});
},

addVideoEvents_ : function(video) {
var events = this.playerStatus_.VideoEvents;
this.videoStatusHandlerBinded_ = this.videoStatusHandler_.bind(this);
for ( var i = 0; i < events.length; i++) {
try {
video.addEventListener(events[i], this.videoStatusHandlerBinded_);
} catch (e) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Add video event({1}) failed: {2}",this.tag_,events[i], (e || "").toString()));
}
}
},

removeVideoEvents_ : function(video) {
var events = this.playerStatus_.VideoEvents;
for ( var i = 0; i < events.length; i++) {
try {
video.removeEventListener(events[i], this.videoStatusHandlerBinded_);
} catch (e) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Remove video event({1}) failed: {2}",this.tag_,events[i], (e || "").toString()));
}
}
},

videoStatusHandler_ : function(evt) {
if (!this.video_ || this.video_ != evt.target) {
return;
}

var time = this.video_.currentTime ? this.video_.currentTime.toFixed(1) : 0;
var type = evt.type;
switch (type) {
case "abort":
break;
case "canplay":
this.onVideoCanPlay_();
break;
case "canplaythrough":
this.onCanPlayThrough_();
break;
case "durationchange":
break;
case "emptied":
break;
case "ended":
this.onEnded_();
break;
case "error":
this.onError_();
break;
case "loadeddata":
this.onLoadedData_();
break;
case "loadedmetadata":
this.onVideoLoadedMetaData_();
break;
case "loadstart":
this.loadStart_();
break;
case "pause":
this.onVideoPuase_();
break;
case "play":
this.onVideoPlay_();
break;
case "playing":
this.onVideoPlaying_();
break;
case "progress":
this.onVideoProgress_();
break;
case "ratechange":
break;
case "seeked":
this.onVideoSeeked_();
break;
case "seeking":
this.onVideoSeeking_();
break;
case "stalled":
break;
case "suspend":
break;
case "timeupdate":
this.onVideoTimeUpdate_();
break;
case "volumechange":
break;
case "waiting":
this.onVideoWaiting_();
break;
default:
break;
}
},
onVideoProgress_ : function() {

},
loadStart_ : function() {
this.sendStatus_({type:"VIDEO.PLAY.START"});
this.playerContext_.videoStatus_ = this.videoStatus_.loadstart;
},

onLoadedData_ : function() {
this.sendStatus_({type:"VIDEO.PLAY.LOAD"});
this.playerContext_.videoStatus_ = this.videoStatus_.loadeddata;
},

onVideoLoadedMetaData_ : function() {
this.videoDuration_ = this.video_.duration ? this.video_.duration.toFixed(1) : 0;
this.sendStatus_({type:"VIDEO.META.INFO",info:{dur:this.videoDuration_}});
},

onVideoTimeUpdate_ : function() {
this.errorTimes_ = 0;
},

onVideoSeeking_ : function() {
var time = this.video_.currentTime ? this.video_.currentTime : 0;
if(this.preTime_ == time)
{
return;
}
this.preSeekTime_ = time;
this.sendStatus_({type:"VIDEO.PLAY.SEEKING",pause:this.video_.paused});
this.seekingTime_=this.global_.getMilliTime_();
this.playerContext_.videoStatus_ = this.videoStatus_.seeking;
this.seek2(this.preSeekTime_);
},

onVideoSeeked_ : function() {
var time = this.video_.currentTime ? this.video_.currentTime : 0;
this.playerContext_.videoStatus_ = this.videoStatus_.seeked;
this.seekedTime_ = this.global_.getMilliTime_();
var params={};
params["utime"]=this.seekedTime_-this.seekingTime_;
params["pos"]=time;
this.sendStatus_({type:"VIDEO.PLAY.SEEKED",params:params,pause:this.video_.paused});
if (!this.video_.paused) {
this.onVideoPlay_();
return;
}
this.video_.play();
},
onVideoPuase_ : function() {
this.playerContext_.videoStatus_ = this.videoStatus_.pause;
this.sendStatus_({type:"VIDEO.PLAY.PAUSE"});
},
onVideoPlay_ : function() {
if(this.playerContext_.videoStatus_ == this.videoStatus_.pause){
this.sendStatus_({type:"VIDEO.PLAY.RESUME"});
}
},
onVideoWaiting_ : function() {
},
onVideoCanPlay_ : function() {
if (this.playerContext_.videoStatus_ == this.videoStatus_.loadeddata) {
this.playerContext_.videoStatus_ = this.videoStatus_.canplay;
if (this.firstSeekTime_) {
this.video_.currentTime = this.firstSeekTime_;
}
}
},
onCanPlayThrough_ : function() {
},
onVideoPlaying_ : function() {
this.playerContext_.videoStatus_ == this.videoStatus_.playing;
if(this.firstPlayingTime_==-1)
{
this.firstPlayingTime_=this.global_.getMilliTime_();
this.sendStatus_({"type":"VIDEO.PLAY.FIRST","init":this.firstPlayTime_,"meta":this.channel_.channelOpenedTime_,"add":this.firstAddDataTime_,"playing":this.firstPlayingTime_})
return;
}
this.sendStatus_({type:"VIDEO.PLAY.PLAYING"});
},

onBufferEndAndOnPrepared_ : function() {
if (this.playerContext_.videoStatus_ == this.videoStatus_.loadstart) {
this.playerContext_.videoStatus_ = this.videoStatus_.canplay;
if (!this.firstOnPrepared_) {
// throw the onprepared event at first play only
this.firstOnPrepared_ = true;
this.sendStatus_({type:"VIDEO.PLAY.PREPARED"});
} else {
this.video_.play();
}
}
},

onEnded_ : function(from) {
var time = this.video_.currentTime ? this.video_.currentTime.toFixed(1) : 0;
this.sendStatus_({type:"VIDEO.PLAY.END"});
},

onError_ : function() {
var time = this.video_.currentTime ? this.video_.currentTime.toFixed(1) : 0;
var code = -100;
if (this.video_ && this.video_.error) {
code = this.video_.error.code;
}
this.actived_ = false;
var nowTime = new Date().getTime();
if (nowTime - this.lastErrorTime_ >= 4000) {
this.lastErrorTime_ = nowTime;
return true;
}
var info = "";
switch (code) {
case 1:
info = "MEDIA_ERR_ABORTED";
break;
case 2:
info = "MEDIA_ERR_NETWORK";
break;
case 3:
info = "MEDIA_ERR_DECODE";
break;
case 4:
info = "MEDIA_ERR_SRC_NOT_SUPPORTED";
break;
default:
info = "";
}
code += 10000;
this.sendStatus_({type:"VIDEO.PLAY.ERROR",code:code,info:info});
return false;
},

stop_ : function() {
this.actived_ = false;
this.stopFetchTimer_();
this.clearMediaSource_();
if (this.video_) {
this.video_.pause();
this.removeVideoEvents_(this.video_);
// this.video_ = null;
}

this.blockList_ = [];
this.toMp4_ = null;
this.initFnum_ = 0;
this.metaData_ = null;
this.nextSegmentId_ = 0;
this.preTime_ = 0;
this.preSegmentId_ = -1;
this.playerContext_ = new p2p$.com.webp2p.core.player.Context();
this.breakTimes_ = 0;
this.bufferTimes_ = 0;
},

pause_ : function() {
if (this.video_) {
this.video_.pause();
}
},
replay_ : function() {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::replay ...",this.tag_));
this.seek_(1);
},

seek_ : function(postion) {
},
getCurrentBuffered_ : function() {
var buffer = -1;
return buffer;
},
getCurrentPosition_ : function() {
if (this.video_) {
return this.video_.currentTime;
}
return 0;
},

getDuration_ : function() {
var dur = -1;
if(this.playerContext_.metaDataType_== p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeVod)
{
dur = this.channel_.metaData_.totalDuration_ / 1000;
}
return dur;
},
sendStatus_:function(params)
{
if(this.channel_){
this.channel_.sendStatus_(params,true);
}
this.wrapper_.sendStatus_(params);
}
});
p2p$.ns('com.webp2p.core.player');
p2p$.com.webp2p.core.player.PLAY_TYPE = {
kPlayTypeBinary : 0,// 二进制方式
kPlayTypeM3U8 : 1,
};

p2p$.com.webp2p.core.player.VIDEO_STATUS = {
loadstart : 'loadstart',
loadeddata : 'loadeddata',
canplay : 'canplay',
seeking : 'seeking',
seeked : 'seeked',
playing : 'playing',
pause : 'pause',
breakstart : 'breakstart',
breakend : 'breakend',
replay : 'replay'
};

p2p$.com.webp2p.core.player.PLAY_STATES = {
status : '',
IDE : 'IDE',
PLAY : 'PLAY',
PLAYING : 'PLAYING',
PAUSE : 'PAUSE',
RESUME : 'RESUME',
SEEKING : 'SEEKING',
SEEKED : 'SEEKED',
// /video 事件
VideoEvents : [ "abort",// 当音频/视频的加载已放弃时
"canplay",// 当浏览器可以播放音频/视频时
"canplaythrough",// 当浏览器可在不因缓冲而停顿的情况下进行播放时
"durationchange",// 当音频/视频的时长已更改时
"emptied",// 当目前的播放列表为空时
"empty", "ended",// 当目前的播放列表已结束时
"error",// 当在音频/视频加载期间发生错误时
"loadeddata",// 当浏览器已加载音频/视频的当前帧时
"loadedmetadata",// 当浏览器已加载音频/视频的元数据时
"loadstart",// 当浏览器开始查找音频/视频时
"pause",// 当音频/视频已暂停时
"play",// 当音频/视频已开始或不再暂停时
"playing",// 当音频/视频在已因缓冲而暂停或停止后已就绪时
"progress",// 当浏览器正在下载音频/视频时
"ratechange",// 当音频/视频的播放速度已更改时
"seeked",// 当用户已移动/跳跃到音频/视频中的新位置时
"seeking",// 当用户开始移动/跳跃到音频/视频中的新位置时
"stalled",// 当浏览器尝试获取媒体数据，但数据不可用时
"suspend",// 当浏览器刻意不获取媒体数据时
"timeupdate",// 当目前的播放位置已更改时
"volumechange",// 当音量已更改时
"waiting" ]
};

p2p$.com.webp2p.core.player.Context = JClass.extend_({
playType_ : -1,
isEncode_ : false,
metaDataType_ : 0,
avccName_ : null,
aacName_ : null,
bufferd_ : null,
bufferLength_ : 0,
playState_ : "PLAY",
buffers_ : null,
currentPlayTime_ : 0,
videoStatus_ : "IDE",
lastCurrentTime_ : -1,

init : function() {
this.playType_ = -1;
this.isEncode_ = false;
this.metaDataType_ = -1;
this.avccName_ = null;
this.aacName_ = null;
this.bufferd_ = null;
this.bufferLength_ = 0;
this.playState_ = "PLAY";
this.buffers_ = [];
this.currentPlayTime_ = 0;
this.videoStatus_ = "";
this.lastCurrentTime_ = -1;
}
});
p2p$.ns('com.webp2p.core.player');

p2p$.com.webp2p.core.player.Creator = JClass.extend_({
channel_ : null,
player_ : null,
url_ : "",
video_ : null,
stream_ : null,
wrapper_ : null,
tag_:"com::webp2p::core::player::Creator",

init : function() {
this.channel_ = null;
this.player_ = null;
this.url_ = "";
this.video_ = null;
this.stream_ = null;
},

initialize_ : function(wrapper, url, video, stream) {
this.wrapper_ = wrapper;
this.url_ = url;
this.video_ = video;
this.stream_ = stream;
},

changeChannel_ : function(url) {
this.url_ = url;
this.channel_ != null ? this.channel_.close_():"";
this.player_.stop_();
this.player_ = null;
},

createPlayer_ : function() {

this.channel_ = this.stream_.requestPlay_(this.url_);
if (this.channel_ != null) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Create player open channel({1}) success",this.tag_,this.url_));
this.channel_.setListener_(this.wrapper_);
this.channel_.open();
if (this.channel_.type_ == p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeVod) {
// VOD
this.player_ = new p2p$.com.webp2p.core.player.VodPlayer(this.wrapper_);
if (this.wrapper_.config_.startTime>0) {
this.channel_.setFirstSeekTime_(this.wrapper_.config_.startTime);
}
} else {
// LIVE
this.player_ = new p2p$.com.webp2p.core.player.LivePlayer(this.wrapper_);
}

if (this.player_ != null) {
this.player_.initialize_(this.url_, this.video_, this.stream_, this.channel_);
if (this.player_.playerContext_.metaDataType_ == p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeVod) {
if (this.wrapper_.config_.startTime>0) {
this.player_.firstSeekStatus_ = this.player_.kFirstSeekInit;
this.player_.firstSeekPosition_ = this.wrapper_.config_.startTime;
}
}
} else {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}.Create player failed",this.tag_));
}
} else {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Create player open channel({1}) failed",this.tag_,this.url_));
}
return this.player_;
}
});
p2p$.ns('com.webp2p.core.player');
p2p$.com.webp2p.core.player.LivePlayer = p2p$.com.webp2p.core.player.BasePlayer.extend_({
isFirstSegment_ : false,
firstIndexUsed_ : false,
playNextDelayTime_ : 0,
suspendTimes_ : 0,

init : function(wrapper) {
this._super(wrapper);
this.tag_="com::webp2p::core::player:LivePlayer";
this.isFirstSegment_ = false;
this.playNextDelayTime_ = 0;
this.playerContext_.metaDataType_ = p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeLive;
this.lastDiscontinuitySegment_ = 0;
this.lastHandleSuspendTime_ = 0;
if(p2p$.com.webp2p.segmentmp4 != undefined)
{
this.toMp4_ = new p2p$.com.webp2p.segmentmp4.ToMp4();
}
},
play : function() {
if (!this.video_) {
return;
}
if (this.video_.paused) {
this.video_.play();
}
this.canHandleSuspend_ = true;
},
getBlock_ : function(nextSegment) {
if (!this.metaData_) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Meta data is null",this.tag_));
return null;
}

for ( var n = 0; n < this.metaData_.segments_.length - 1; n++) {
var segment = this.metaData_.segments_[n];
var segment2 = this.metaData_.segments_[n + 1];
segment.nextId_ = segment2.id_;
if (n == this.metaData_.segments_.length - 2) {
segment2.nextId_ = segment2.id_;
}
}

for ( var n = 0; n < this.metaData_.segments_.length; n++) {
var segment = this.metaData_.segments_[n];
if (nextSegment == segment.id_) {
return segment;
}
if (n == this.metaData_.segments_.length - 1) {
P2P_ULOG_TRACE(P2P_ULOG_FMT("{0}::segment ({1}) not found,return default segment({2})",this.tag_,nextSegment,this.metaData_.segments_[0].id_));
}
}
return this.metaData_.segments_[0];
},

refreshUrgentSegment_ : function(segmentId) {
if (!this.playerContext_.bufferd_) {
return;
}
var vtime = this.video_.currentTime;
if (vtime > 1) {
var segment = this.getSegmentByVideoTime_(vtime);
if (segment) {
this.urgentSegment_ = segment.id_;
P2P_ULOG_TRACE(P2P_ULOG_FMT("{0}::refreshUrgentSegment1 requestSegment({1}),urgentSegment({2})",this.tag_,segmentId,this.urgentSegment_));
return;
}
}
this.urgentSegment_ = segmentId - 1;
P2P_ULOG_TRACE(P2P_ULOG_FMT("{0}::refreshUrgentSegment2 requestSegment({1}),urgentSegment({2})",this.tag_,segmentId, this.urgentSegment_));
},

getSegmentByVideoTime_ : function(time) {
time = time * 1000;
var temp = null;
for ( var n = 0; n < this.metaData_.segments_.length; n++) {
var segment = this.metaData_.segments_[n];
// the current urgentSegment should be the latest urgentSegment_
if (segment.timestamp_ <= time && time <= segment.timestamp_ + segment.duration_ && segment.id_ > this.lastDiscontinuitySegment_) {
temp = segment;
}
}
return temp;
},
playSegment_ : function() {
this.calculateBufferLength_();
if (!this.playerContext_.avccName_&&this.playerContext_.isEncode_) {
return;
}
if (!this.mediaSource_) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Create media source ...",this.tag_));
this.mediaSource_ = this.createMediaSource_();
this.video_.src = window.URL.createObjectURL(this.mediaSource_);
}
//mediasource创建超时，5秒超时
if (!this.sourceBuffer_) {
if (!this.mediaOpened_) {
this.delayTime_++;
if (this.delayTime_ > 50) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Play segment with delay count({1})",this.tag_,this.delayTime_));
}
return;
}
this.addMediaSourceHeader_();
return;
}
if (this.sourceBuffer_.updating) {
return;
}
if(this.blockList_.length==0)
{
return;
}
var streamInfo = this.blockList_[0];
if (streamInfo.block.index_ == 0 && !this.firstIndexUsed_) {
this.isFirstSegment_ = true;
this.firstIndexUsed_ = true;
}

if (this.addedSegment_ && streamInfo.block.timestamp_ < this.addedSegment_.timestamp_) {
if (!this.showDiscontinuity_) {
if (streamInfo.block.discontinuity_) {
this.showDiscontinuity_ = true;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::discontinuity true, segment({1})",this.tag_, streamInfo.block.id_));
} else {
streamInfo.block.discontinuity_ = true;
this.showDiscontinuity_ = true;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::discontinuity false, segment({1})",this.tag_, streamInfo.block.id_));
}
}
}

if (streamInfo.block.discontinuity_ && !this.playNextVideo_ && this.lastDiscontinuitySegment_ != streamInfo.block.id_) {
if (this.playerContext_.bufferLength_ < 0.1 || this.playNextDelayTime_ > 15) {
var offsetTime = ((streamInfo.block.timestamp_ || 0)) / 1000;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Start to play next video, buffer({1}), delay({2}), offset({3}), mime({4}, {5} => {6})",this.tag_,this.playerContext_.bufferLength_.toFixed(3), this.playNextDelayTime_, offsetTime, streamInfo.mime == this.sourceMime_ ? "same": "diff", this.sourceMime_, streamInfo.mime));
// this.video_.pause();
this.video_.currentTime = offsetTime;
if (streamInfo.mime != this.sourceMime_) {
// play next video
this.clearMediaSource_();
this.playNextVideo_ = true;
this.isFirstSegment_ = true;
this.playerContext_.bufferd_ = null;
this.playerContext_.avccName_ = null;
this.playerContext_.aacName_ = null;
this.blockList_ = [];
} else if (this.sourceBuffer_.buffered.length > 0) {
this.sourceBuffer_.abort()
this.sourceBuffer_.remove(0, this.sourceBuffer_.buffered.end(this.sourceBuffer_.buffered.length - 1));
}
this.preTime_ = 0;
this.playNextDelayTime_ = 0;
this.showDiscontinuity_ = false;
this.addedSegment_ = null;
this.playerContext_.bufferLength_ = 0;
this.lastDiscontinuitySegment_ = streamInfo.block.id_;
} else {
if (this.playerContext_.bufferLength_ < 1) {
this.playNextDelayTime_++;
}
}
//			this.nextSegmentId_ = streamInfo.block.id_;
return null;
}
//		this.handleSuspend_();
if (this.blockList_.length <= 0 || this.playerContext_.bufferLength_ >= this.config_.bufferLength) {
return;
}
this.blockList_.shift();
if(this.firstAddDataTime_==-1)
{
this.firstAddDataTime_=this.global_.getMilliTime_();
}
this.sourceBuffer_.appendBuffer(streamInfo.data);
this.addedSegment_ = streamInfo.block;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Add data success ,buffer length({1}),blockLength ({2}s), segmentId({3}), startTime({4}), timestamp({5}), discontinuity({6}), segment length ({7}), prev segment({8}), next segment({9})",this.tag_, this.playerContext_.bufferLength_.toFixed(2), streamInfo.block.duration_ / 1000,streamInfo.block.id_, this.global_.getCurentTime_(streamInfo.block.startTime_ / 1000), streamInfo.block.timestamp_,streamInfo.block.discontinuity_, streamInfo.data.length, this.preSegmentId_, this.nextSegmentId_));
},

handleSuspend_ : function() {
if (!this.playerContext_.bufferd_ || !this.canHandleSuspend_) {
return;
}
var nowTime = new Date().getTime();
if (this.lastHandleSuspendTime_ + 500 > nowTime) {
return;
}
this.lastHandleSuspendTime_ = nowTime;
var temp = this.playerContext_.currentPlayTime_;
var bufferIndex = -1;
if (Math.abs(this.video_.currentTime - temp) < 0.1) {
// break
for ( var i = 0; i < this.playerContext_.bufferd_.length; i++) {
var start = this.playerContext_.bufferd_.start(i);
if (start > temp) {
bufferIndex = i;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} start ({1}),length ({2}),i ({3}),bufferIndex ({4})",this.tag_, start,this.playerContext_.bufferd_.length, i, bufferIndex));
break;
}
}
if (bufferIndex != -1) {
var seekto = this.playerContext_.bufferd_.start(bufferIndex);
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} replay suspend seekto ({1}) ...",this.tag_, seekto));
try {
// this.video_.pause();
this.video_.currentTime = seekto;
this.video_.play();
if (bufferIndex >= 2) {
if (!this.macSafariPattern_) {
this.sourceBuffer_.remove(0, this.playerContext_.bufferd_.end(bufferIndex - 2));
}
this.playerContext_.bufferd_ = this.sourceBuffer_.buffered;
}
} catch (e) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0} replay seek or remove error({1})",this.tag_, e));
}
this.suspendTimes_ = 0;
} else {
if (!this.suspendTimes_) {
this.suspendTimes_ = 0;
}
this.suspendTimes_++;
if (this.suspendTimes_ > 5) {
var seekto = temp + 0.2;
this.video_.currentTime = seekto;
this.suspendTimes_ = 0;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} replay2 suspend seekto ({1}) ...",this.tag_, seekto));
}
}
} else {
this.suspendTimes_ = 0;
}
this.playerContext_.currentPlayTime_ = this.video_.currentTime;
},

onVideoSeeking_ : function() {
},

onVideoSeeked_ : function() {
// this.video_.play();
},

onError_ : function() {
this.errorTimes_++;
this._super();
if (this.errorTimes_ > this.maxErrorTimes_) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Player error {1} times...,return error",this.tag_,this.errorTimes_));
return;
}
this.clearMediaSource_();
// this.removeSourceBuffer_();
this.playNextVideo_ = true;
this.isFirstSegment_ = true;
this.playerContext_.bufferd_ = null;
this.playerContext_.avccName_ = null;
this.playerContext_.aacName_ = null;
this.blockList_ = [];
this.video_.pause();
this.onErrorReplay_ = true;
var findFlag = 0;
var segment = this.getSegmentByVideoTime_(this.playerContext_.currentPlayTime_);
if (segment) {
this.nextSegmentId_ = segment.id_;
findFlag = 1;
} else {
var timestamp = Date.parse(new Date());
var seek2Segment = this.findSegment_(timestamp / 1000);
if (seek2Segment) {
this.nextSegmentId_ = seek2Segment.id_;
findFlag = 2;
} else {
this.nextSegmentId_ = this.addedSegment_ ? this.addedSegment_.id_ : 0;
findFlag = 3;
}
}
this.lastDiscontinuitySegment_ = 0;
this.playerContext_.bufferLength_ = 0;
this.actived_ = true;
this.playNextDelayTime_ = 0;
this.showDiscontinuity_ = false;
this.addedSegment_ = null;
this.playerContext_.bufferLength_ = 0;
this.errorReplayTime_ = this.playerContext_.currentPlayTime_;
this.playerContext_.currentPlayTime_ = 0;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::replay find segment by ({1}),nextSegmentId({2}),errorReplayTime({3})",this.tag_,findFlag,this.nextSegmentId_, this.errorReplayTime_));
},

onVideoTimeUpdate_ : function() {
this._super();
// this.playerContext_.currentPlayTime_ = this.video_.currentTime;
},
seek_ : function(postion) {
return;
}
});
p2p$.ns('com.webp2p.core.player');
p2p$.com.webp2p.core.player.VodPlayer = p2p$.com.webp2p.core.player.BasePlayer.extend_({
firstSeekStatus_ : -1,
addNextSegmentId_ : false,
addedSegment_ : null,
resetSeekTo_ : 0,

init : function(wrapper) {
this._super(wrapper);
this.tag_="com::webp2p::player::VodPlayer";
this.firstSeekStatus_ = -1;
this.firstSeekPosition_ = 0;
this.resetSeekTo_ = 0;
this.addNextSegmentId_ = false;
this.playerContext_.metaDataType_ = p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeVod;
},
getBlock_ : function(nextSegment) {
if (this.metaData_) {
if (!this.addNextSegmentId_) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::getBlock first to set MetaData nextId for segment!",this.tag_));
for ( var n = 0; n < this.metaData_.segments_.length - 1; n++) {
var segment = this.metaData_.segments_[n];
var segment2 = this.metaData_.segments_[n + 1];
segment.nextId_ = segment2.id_;
if (n == this.metaData_.segments_.length - 2) {
segment2.nextId_ = -1;
}
this.addNextSegmentId_ = true;
}
}
for ( var n = 0; n < this.metaData_.segments_.length; n++) {
var segment = this.metaData_.segments_[n];
if (segment.id_ == nextSegment) {
return segment;
}
}
} else {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Meta data is null",this.tag_));
return null;
}
},

playSegment_ : function() {
if (!this.playerContext_.avccName_ && this.playerContext_.isEncode_) {
return;
}

if (!this.mediaSource_) {
P2P_ULOG_TRACE(P2P_ULOG_FMT("{0}::Create media source ...", this.tag_));
this.sourceBuffer_ = null;
this.mediaSource_ = this.createMediaSource_();
this.video_.src = window.URL.createObjectURL(this.mediaSource_);
if (!this.firstSetSrc_) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onvideosrc ...", this.tag_));
this.firstSetSrc_ = true;
}
}

if (!this.sourceBuffer_) {
this.delayTime_++;
if (this.delayTime_ > 500) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Play segment with delay count({1})", this.tag_, this.delayTime_));
}
return;
}
if (this.sourceBuffer_.updating) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::sourceBuffer_.updating ({1})", this.tag_, this.sourceBuffer_.updating));
return;
}
//判断视频在缓冲中
var currentTime = this.video_.currentTime.toFixed(1);
var vRemaining = this.video_.duration - this.video_.currentTime;
if (this.playerContext_.lastCurrentTime_ == currentTime && !this.video_.paused && !this.video_.ended){
if(this.playerContext_.bufferLength_ > 3)//存在缓冲，属于卡顿
{
this.breakTimes_++;//卡顿计数
if(this.playerContext_.videoStatus_ != p2p$.com.webp2p.core.player.VIDEO_STATUS.seeking&&this.breakTimes_>=5){
this.resetSeekTo_ = this.resetSeekTo_ + this.fectchInterval_*this.breakTimes_;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} time({1}),seekTo({2}),resetSeekTo({3}), bufferLength({4})", this.tag_,currentTime, Number(currentTime)+this.resetSeekTo_/1000,this.resetSeekTo_, this.playerContext_.bufferLength_));
this.video_.currentTime = Number(currentTime)+this.resetSeekTo_/1000;
// this.video_.play();
this.breakTimes_=0;
}
}else if (Math.abs(vRemaining) > 5 ) {
this.bufferTimes_++;//加缓冲载数据计数
if (this.bufferTimes_ > 5) {
if (this.playerContext_.videoStatus_ == this.videoStatus_.canplay
|| this.playerContext_.videoStatus_ == this.videoStatus_.seeked
|| this.playerContext_.videoStatus_ == this.videoStatus_.seeking
|| this.playerContext_.videoStatus_ == this.videoStatus_.breakend) {
this.sendStatus_({type:"VIDEO.BUFFER.START"});
this.playerContext_.videoStatus_ = this.videoStatus_.breakstart;
}
}
}
}
if (this.playerContext_.lastCurrentTime_ != currentTime) {
if (this.playerContext_.videoStatus_ == this.videoStatus_.breakstart) {
this.sendStatus_({type:"VIDEO.BUFFER.END"});
this.playerContext_.videoStatus_ = this.videoStatus_.breakend;
}
this.resetSeekTo_=0;
this.breakTimes_ = 0;
this.bufferTimes_ = 0;
this.playerContext_.lastCurrentTime_ = currentTime;
}
//////
this.calculateBufferLength_();
if (this.blockList_.length <= 0 || this.playerContext_.bufferLength_ >= this.config_.bufferLength) {
return;
}
var streamInfo = this.blockList_[0];
this.blockList_.shift();
if (streamInfo.block.index_ == 0 && this.playerContext_.videoStatus_ != this.videoStatus_.seeking) {
this.isFirstSegment_ = true;
}
var existTime = streamInfo.block.startTime_ / 1000 + 2;
this.addedSegment_ = streamInfo.block;
if (this.existTime_(existTime) && !this.onErrorReplay_) {//判断buffer中是否存在该时刻的数据
P2P_ULOG_WARNING(P2P_ULOG_FMT("{0} Add data exist,ignore! segmentId({1})",this.tag_,streamInfo.block.id_));
return;
}
if(this.firstAddDataTime_==-1)//记录首次添加数据时间
{
this.firstAddDataTime_=this.global_.getMilliTime_();
}
this.sourceBuffer_.appendBuffer(streamInfo.data);
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Add data success ,buffer({1}),block({2}s), segment({3}), start time ({4}),  timestamp({5}),segment length ({6})",this.tag_,this.playerContext_.bufferLength_.toFixed(2), streamInfo.block.duration_ / 1000, streamInfo.block.id_,streamInfo.block.startTime_ / 1000, streamInfo.block.timestamp_, streamInfo.data.length));
},

seek : function(postion) {
if (!this.mediaSource_) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Seek postion ({1}),mediaSource is null",this.tag_,postion));
return;
}
if (isNaN(postion)) {
return;
}
if (postion <= 1) {
postion = 1;
}
if (postion >= this.mediaSource_.duration) {
postion = this.mediaSource_.duration - 0.5;
}
var time = this.video_.currentTime ? this.video_.currentTime.toFixed(1) : 0;
this.preSeekTime_ = Number(postion).toFixed(0);
this.video_.currentTime = postion;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Seek vtime({1}) seekTo({2})",this.tag_,time, this.preSeekTime_));
},

seek2 : function(time) {
var seek2Segment = this.findSegment_(time);
if (seek2Segment) {
this.nextSegmentId_ = seek2Segment.id_;
try {
this.sourceBuffer_.abort();
} catch (e) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::seek2 abort error({1})",this.tag_,e));
}
this.blockList_ = [];
this.playerContext_.bufferLength_ = 0;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::seek2 seek to({1}), next segment({2}), state({3})",this.tag_,time, this.nextSegmentId_,this.playerContext_.playState_));
this.onLoop_();
} else {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::seek2 find segment failed, seek to({1}), next segment({2})",this.tag_,time,this.nextSegmentId_));
}
},

onVideoTimeUpdate_ : function() {
if (parseFloat(this.videoDuration_) < 1) {
return;
}
this._super();
var time = parseFloat(this.video_.currentTime ? this.video_.currentTime.toFixed(1) : 0);
this.playerContext_.currentPlayTime_ = time;
var remain = parseFloat(this.videoDuration_) - time;

// put a compulsory end event
if (Math.abs(remain) < 5 && !this.endTimer_) {
var me = this;
this.endTimer_ = setTimeout(function() {
me.endTimer_ = null;
if (parseFloat(me.videoDuration_) - parseFloat(me.video_.currentTime) < 5) {
if (!me.VideoEnd_) {
me.VideoEnd_ = true;
me.onEnded_(true);
}
}
}, 5000);
} else {
if (this.endTimer_ && Math.abs(remain) > 5) {
clearTimeout(this.endTimer_);
this.endTimer_ = null;
}
}

if (Math.abs(remain) <= 5) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Video time update, time({1}) remain({2})",this.tag_,time, remain));
}
if (Math.abs(remain) <= 0.5 && !this.VideoEnd_) {
this.VideoEnd_ = true;
this.onEnded_(false);
}
if (this.VideoEnd_ && parseFloat(this.videoDuration_) - time > 0.5) {
this.VideoEnd_ = null;
}
},
getCurrentBuffered : function() {
var buffer = -1;
if (this.video_) {
var curTime = this.video_.currentTime ? this.video_.currentTime : 0;
for ( var i = 0; i < this.video_.buffered.length; i++) {
var start = this.video_.buffered.start(i);
var end = this.video_.buffered.end(i);
if (start <= curTime && curTime <= end) {
buffer = end;
break;
}
}
}
return buffer;
},
onError_ : function() {
var isContinue = this._super();
if (!isContinue) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Player error stop play ...",this.tag_));
this.stop_();
return false;
}
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Player error {1} times... init a new one",this.tag_,this.errorTimes_));
this.clearMediaSource_();
this.isFirstSegment_ = true;
this.onErrorReplay_ = true;
this.playerContext_.bufferd_ = null;
this.playerContext_.avccName_ = null;
this.playerContext_.aacName_ = null;
this.playerContext_.bufferLength_ = 0;
this.firstProgress_ = null;
this.blockList_ = [];
this.actived_ = true;
this.errorReplayTime_ = this.playerContext_.currentPlayTime_ + 1;
var seek2Segment = this.findSegment_(this.errorReplayTime_);
if (seek2Segment) {
this.nextSegmentId_ = seek2Segment.id_;
} else {
this.nextSegmentId_ = this.addedSegment_ ? this.addedSegment_.id_ : 0;
}

this.addedSegment_ = null;
this.playerContext_.currentPlayTime_ = 0;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::replay segment({1}),nextSegmentId2({2}),errorReplayTime({3})",this.tag_,(seek2Segment != null), this.nextSegmentId_, this.errorReplayTime_));
}
});
p2p$.ns("com.webp2p.core.storage");

p2p$.com.webp2p.core.storage.BucketStatic = {
kLowDataCapacity : 30 * 1024 * 1024,
kUpperMemoryCapacity : 60 * 1024 * 1024,
kUpperDataCapacity : 1000 * 1024 * 1024
},

p2p$.com.webp2p.core.storage.Bucket = JClass.extend_({
name_ : "",
opened_ : false,
dataSize_ : 0,
dataCapacity_ : 0,
upperCapacity_ : 0,
maxOpenBlocks_ : 0,

init : function(name) {
this.name_ = name;
this.opened_ = false;
this.dataSize_ = 0;
this.dataCapacity_ = p2p$.com.webp2p.core.storage.BucketStatic.kLowDataCapacity;
this.upperCapacity_ = p2p$.com.webp2p.core.storage.BucketStatic.kUpperDataCapacity;
this.maxOpenBlocks_ = 500;
},

getName_ : function() {
return this.name_;
},

getDataSize_ : function() {
return this.dataSize_;
},

getDataCapacity_ : function() {
return this.dataCapacity_;
},

getMaxOpenBlocks_ : function() {
return this.maxOpenBlocks_;
},

setDataCapacity_ : function(size) {
var old = this.dataCapacity_;
if (size <= this.upperCapacity_) {
this.dataCapacity_ = p2p$.com.webp2p.core.storage.BucketStatic.kLowDataCapacity > size ? p2p$.com.webp2p.core.storage.BucketStatic.kLowDataCapacity
: size;
} else {
this.dataCapacity_ = this.upperCapacity_;
}
return old;
},

available : function() {
return this.opened_;
},
});
/*
* 内存管理篮子
* */
p2p$.ns("com.webp2p.core.storage");

p2p$.com.webp2p.core.storage.MemoryBlock = JClass.extend_({
archived_ : false,
activeTime_ : 0,
writeTime_ : 0,
archiveTime_ : 0,
data_ : "",

init : function() {
this.archived_ = false;
this.activeTime_ = 0;
this.writeTime_ = 0;
this.archiveTime_ = 0;
this.data_ = "";// new ArrayBuffer(0);
},
});

p2p$.com.webp2p.core.storage.MemoryBucket = p2p$.com.webp2p.core.storage.Bucket.extend_({
lowCapacity_ : false,
blocks_ : null,
manager_ : null,

init : function(manager) {
this.manager_ = manager;
this._super("memory");
this.lowCapacity_ = false;
this.blocks_ = new p2p$.com.common.Map();// p2p$.com.webp2p.core.storage.MemoryBlock();
},

open : function() {
this.blocks_.clear();
this.lowCapacity_ = false;
this.dataCapacity_ = 200 * 1024 * 1024;// memory.availableBytes_ / 5;
this.upperCapacity_ = this.dataCapacity_;
if (this.dataCapacity_ < p2p$.com.webp2p.core.storage.BucketStatic.kLowDataCapacity) {
this.lowCapacity_ = true;
this.dataCapacity_ = p2p$.com.webp2p.core.storage.BucketStatic.kLowDataCapacity;
this.upperCapacity_ = this.dataCapacity_;
} else if (this.dataCapacity_ > p2p$.com.webp2p.core.storage.BucketStatic.kUpperMemoryCapacity) {
this.dataCapacity_ = p2p$.com.webp2p.core.storage.BucketStatic.kUpperMemoryCapacity;
}
P2P_ULOG_INFO(P2P_ULOG_FMT("core::storage::MemoryBucket::Open successfully"));
this.opened_ = true;
return true;
},

close : function() {
this.opened_ = false;
this.blocks_.clear();
P2P_ULOG_INFO(P2P_ULOG_FMT("core::storage::MemoryBucket::Closed"));
return true;
},

clearExpiredBlocks_ : function(currentId) {
var removedCount = 0;
var minBlockTime = -1;
var elemIndex = null;
for ( var n = 0; n < this.blocks_.length; n++) {
// ignore current block
var elem = this.blocks_.element(n);
if (elem.key == currentId) {
continue;
}
if (minBlockTime < 0 || elem.value.writeTime_ < minBlockTime) {
elemIndex = elem;
minBlockTime = elem.value.writeTime_;
}
}
if (elemIndex != this.blocks_.element(this.blocks_.length - 1)) {
P2P_ULOG_INFO(P2P_ULOG_FMT("core::storage::MemoryBucket::Clear expire block({0}), size({1}), last write({2})", elemIndex.key,
elemIndex.value.data_.length, p2p$.com.common.String.formatTime_(elemIndex.value.writeTime_, "yyyy-M-d h:m:s")));

removedCount++;
this.dataSize_ -= elemIndex.value.data_.length;
this.blocks_.erase(elemIndex.key);
var items = elemIndex.key.split("//");
if (items.length >= 3) {
for ( var n = 0; n < this.manager_.channels_.length; n++) {
var mapItem = this.manager_.channels_.element(n);
if (mapItem.value.id_ == items[1]) {
var channel = mapItem.value;
channel.resetSegmentPieceCompletion_(items[2]);
}
}
}

}
return removedCount;
},

exists : function(objectId) {
return this.blocks_.find(objectId);
},

archived : function(objectId) {
},

read : function(objectId, offset, size) {
var itrFind = this.blocks_.find(objectId);
if (!itrFind) {
return -1;
}
if (typeof size == 'undefined') {
size = p2p$.com.webp2p.core.common.Number.maxUnsignedValue_();
}
var block = this.blocks_.get(objectId);
var stream = null;
if (size == p2p$.com.webp2p.core.common.Number.maxUnsignedValue_()) {
stream = block.data_;
} else if (offset == 0 && size == block.data_.length) {
stream = block.data_;
} else {
stream = block.data_.subarray(offset, offset + size);
}
return stream;
},

write : function(objectId, offset, data, size) {
if (this.dataSize_ + size > this.dataCapacity_) {
while (this.dataSize_ + size > this.dataCapacity_) {
if (this.clearExpiredBlocks_(objectId) <= 0) {
break;
}
}
}
var block = this.blocks_.get(objectId);
block.activeTime_ = block.writeTime_ = p2p$.com.common.Global.getMilliTime_();

var minSize = offset + size;
var allocSize = (minSize > block.data_.length) ? (minSize - block.data_.length) : 0;
if (allocSize > 0) {
block.data_ = new Uint8Array(minSize);
this.dataSize_ += allocSize;
}
block.data_.set(data, offset);
return true;
},

archive : function(objectId, archived) {
},

reserve : function(objectId, size) {
var block = this.blocks_.get(objectId);
if (typeof block == 'undefined' || block == null) {
block = new p2p$.com.webp2p.core.storage.MemoryBlock();
this.blocks_.set(objectId, block);
}
block.activeTime_ = block.writeTime_ = p2p$.com.common.Global.getMilliTime_();
var allocSize = (size > block.data_.length) ? (size - block.data_.length) : 0;
if (allocSize > 0) {
block.data_ = new Uint8Array(size);
this.dataSize_ += allocSize;
}
return true;
},

remove : function(objectId) {
var itrFind = this.blocks_.find(objectId);
if (!itrFind) {
return -1;
}
var block = this.blocks_.get(objectId);
this.dataSize_ -= block.data_.length;
this.blocks_.erase(objectId);
return true;
}
});
p2p$.ns("com.webp2p.core.storage");

p2p$.com.webp2p.core.storage.Pool = {

buckets_ : null,
memoryBucket_ : null,

initialize_ : function(manager) {
this.buckets_ = [];
this.memoryBucket_ = null;
this.memoryBucket_ = new p2p$.com.webp2p.core.storage.MemoryBucket(manager);
this.buckets_.push(this.memoryBucket_);

for ( var n = 0; n < this.buckets_.length; n++) {
var item = this.buckets_[n];
if (!item.open()) {
P2P_ULOG_INFO(P2P_ULOG_FMT("core::storage::Pool::Open bucket({0}) failed", item.getName_()));
return false;
}
}
P2P_ULOG_INFO(P2P_ULOG_FMT("core::storage::Pool::Initialize successfully"));
return true;
},

exit : function() {
P2P_ULOG_INFO(P2P_ULOG_FMT("core::storage::Pool::Exiting...."));
for ( var n = 0; n < this.buckets_.length; n++) {
var item = this.buckets_[n];
item.close();
}
P2P_ULOG_INFO(P2P_ULOG_FMT("core::storage::Pool::Exited"));
},

getDefaultBucket_ : function() {
return this.memoryBucket_;
},

getMemoryBucket_ : function() {
return this.memoryBucket_;
}
};
p2p$.ns("com.webp2p.core.supernode");

p2p$.com.webp2p.core.supernode.BitmapStatic = {
kMaxBitCount : 80 * 1000,
};

p2p$.com.webp2p.core.supernode.Bitmap = JClass.extend_({
data_ : null,

init : function() {
this.data_ = new p2p$.com.common.Map();
},

getValue : function(id) {
var index = id % p2p$.com.webp2p.core.supernode.BitmapStatic.kMaxBitCount;
var offset = Math.floor(index / 8);
var retValue = {
value : 0,
};
if (index < 0 || offset < 0 || !this.data_.find2(offset, retValue)) {
return false;
}
// this.data_.find2(offset,retValue);
var value = retValue.value;// this.data_.get(offset);
var old = (value & (1 << (index % 8))) ? true : false;
return old;
},

setValue : function(id, bit) {

var index = id % p2p$.com.webp2p.core.supernode.BitmapStatic.kMaxBitCount;
var offset = Math.floor(index / 8);
if (index < 0 || offset < 0) {
return false;
}
var value = this.data_.get(offset);
if (typeof value == 'undefined' || value == null) {
value = new Uint8Array(1);
this.data_.set(offset, value);
}
var old = (value & (1 << (index % 8))) ? true : false;
value |= (1 << (index % 8));
this.data_.set(offset, value);
return old;
},

reserve : function(size) {
},

clear : function(reserveBuffer) {
if (reserveBuffer) {
for ( var i = 0; i < this.data_.elements_.length; i++) {
this.data_.elements_[i].value = new Uint8Array(1);
}
} else {
this.data_.clear();
}
}
});
p2p$.ns("com.webp2p.core.supernode");

p2p$.com.webp2p.core.supernode.Context = JClass.extend_({
url_ : null,
gslbData_ : null,
configData_ : null,
strings_:null,

// properties
debug_ : false,
drmEnabled_ : false,
streamId_ : "",
moduleVersion_ : "",
deviceType_ : "",
sosType_ : "",
playType_ : "",
platformId_ : "",
subPlatformId_ : "",
videoType_ : "",
videoFormat_ : "",
appUuid_ : "",
uid_ :"",
cid_ :"",
vid_ :"",
pid_ :"",
custid_:"",
lc_ :"",
token_ : "",
pay_ : "",
termId_ : "",
t3partyAppChannel_ : "",
addtionalParam1_ : "",
addtionalParam2_ : "",
addtionalParam3_ : "",
addtionalParams_ : 0,
terminalType_ : 0,
statReportInterval_ : 0, // seconds
specialPlayerTimeOffset_ : 0, // seconds offset for special hardware players such as S50, S40
specialPlayerTimeLimit_ : 0, // seconds limit for speical hardware player such as S240F, S250F
liveStorageMemoryOnly_ : false,
vodStorageMemoryOnly_ : 0,

// geo
isp_ : 0,
country_ : 0,
province_ : 0,
city_ : 0,
area_ : 0,
countryCode_ : "",
geo_ : "",
geoName_ : "",
clientIp_ : "",
gslbServerIp_ : "",
metaServerIp_ : "",

// cdn/p2p params
p2pServerVersion_ : 0,// p2p server protocol version, 1:1.0, 2: 2.0
p2pFetchRate_ : null, // percent, 0~1
p2pMaxPeers_ : 0, // count
p2pUrgentSize_ : 0, // second(s)
p2pUrgentLevel1_ : 0, // urgent size if playLevel == 1
p2pSharePeers_ : false, // enable share p2p peers to others
p2pUploadEnabled_ : false, // enable p2p upload
p2pUploadLimit_ : false, // limit p2p upload speed
p2pUploadThrottleInit_ : 0, // initial upload bandwidth for p2p upload throttle (byte/s)
p2pUploadThrottleAverage_ : 0, // estimated average upload bandwidth for p2p upload throttle (byte/s)
p2pUploadMaxReserved_ : 0, // max reserved upload bandwidth (byte/s)
p2pUrgentUploadEnabled_ : false, // to upload if download enter urgent area
p2pPeerId_ : "",// primary p2p peer id
p2pRtmfpPeerId_ : "",// fro rtmfp
p2pWebsocketPeerId_ : "", // for websocket
p2pWebrtcPeerId_ : "", // for webrtc
p2pMaxQPeers_ : 0, //
p2pHeartbeatInterval_ : 0, // interval to gather,tracker (seconds)
p2pShareRangeInterval_ : 0, // send range interval (seconds)
p2pMaxParallelRequestPieces_ : 0, // max parallel request pieces for p2p peers
p2pMaxUrgentRequestPieces_ : 0, // max parallel request pieces for p2p peers when urgent not fullfill
cdnSlowThresholdRate_ : 0, // to decide whether cdn speed is too slow compare with media bitrate
cdnDisabled_ : false, // disable download data from cdn
cdnMultiRequest_ : false, // request from multi-cdn servers
cdnMultiMaxHost_ : 0, // request maximum cdn servers
cdnStartTime_ : 0, // for advertisment, second(s)
playingPosition_ : 0, // the position now player used
downloadSpeedRatio_ : 0, // download speed control rate, compare with bitrate

// protocols
protocolCdnDisabled_ : false,
protocolRtmfpDisabled_ : false,
protocolWebsocketDisabled_ : false,
protocolWebrtcDisabled_ : false,

// protocol status
selectorServerHost_ : "",
gatherServerHost_ : "",
rtmfpServerHost_ : "",
trackerServerHost_ : "",
webrtcServerHost_ : "",
stunServerHost_ : "",

selectorConnectedTime_ : 0, // units: us
rtmfpServerConnectedTime_ : 0, // units: us
gatherServerConnectedTime_ : 0, // units: us
trackerServerConnectedTime_ : 0, // units: us, cde tracker
webrtcServerConnectedTime_ : 0,

cdnTotalNodeCount_ : 0,
rtmfpTotalNodeCount_ : 0,
websocketTotalNodeCount_ : 0,
webrtcTotalNodeCount_ : 0,

upnpMapCompleteTime_ : 0,
upnpMapSuccess_ : false,
upnpMappedInPort_ : 0,
upnpMappedOutPort_ : 0,
upnpMappedAddress_ : "",

hasDefaultTrackerServer_ : false,
hasDefaultWebrtcServer_ : false,
hasDefaultStunServer_ : false,
init : function() {
this.url_ = new p2p$.com.common.Url();
this.strings_ = p2p$.com.common.String;
this.debug_ = false;
this.drmEnabled_ = false;
this.terminalType_ = 1;
this.statReportInterval_ = 60;
this.specialPlayerTimeOffset_ = 0; // default disabled
this.specialPlayerTimeLimit_ = 0; // default disabled
this.liveStorageMemoryOnly_ = false;
this.vodStorageMemoryOnly_ = false;
this.videoFormat_ = "lm3u8";

// geo
this.isp_ = 0;
this.country_ = 0;
this.province_ = 0;
this.city_ = 0;
this.area_ = 0;

// cdn/p2p params
this.p2pServerVersion_ = 1; // 1.0
this.p2pFetchRate_ = 0.1;
this.p2pMaxPeers_ = 10;
this.p2pUrgentSize_ = 10;
this.p2pUrgentLevel1_ = 10;
this.p2pSharePeers_ = true;
this.p2pUploadEnabled_ = true;
this.p2pUrgentUploadEnabled_ = false;
this.p2pUploadLimit_ = false;
this.p2pUploadThrottleInit_ = 50000; // 50kB/s
this.p2pUploadThrottleAverage_ = 120000; // 100kB/s
this.p2pUploadMaxReserved_ = 30000; // 30kB/s
this.p2pMaxQPeers_ = 5;
this.p2pHeartbeatInterval_ = 30; // second(s)
this.p2pShareRangeInterval_ = 5; // second(s)
this.p2pMaxParallelRequestPieces_ = 20;
this.p2pMaxUrgentRequestPieces_ = 1;
this.cdnSlowThresholdRate_ = 1.0;
this.cdnDisabled_ = false;
this.cdnMultiRequest_ = true; // false;
this.cdnMultiMaxHost_ = 3;
this.cdnStartTime_ = 0;
this.playingPosition_ = 0;
this.downloadSpeedRatio_ = -1.0;

// protocol params
this.protocolCdnDisabled_ = false;
this.protocolRtmfpDisabled_ = false;
this.protocolWebsocketDisabled_ = false;
this.protocolWebrtcDisabled_ = false;

// status
// selectorServerPort_ = 0;
// gatherServerPort_ = 0;
// rtmfpServerPort_ = 0;
// trackerServerPort_ = 0;
this.selectorConnectedTime_ = 0;
this.rtmfpServerConnectedTime_ = 0;
this.gatherServerConnectedTime_ = 0;
this.trackerServerConnectedTime_ = 0;
this.webrtcServerConnectedTime_ = 0;

this.cdnTotalNodeCount_ = 0;
this.rtmfpTotalNodeCount_ = 0;
this.websocketTotalNodeCount_ = 0;
this.webrtcTotalNodeCount_ = 0;

this.upnpMapCompleteTime_ = 0;
this.upnpMapSuccess_ = false;
this.upnpMappedInPort_ = 0;
this.upnpMappedOutPort_ = 0;

this.hasDefaultTrackerServer_ = false;
this.hasDefaultWebrtcServer_ = false;
this.hasDefaultStunServer_ = false;
},
initialize_ : function(url, env) {
// properties
this.url_ = url;
this.moduleVersion_ = this.strings_.format("H5-{0}.{1}.{2}", p2p$.com.selector.Module.kH5MajorVersion,
p2p$.com.selector.Module.kH5MinorVersion, p2p$.com.selector.Module.kH5BuildNumber);
this.deviceType_ = this.strings_.toUpper_(this.url_.params_.get("hwtype"));
this.osType_ = this.url_.params_.get("ostype");
this.terminalType_ = this.strings_.parseNumber_(this.url_.params_.get("termid"), 1);
this.platformId_ = this.url_.params_.get("platid");
this.subPlatformId_ = this.url_.params_.get("splatid");
this.videoType_ = this.url_.params_.get("vtype");
this.streamId_ = this.url_.params_.has("stream_id") ? this.url_.params_.get("stream_id") : "";
this.appUuid_ = this.url_.params_.has("uuid") ? this.url_.params_.get("uuid") : "";
this.t3partyAppChannel_ = this.url_.params_.has("ch") ? this.url_.params_.get("ch") : "";
this.token_ = this.url_.params_.has("token") ? this.url_.params_.get("token") : "";
this.pay_ = this.url_.params_.has("payff") ? this.url_.params_.get("payff") : "";
this.termId_ = this.url_.params_.has("termid") ? this.url_.params_.get("termid") : "";
this.cid_ = this.url_.params_.has("cid") ? this.url_.params_.get("cid") : "";
this.vid_ = this.url_.params_.has("vid") ? this.url_.params_.get("vid") : "";
this.pid_ = this.url_.params_.has("pid") ? this.url_.params_.get("pid") : "";
this.uid_ = this.url_.params_.has("uid") ? this.url_.params_.get("uid") : "";
this.custid_ = this.url_.params_.has("custid") ? this.url_.params_.get("custid") : "";
this.lc_ = this.url_.params_.has("lc") ? this.url_.params_.get("lc") : "";

this.liveStorageMemoryOnly_ = env.liveStorageMemoryOnly_;
this.vodStorageMemoryOnly_ = env.vodStorageMemoryOnly_;

if (this.deviceType_ == "" || !env.deviceType_ == "") {
this.deviceType_ = env.deviceType_;
}
if (this.osType_ == "" || !env.osType_ == "") {
this.osType_ = env.osType_;
}
if (env.specialPlayerTimeOffset_ != 0) {
this.specialPlayerTimeOffset_ = env.specialPlayerTimeOffset_;
}
if (env.specialPlayerTimeLimit_ != 0) {
this.specialPlayerTimeLimit_ = env.specialPlayerTimeLimit_;
}
if (env.downloadSpeedRatio_ > 0) {
this.downloadSpeedRatio_ = env.downloadSpeedRatio_;
}

if (env.paramWebrtcServer_) {
this.hasDefaultWebrtcServer_ = true;
this.webrtcServerHost_ = "ws://" + env.paramWebrtcServer_;
}
if (env.paramTrackerServer_) {
this.hasDefaultTrackerServer_ = true;
this.gatherServerHost_ = env.paramTrackerServer_;
}
if (env.paramStunServer_) {
this.hasDefaultStunServer_ = true;
this.stunServerHost_ = "stun:" + env.paramStunServer_;
}
if (env.paramCloseWebrtc_) {
this.protocolWebrtcDisabled_ = env.paramCloseWebrtc_;
}
if (env.paramCloseWebsocket_) {
this.protocolWebsocketDisabled_ = env.paramCloseWebsocket_;
}

// addtional params
this.addtionalParams_ == "";
this.addtionalParam1_ = this.url_.params_.has("p1") ? this.url_.params_.get("p1") : "";
this.addtionalParam2_ = this.url_.params_.has("p2") ? this.url_.params_.get("p2") : "";
this.addtionalParam3_ = this.url_.params_.has("p3") ? this.url_.params_.get("p3") : "";
if (this.addtionalParam1_ != "" || this.addtionalParam2_ != "" || this.addtionalParam3_ != "") {
this.addtionalParams_ = this.strings_.format("p1={0}&p2={1}&p3={2}", this.addtionalParam1_, this.addtionalParam2_,
this.addtionalParam3_);
}
},

loadParams_ : function(params, customParams) {
if (customParams.hasOwnProperty("cdnMultiRequest")) {
this.cdnMultiRequest_ = customParams["cdnMultiRequest"];
}

if (params.hasOwnProperty("debug")) {
this.debug_ = params["debug"];
}
if (params.hasOwnProperty("mcdn")) {
this.cdnMultiRequest_ = params["mcdn"];
}
if (params.hasOwnProperty("ccdn")) {
this.cdnMultiMaxHost_ = params["ccdn"];
}
if (params.hasOwnProperty("dsratio")) {
this.downloadSpeedRatio_ = params["dsratio"];
}
},

loadData_ : function(data) {
this.gslbData_ = data;
this.geo_ = data["geo"];
this.geoName_ = data["desc"];
this.clientIp_ = data["remote"];
var geoValues = this.geo_.split(".");
if (geoValues.length > 0) {
this.countryCode_ = this.strings_.trim(geoValues[0]);
this.country_ = 0;
for ( var n = 0; n < this.countryCode_.length && n < 2; n++) {
this.country_ = this.country_ * 256 + (this.countryCode_[n]).charCodeAt();
}
}
if (geoValues.length > 1) {
this.province_ = this.strings_.parseNumber_(geoValues[1]);
}
if (geoValues.length > 2) {
this.city_ = this.strings_.parseNumber_(geoValues[2]);
}
if (geoValues.length > 3) {
this.isp_ = this.strings_.parseNumber_(geoValues[3]);
}
},

detectSpecialPlayerTimeOffset_ : function() {
},

resetPeerState_ : function() {
},
getAllStatus_ : function(result) {
result["drmEnabled"] = this.drmEnabled_;
result["geo"] = this.geo_;
result["geoName"] = this.geoName_;
result["clientIp"] = this.clientIp_;
result["gslbServerIp"] = this.gslbServerIp_;
result["metaServerIp"] = this.metaServerIp_;
result["deviceType"] = this.deviceType_;
result["osType"] = this.osType_;
result["statReportInterval"] = this.statReportInterval_;
result["specialPlayerTimeOffset"] = this.specialPlayerTimeOffset_;
result["specialPlayerTimeLimit"] = this.specialPlayerTimeLimit_;
result["liveStorageMemoryOnly"] = this.liveStorageMemoryOnly_;
result["vodStorageMemoryOnly"] = this.vodStorageMemoryOnly_;
result["downloadSpeedRatio"] = this.downloadSpeedRatio_;

result["p2pPeerId"] = this.p2pPeerId_;
result["p2pRtmfpPeerId"] = this.p2pRtmfpPeerId_;
result["p2pWebsocketPeerId"] = this.p2pWebsocketPeerId_;
result["p2pWebrtcPeerId"] = this.p2pWebrtcPeerId_;
result["p2pFetchRate"] = this.p2pFetchRate_;
result["p2pMaxPeers"] = this.p2pMaxPeers_;
result["p2pUrgentSize"] = this.p2pUrgentSize_;
result["p2pUploadEnabled"] = this.p2pUploadEnabled_;
result["p2pUploadLimit"] = this.p2pUploadLimit_;
result["p2pUploadThrottleInit"] = this.p2pUploadThrottleInit_;
result["p2pUploadThrottleAverage"] = this.p2pUploadThrottleAverage_;
result["p2pUploadMaxReserved"] = this.p2pUploadMaxReserved_;
result["p2pUrgentUploadEnabled"] = this.p2pUrgentUploadEnabled_;
result["p2pShareRangeInterval"] = this.p2pShareRangeInterval_;
result["p2pMaxParallelRequestPieces"] = this.p2pMaxParallelRequestPieces_;
result["p2pMaxUrgentRequestPieces"] = this.p2pMaxUrgentRequestPieces_;

result["cdnSlowThresholdRate"] = this.cdnSlowThresholdRate_;
result["cdnDisabled"] = this.cdnDisabled_;
result["cdnMultiRequest"] = this.cdnMultiRequest_;
result["cdnMultiMaxHost"] = this.cdnMultiMaxHost_;
result["cdnStartTime"] = this.cdnStartTime_;
result["playingPosition"] = this.playingPosition_;

result["selectorServerHost"] = this.selectorServerHost_;
result["gatherServerHost"] = this.gatherServerHost_;
result["rtmfpServerHost"] = this.rtmfpServerHost_;
result["trackerServerHost"] = this.trackerServerHost_;

var url = new p2p$.com.common.Url();
url.fromString_(this.webrtcServerHost_);
result["webrtcServerHost"] = url.host_ + ":" + url.port_;

result["protocolCdnDisabled"] = this.protocolCdnDisabled_;
result["protocolRtmfpDisabled"] = this.protocolRtmfpDisabled_;
result["protocolWebsocketDisabled"] = this.protocolWebsocketDisabled_;
result["protocolWebrtcDisabled"] = this.protocolWebrtcDisabled_;

result["selectorConnectedTime"] = this.selectorConnectedTime_;
result["rtmfpServerConnectedTime"] = this.rtmfpServerConnectedTime_;
result["webrtcServerConnectedTime"] = this.webrtcServerConnectedTime_;
result["gatherServerConnectedTime"] = this.gatherServerConnectedTime_;
result["trackerServerConnectedTime"] = this.trackerServerConnectedTime_;

result["cdnTotalNodeCount"] = this.cdnTotalNodeCount_;
result["rtmfpTotalNodeCount"] = this.rtmfpTotalNodeCount_;
result["webrtcTotalNodeCount"] = this.webrtcTotalNodeCount_;
result["websocketTotalNodeCount"] = this.websocketTotalNodeCount_;

result["upnpMapCompleteTime"] = this.upnpMapCompleteTime_;
result["upnpMapSuccess"] = this.upnpMapSuccess_;
result["upnpMappedInPort"] = this.upnpMappedInPort_;
result["upnpMappedOutPort"] = this.upnpMappedOutPort_;
result["upnpMappedAddress"] = this.upnpMappedAddress_;
}
});
p2p$.ns("com.webp2p.core.supernode");

p2p$.com.webp2p.core.supernode.DATA_VERIFY_METHOD = {
kDataVerifyMethodDefault : 0,
kDataVerifyMethodCrc32 : 1
};

p2p$.com.webp2p.core.supernode.MetaData = JClass.extend_({
type_ : 0,
hlsMode_ : false,
directMetaMode_ : false,
rangeParamsSupported_ : false,
version_ : "",
allowCache_ : "",
targetDuration_ : 0,
programId_ : "",
programeType_ : "",
programVersion_ : "",
programDateTime_ : "",
p2pGroupId_ : "",
localMetaContent_ : "",
mediaSequence_ : 0,
lastReceiveSpeed_ : 0,
pictureWidth_ : 0,
pictureHeight_ : 0,
// totalTnLength_;
// totalPnLength_;
// totalSegmentCount_;
directCount_ : 0,
moreUrlCount_ : 0,
p2pPieceCount_ : 0,
verifyMethod_ : 0,
totalDuration_ : 0,
directDuration_ : 0,
createTime_ : 0,
updateTime_ : 0,
urgentSegmentId_ : 0,
dataSize_ : 0,
totalGapDuration_ : 0,

taskId_ : "",
storageId_ : "",
channelUrl_ : "",
sourceUrl_ : "",
finalUrl_ : "",
sourceServer_ : "",
morePrimaryUrls_ : null,
segments_ : null,

tn2SegmentIndexMap_ : null,
pn2SegmentIndexMap_ : null,

strings_:null,
global_:null,

init : function() {
this.segments_ = [];
this.tn2SegmentIndexMap_ = new p2p$.com.common.Map();
this.pn2SegmentIndexMap_ = new p2p$.com.common.Map();
this.strings_ = p2p$.com.common.String;
this.global_ = p2p$.com.common.Global;
this.type_ = p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeVod;
this.hlsMode_ = true;
this.directMetaMode_ = false;
this.rangeParamsSupported_ = true; // default support for rstart, rend params
this.verifyMethod_ = p2p$.com.webp2p.core.supernode.DATA_VERIFY_METHOD.kDataVerifyMethodDefault;
this.tidy();
},
// readBigUnsignedInteger( const char *data );

tidy : function() {
this.targetDuration_ = 0;
this.pictureWidth_ = 0;
this.pictureHeight_ = 0;
// totalTnLength_ = 0;
// totalPnLength_ = 0;
// totalSegmentCount_ = 0;
this.directCount_ = 0;
this.moreUrlCount_ = 0;
this.p2pPieceCount_ = 0;
this.totalDuration_ = 0;
this.directDuration_ = 0;
this.mediaSequence_ = 0;
this.lastReceiveSpeed_ = 0;
this.updateTime_ = 0;
this.createTime_ = this.global_.getMilliTime_();
this.urgentSegmentId_ = -1;
this.dataSize_ = 0;
this.totalGapDuration_ = 0;

this.version_ = "";
this.programId_ = "";
this.programVersion_ = "";
this.p2pGroupId_ = "";
this.segments_ = [];
this.localMetaContent_ = "";
this.tn2SegmentIndexMap_.clear();
this.pn2SegmentIndexMap_.clear();
},
fork : function() {
var result = new p2p$.com.webp2p.core.supernode.MetaData();
for ( var n in this) {
result[n] = this[n];
}
return result;
},
load : function(values, elapsedTime, needBuildIndexes) {
this.tidy();
this.hlsMode_ = true;
this.moreUrlCount_ = 0;

var lines = values.split("\n");
var maxPieceId = 0;
var nonDirectCount = 0;
var lastSegment = new p2p$.com.webp2p.core.supernode.MetaSegment();
lastSegment.m3u8LoadTime_ = elapsedTime;
var needMoreUrls = (this.directMetaMode_ || p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeLive == this.type_);
if (needMoreUrls) {
lastSegment.moreMediaUrls_ = [];
}
this.updateTime_ = this.global_.getMilliTime_();
for ( var n = 0; n < lines.length; n++) {
// if (n == 100) break;
var line = lines[n];
line = this.strings_.trim(line);
if ("" == line) {
continue;
}
if (line[0] != '#') {
if (lastSegment.id_ < 0 || (this.directMetaMode_ && this.type_ != p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeLive)) {
lastSegment.id_ = this.segments_.length;
}

if (this.directMetaMode_ && lastSegment.directMode_) {
lastSegment.p2pDisabled_ = true;
}
lastSegment.pictureHeight_ = this.pictureHeight_;
lastSegment.pictureWidth_ = this.pictureWidth_;
lastSegment.url_ = line;
lastSegment.mediaUrl_ = this.strings_.getAbsoluteUrlIfNeed_(lastSegment.url_, this.finalUrl_);
lastSegment.playUrl_ = lastSegment.formatPlayUrl_(this.storageId_);

if (lastSegment.pieces_.length == 0) {
// no pieces
var pieceItem = new p2p$.com.webp2p.core.supernode.MetaPiece();
pieceItem.type_ = p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypePn;
pieceItem.id_ = (lastSegment.id_ > 0) ? lastSegment.id_ : this.segments_.length;
lastSegment.piecePnCount_++;
pieceItem.size_ = 0;
pieceItem.checksum_ = 0;
pieceItem.offset_ = lastSegment.size_;
pieceItem.index_ = lastSegment.pieces_.length;
lastSegment.p2pDisabled_ = true;
lastSegment.size_ += pieceItem.size_;
lastSegment.pieces_.push(pieceItem);
}

if (lastSegment.startTime_ <= 0) {
lastSegment.startTime_ = this.totalDuration_;
}
if (this.type_ == p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeVod
|| this.type_ == p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeDownload) {
lastSegment.startTimeActual_ = this.totalDuration_;
} else {
lastSegment.startTimeActual_ = lastSegment.startTime_;
}
if (needMoreUrls) {
if (lastSegment.moreMediaUrls_ && lastSegment.moreMediaUrls_[0]) {
this.moreUrlCount_ = 1;
}
if (lastSegment.moreMediaUrls_ && lastSegment.moreMediaUrls_[1]) {
this.moreUrlCount_ = 2;
}
}

this.segments_.push(lastSegment);
this.p2pPieceCount_ += (lastSegment.pieceTnCount_ + lastSegment.piecePnCount_);
this.totalDuration_ += lastSegment.duration_;
this.dataSize_ += lastSegment.size_;
if (lastSegment.directMode_ && nonDirectCount <= 0) {
this.directCount_++;
this.directDuration_ += lastSegment.duration_;
} else {
nonDirectCount++;
}

lastSegment = new p2p$.com.webp2p.core.supernode.MetaSegment();
lastSegment.m3u8LoadTime_ = elapsedTime;
if (this.directMetaMode_ || needMoreUrls) {
lastSegment.moreMediaUrls_ = [];
}
continue;
}
var pos = 0, linKey = "", linValue = "";
if ((pos = line.indexOf(":")) == -1) {
linKey = line;
} else {
linKey = (pos > 0) ? line.substr(0, pos) : "";
linValue = ((pos + 1) < line.length) ? line.substr(pos + 1) : "";
}
linKey = this.strings_.trim(linKey);
linValue = this.strings_.trim(linValue);

if (this.strings_.compareTo_(linKey, "#EXT-X-VERSION", true) == 0) {
this.version_ = linValue;
} else if (this.strings_.compareTo_(linKey, "#EXT-X-ALLOW-CACHE", true) == 0) {
this.allowCache_ = linValue;
} else if (this.strings_.compareTo_(linKey, "#EXT-X-TARGETDURATION", true) == 0) {
this.targetDuration_ = this.strings_.parseNumber_(linValue, 0);
} else if (this.strings_.compareTo_(linKey, "#EXT-X-MEDIA-SEQUENCE", true) == 0) {
this.mediaSequence_ = this.strings_.parseNumber_(linValue, 0);
} else if (this.strings_.compareTo_(linKey, "#EXT-X-PROGRAM-DATE-TIME", true) == 0) {
this.programDateTime_ = linValue;
} else if (this.strings_.compareTo_(linKey, "#EXT-LETV-M3U8-TYPE", true) == 0) {
this.programeType_ = linValue;
} else if (this.strings_.compareTo_(linKey, "#EXT-LETV-M3U8-VER", true) == 0) {
this.programVersion_ = linValue;
} else if (this.strings_.compareTo_(linKey, "#EXT-LETV-PROGRAM-ID", true) == 0) {
this.programId_ = linValue;
lastSegment.programId_ = linValue;
lastSegment.beginOfMeta_ = true;
} else if (this.strings_.compareTo_(linKey, "#EXT-LETV-PIC-WIDTH", true) == 0) {
this.pictureWidth_ = this.strings_.parseFloat(linValue, 0);
} else if (this.strings_.compareTo_(linKey, "#EXT-LETV-PIC-HEIGHT", true) == 0) {
this.pictureHeight_ = this.strings_.parseFloat(linValue, 0);
} else if (this.strings_.compareTo_(linKey, "#EXT-LETV-DIRECT", true) == 0) {
lastSegment.directMode_ = this.strings_.parseNumber_(linValue, 0) ? true : false;
} else if (this.strings_.compareTo_(linKey, "#EXT-LETV-PATH1", true) == 0 && lastSegment.moreMediaUrls_ != null) {
lastSegment.moreMediaUrls_[0] = linValue;
} else if (this.strings_.compareTo_(linKey, "#EXT-LETV-PATH2", true) == 0 && lastSegment.moreMediaUrls_ != null) {
lastSegment.moreMediaUrls_[1] = linValue;
} else if (this.strings_.compareTo_(linKey, "#EXT-LETV-AD-MONITOR-URL", true) == 0) {
lastSegment.advertMonitorUrl_ = linValue;
}

if (this.strings_.compareTo_(linKey, "#EXT-LETV-START-TIME", true) == 0) {
lastSegment.startTime_ = this.strings_.parseFloat(linValue, 0) * 1000;
} else if (this.strings_.compareTo_(linKey, "#EXT-LETV-SEGMENT-ID", true) == 0) {
lastSegment.id_ = this.strings_.parseNumber_(linValue, 0);
} else if (this.strings_.compareTo_(linKey, "#EXT-LETV-CKS", true) == 0) {

// speed up method
var pieceItem = new p2p$.com.webp2p.core.supernode.MetaPiece();
linValue = this.strings_.makeUpper_(linValue);
var position = linValue.indexOf("TN=");
var pieceTag = linValue.substr(position);
if (-1 != position) {
pieceItem.type_ = p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn;
pieceItem.id_ = this.strings_.parseNumber_(pieceTag.substring(3, pieceTag.indexOf("&")));

position = linValue.indexOf("KEY=");
pieceTag = linValue.substr(position);
if (-1 != position) {
pieceItem.key_ = this.strings_.parseNumber_(pieceTag.substring(4, pieceTag.indexOf("&")));
}

lastSegment.pieceTnCount_++;
} else {
pieceItem.type_ = p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypePn;
position = linValue.indexOf("PN=");
pieceTag = linValue.substr(position);
if (-1 != position) {
pieceItem.id_ = this.strings_.parseNumber_(pieceTag.substring(3, pieceTag.indexOf("&")));
}
lastSegment.piecePnCount_++;
}
position = linValue.indexOf("SZ=");
pieceTag = linValue.substr(position);
if (-1 != position) {
pieceItem.size_ = this.strings_.parseNumber_(pieceTag.substring(3, pieceTag.indexOf("&")));
}

position = linValue.indexOf("CKS=");
pieceTag = linValue.substr(position);
if (-1 != position) {
pieceItem.checksum_ = this.strings_.parseNumber_(pieceTag.substring(4));
}

// P2P_ULOG_INFO("pieceItem.checksum_:"+pieceItem.checksum_ +",pieceItem.size_:"+pieceItem.size_+",sum:"+(pieceItem.checksum_+pieceItem.size_));
pieceItem.offset_ = lastSegment.size_;
pieceItem.index_ = lastSegment.pieces_.length;
lastSegment.size_ += pieceItem.size_;
lastSegment.pieces_.push(pieceItem);
this.maxPieceId = Math.max(maxPieceId, pieceItem.id_);
} else if (this.strings_.compareTo_(linKey, "#EXT-X-DISCONTINUITY", true) == 0) {
lastSegment.discontinuity_ = true;
P2P_ULOG_TRACE("core::supernode::MetaData Segment is #EXT-X-DISCONTINUITY id(" + lastSegment.id_ + "), start time(" + lastSegment.startTime_
+ ")");
} else if (this.strings_.compareTo_(linKey, "#EXTINF", true) == 0) {
lastSegment.duration_ = (this.strings_.parseFloat(linValue, 0) * 1000);
// P2P_ULOG_INFO("parseResult:"+this.strings_.parseFloat(linValue, 0)+",lastSegment.duration_:"+lastSegment.duration_
// +",linval="+linValue);
}

}
if (needBuildIndexes) {
this.buildIndexes_();
}

// default
if (!(this.programId_ == "")) {//生成gid
this.p2pGroupId_ = this.programId_ + this.programVersion_ + p2p$.com.selector.Module.kP2pVersion;
}
return true;
},

loadHeaders_ : function(url, cheaders, checksumData) {
},

buildIndexes_ : function() {
this.tn2SegmentIndexMap_.clear();
this.pn2SegmentIndexMap_.clear();
this.segments_.sort(function(item1, item2) {
return item1.id_ - item2.id_;
});

this.p2pPieceCount_ = 0;
this.totalDuration_ = 0;
for ( var n = 0; n < this.segments_.length; n++) {
var segment = this.segments_[n];
segment.index_ = n;
this.totalDuration_ += segment.duration_;
if (segment.p2pDisabled_) {
continue;
}

this.p2pPieceCount_ += segment.pieces_.length;
for ( var k = 0; k < segment.pieces_.length; k++) {
var piece = segment.pieces_[k];
var indexMap = (p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn == piece.type_) ? this.tn2SegmentIndexMap_
: this.pn2SegmentIndexMap_;
// indexMap[piece.id_] = segment.index_;
indexMap.set(piece.id_, segment.index_, false);
}
}
},

updateMetaCache_ : function(endTime, endList, localMode) {
},

combineWith_ : function(other, reloaded, groupChanged) {
var modifyCount = 0;
var newSegmentCount = 0;
var maxSegmentId = 0;
var newSegments = [];
if (groupChanged) {
this.version_ = other.version_;
this.mediaSequence_ = other.mediaSequence_;
this.pictureWidth_ = other.pictureWidth_;
this.pictureHeight_ = other.pictureHeight_;
}

for ( var k = 0; k < this.segments_.length; k++) {
var item = this.segments_[k];
maxSegmentId = maxSegmentId > item.id_ ? maxSegmentId : item.id_;
}

for ( var n = 0; n < other.segments_.length; n++) {
var segment = other.segments_[n];
var exists = false;
var existsIndex = 0;
for ( var k = 0; k < this.segments_.length; k++) {
var item = this.segments_[k];
if (item.startTime_ > 0) {
if (item.id_ == segment.id_) {
existsIndex = k;
exists = true;
break;
}
} else if (item.url_ == segment.url_) {
existsIndex = k;
exists = true;
break;
}
}

if (exists) {
if (reloaded) {
var existsSegment = this.segments_[existsIndex];
var backupSegment = existsSegment;
existsSegment = segment;
existsSegment.url_ = backupSegment.url_;
existsSegment.mediaUrl_ = backupSegment.mediaUrl_;
existsSegment.playUrl_ = backupSegment.playUrl_;
existsSegment.advertMonitorUrl_ = backupSegment.advertMonitorUrl_;
existsSegment.advertMonitorReported_ = backupSegment.advertMonitorReported_;
existsSegment.pictureWidth_ = backupSegment.pictureWidth_;
existsSegment.pictureHeight_ = backupSegment.pictureHeight_;
modifyCount++;
}
continue;
}
newSegments.push(segment.id_);
this.segments_.push(segment);
var newSegment = this.segments_[this.segments_.length - 1];
if (this.p2pGroupId_ == "") {
// standrad meta
newSegment.id_ = (segment.startTime_ > 0) ? (newSegment.startTime_ / 1000) : (++maxSegmentId);
if (segment.pieces_.length == 1) {
newSegment.pieces_[0].id_ = segment.id_;
}
}
this.p2pPieceCount_ += segment.pieces_.length;
newSegmentCount++;
modifyCount++;
}

if (modifyCount > 0) {
this.buildIndexes_();
}

return {
newSegmentCount_ : newSegmentCount,
newSegments_ : newSegments
};
},

combineSameGroup_ : function(other) {
if (other.segments_.length == 0) {
return 0;
}

var newSegmentCount = 0;
var maxSegmentId = 0;
var newSegments = [];
var endIndex = other.segments_.length - 1;
for (; endIndex >= 0; endIndex--) {
var item = other.segments_[endIndex];
if (item.beginOfMeta_) {
break;
}
}

if (endIndex <= 0) {
return 0;
}

for ( var n = 0; n < endIndex; n++) {
var segment = other.segments_[n];
var exists = false;
for ( var k = 0; k < this.segments_.length; k++) {
var item = this.segments_[k];
if (item.startTime_ > 0) {
if (item.id_ == segment.id_) {
exists = true;
break;
}
} else if (item.url_ == segment.url_) {
exists = true;
break;
}
}

if (exists) {
continue;
}
newSegments.push(segment.id_);
this.segments_.push(segment);
var newSegment = this.segments_[this.segments_.length - 1];
if (!this.p2pGroupId_) {
// standrad meta
newSegment.id_ = (segment.startTime_ > 0) ? (newSegment.startTime_ / 1000) : (++maxSegmentId);
if (segment.pieces_.length == 1) {
newSegment.pieces_[0].id_ = segment.id_;
}
}
this.p2pPieceCount_ += segment.pieces_.length;
newSegmentCount++;
}

if (newSegmentCount > 0) {
this.buildIndexes_();
}
return {
newSegmentCount_ : newSegmentCount,
newSegments_ : newSegments
};
},

duplicateExistsFrom_ : function(other) {
},

markAllSegmentP2pDisabled_ : function() {
for ( var n = 0; n < this.segments_.length; n++) {
var item = this.segments_[n];
item.p2pDisabled_ = true;
}
},

updateSegmentTimeGap_ : function() {
},

resetReceiveTags_ : function() {
},

parseChecksum_ : function(pieceSize, checksums, checksumData) {
},

verifyPiece_ : function(piece, data, size) {
switch (this.verifyMethod_) {
case p2p$.com.webp2p.core.supernode.DATA_VERIFY_METHOD.kDataVerifyMethodCrc32:
return piece.verifyWithCrc32_(data, size);
default:
return piece.verify(data, size);
}
},

getLocalMetaContent_ : function() {
return this.localMetaContent_;
},

getSegmentStorageId_ : function(segmentId) {
return this.strings_.format("channel://{0}//{1}", this.storageId_, segmentId);
},

getSegmentIndexById_ : function(id) {
for ( var n = 0; n < this.segments_.length; n++) {
var item = this.segments_[n];
if (item.id_ == id) {
return n;
}
}
return -1;
},

getSegmentIndexByPieceId_ : function(type, id) {
var indexMap = (p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn == type) ? this.tn2SegmentIndexMap_ : this.pn2SegmentIndexMap_;
var value = indexMap.get(id);
return (value != null ? value : -1);
},

getSegmentById_ : function(id) {
var segment = null;
for ( var n = 0; n < this.segments_.length; n++) {
var item = this.segments_[n];
if (item.id_ == id) {
segment = item;
break;
}
}
return segment;
},

getDataSize_After_ : function(msId) {
},
getAllStatus_ : function(startSegmentId, maxDuration, params, result) {
var incompleleOnly = params.get("incompleteOnly");
result["updateTime"] = this.updateTime_;
result["segmentCount"] = this.segments_.length;
result["directCount"] = this.directCount_;
result["pieceCount"] = this.tn2SegmentIndexMap_.length + this.pn2SegmentIndexMap_.length;
result["tnPieceCount"] = this.tn2SegmentIndexMap_.length;
result["pnPieceCount"] = this.pn2SegmentIndexMap_.length;
result["p2pGroupId"] = this.p2pGroupId_;
result["directDuration"] = this.directDuration_;
result["targetDuration"] = this.targetDuration_;
result["totalGapDuration"] = this.totalGapDuration_;
result["segmentFirstId"] = (this.segments_.length > 0) ? this.segments_[0].id_ : 0;
result["segmentLastId"] = (this.segments_.length > 0) ? this.segments_[this.segments_.length - 1].id_ : 0;
result["rangeParamsSupported"] = this.rangeParamsSupported_;
result["verifyMethod"] = this.verifyMethod_;
var segmentDisplayCount = 0;
var segmentDisplayDuration = 0;
var segmentCompletedCount = 0;
var segmentCompletingCount = 0;
var resultSegments = result["segments"] = [];
for ( var n = 0, j = 0; n < this.segments_.length; n++) {
var segment = this.segments_[n];
if (incompleleOnly && segment.completedTime_ > 0) {
continue;
}
if (startSegmentId >= 0 && segment.id_ < startSegmentId) {
continue;
}
if (maxDuration > 0 && segmentDisplayDuration >= maxDuration * 1000) {
break;
}
var resultSegmentsStatus = resultSegments[j++] = {};
segment.getAllStatus_(resultSegmentsStatus);

segmentDisplayCount++;
segmentDisplayDuration += segment.duration_;
if (segment.completedTime_ > 0) {
segmentCompletedCount++;
} else if (segment.completedPieceCount_ > 0) {
segmentCompletingCount++;
}
}
result["segmentDisplayCount"] = segmentDisplayCount;
result["segmentDisplayDuration"] = segmentDisplayDuration;
result["segmentCompletedCount"] = segmentCompletedCount;
result["segmentCompletingCount"] = segmentCompletingCount;
}
});
p2p$.ns("com.webp2p.core.supernode");

p2p$.com.webp2p.core.supernode.MetaPiece = JClass.extend_({
id_ : 0,
type_ : 0,
key_ : 0,
offset_ : 0,
size_ : 0,
wild_ : false,
checksum_ : 0,
index_ : 0,

// status
randomNumber_ : 0,
transferDepth_ : 0,
receiveProtocol_ : 0,
shareInRanges_ : 0,
receiveByStable_ : false,
receiveByOther_ : false,
receiveSessionId_ : 0,
receiveStartTime_ : 0,
playedTime_ : 0,
completedTime_ : 0,
recvTimes_ : 0,
writeTimes_ : 0,

init : function() {
this.id_ = 0;
this.type_ = p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn;
this.key_ = 0;
this.offset_ = 0;
this.size_ = 0;
this.wild_ = false;
this.checksum_ = 0;
this.index_ = 0;
this.randomNumber_ = Math.floor(Math.random() * 100 + 1);
this.transferDepth_ = 0;
this.receiveProtocol_ = 0;
this.shareInRanges_ = 0;
this.receiveByStable_ = false;
this.receiveByOther_ = false;
this.receiveSessionId_ = 0;
this.receiveStartTime_ = 0;
this.playedTime_ = 0;
this.completedTime_ = 0;
this.recvTimes_ = 0;
},

fork : function() {
var result = new p2p$.com.webp2p.core.supernode.MetaPiece();
for ( var n in this) {
result[n] = this[n];
}
return result;
},

verify : function(data, size) {
if (this.size_ <= 0 || this.wild_) {
return true;
}

var step = 47;
var pos = 0;
var sum = 0xffffffff;
if (size >= 188) {
pos += 4;
while (pos + step < size) {
// uint32 item1 = core::common::network2Host32(*(uint32 *)(data + pos));
// uint32 item2 = (uint32(data[pos]) << 24) + (uint32(data[pos + 1]) << 16) + (uint32(data[pos + 2]) << 8) + (uint32(data[pos + 3]));
// p2p$.com.webp2p.core.common.Number.convertToValue_('8',value,_position);'4',value,_position
var item1 = p2p$.com.webp2p.core.common.Number.convertToValue_('4', data, pos);
sum ^= item1;
pos += step;
}
}
sum = (~(((sum >> 16) & 0xffff) + (sum & 0xffff))) & 0xffff;
return this.checksum_ == sum;
},

verifyWithCrc32_ : function(data, size) {
},

getTypeName_ : function() {
},
getAllStatus_ : function(result) {
result["id"] = this.id_;
result["index"] = this.index_;
result["type"] = this.type_;
result["offset"] = this.offset_;
result["size"] = this.size_;
result["wild"] = this.wild_;
result["checksum"] = this.checksum_;
result["transferDepth"] = this.transferDepth_;
result["shareInRanges"] = this.shareInRanges_;
result["receiveProtocol"] = this.receiveProtocol_;
result["receiveByStable"] = this.receiveByStable_;
result["receiveStartTime"] = this.receiveStartTime_;
result["playedTime"] = this.playedTime_;
result["completedTime"] = this.completedTime_;
}
});
p2p$.ns("com.webp2p.core.supernode");

p2p$.com.webp2p.core.supernode.MetaSegment = JClass.extend_({
id_ : 0,
startTime_ : 0,
startTimeActual_ : 0,
duration_ : 0,
urlOffset_ : 0,
index_ : 0,
pieceTnCount_ : 0,
piecePnCount_ : 0,
size_ : 0,
beginOfMeta_ : false,
directMode_ : false,
discontinuity_ : false,
p2pDisabled_ : false,
timeGapChecked_ : false,
advertMonitorReported_ : false,
url_ : "",
mediaUrl_ : "",
playUrl_ : "",
advertMonitorUrl_ : "",
programId_ : "",
pieces_ : null,
moreMediaUrls_ : null,
pictureWidth_ : 0,
pictureHeight_ : 0,

lastActiveTime_ : 0,
completedPieceCount_ : 0,
completedTime_ : 0,
completedSize_ : 0,
startReceiveTime_ : 0,
lastReceiveTime_ : 0,
lastPlayTime_ : 0,
receiveSpeed_ : 0,
m3u8LoadTime_ : 0,
tag_:"com::relayCore::channels::meta::MetaSegement",

init : function() {
this.pieces_ = [];
this.id_ = -1;
this.startTime_ = 0;
this.startTimeActual_ = 0;
this.duration_ = 0;
this.urlOffset_ = -1;
this.index_ = 0;
this.pieceTnCount_ = 0;
this.piecePnCount_ = 0;
this.size_ = 0;
this.lastActiveTime_ = 0;
this.completedPieceCount_ = 0;
this.completedTime_ = 0;
this.completedSize_ = 0;
this.startReceiveTime_ = 0;
this.lastReceiveTime_ = 0;
this.lastPlayTime_ = 0;
this.receiveSpeed_ = 0;
this.beginOfMeta_ = false;
this.directMode_ = false;
this.discontinuity_ = false;
this.p2pDisabled_ = false;
this.timeGapChecked_ = false;
this.advertMonitorReported_ = false;
this.m3u8LoadTime_ = 0;
},

getPieceIndex_ : function(type, id) {
for ( var n = 0; n < this.pieces_.length; n++) {
var piece = this.pieces_[n];
if (piece.type_ == type && piece.id_ == id) {
return n;
}
}
return -1;
},

checkPieceCompletion_ : function() {

var nowTime = p2p$.com.common.Global.getMilliTime_();
this.lastReceiveTime_ = nowTime;
this.completedPieceCount_ = 0;
this.completedSize_ = 0;
for ( var n = 0; n < this.pieces_.length; n++) {
var piece = this.pieces_[n];
if (piece.writeTimes_ > 0) {
this.completedPieceCount_++;
if (piece.size_ >= 0) {
this.completedSize_ += piece.size_;
}
}
}
if (this.completedPieceCount_ == this.pieces_.length) {
this.completedTime_ = nowTime;
P2P_ULOG_TRACE(P2P_ULOG_FMT("{0}::Segment({1}) download complete",this.tag_, this.id_, this.pieces_.length));
if (this.completedSize_ <= 0) {
this.completedSize_ = this.size_;
}
}
if (this.startReceiveTime_ > 0 && nowTime > this.startReceiveTime_) {
this.receiveSpeed_ = this.completedSize_ * 1000 / (nowTime - this.startReceiveTime_);
}
},

resetPieceCompletion_ : function() {
this.lastPlayTime_ = 0;
this.completedTime_ = 0;
this.completedPieceCount_ = 0;
this.completedSize_ = 0;
for ( var n = 0; n < this.pieces_.length; n++) {
var piece = this.pieces_[n];
piece.completedTime_ = 0;
piece.writeTimes_ = 0;
piece.playedTime_ = 0;
piece.recvTimes_ = 0;
}
},

formatPlayUrl_ : function(storageId) {
return "/play/slices/" + this.id_ + ".ts?id=" + storageId + "&segment=" + this.id_;
},
getAllStatus_ : function(result) {
result["id"] = this.id_;
result["index"] = this.index_;
result["duration"] = this.duration_;
result["url"] = this.url_;
result["pieceCount"] = this.pieces_.length;
result["pieceTnCount"] = this.pieceTnCount_;
result["piecePnCount"] = this.piecePnCount_;
result["size"] = this.size_;
result["startTime"] = this.startTime_;
result["startTimeActual"] = this.startTimeActual_;
result["lastActiveTime"] = this.lastActiveTime_;
result["completedTime"] = this.completedTime_;
result["completedPieceCount"] = this.completedPieceCount_;
result["completedSize"] = this.completedSize_;
result["startReceiveTime"] = this.startReceiveTime_;
result["lastReceiveTime"] = this.lastReceiveTime_;
result["receiveSpeed"] = this.receiveSpeed_;
result["beginOfMeta"] = this.beginOfMeta_;
result["discontinuity"] = this.discontinuity_;

var pendingPieceCount = 0;
var resultPieces = result["pieces"] = [];
for ( var n = 0; n < this.pieces_.length; n++) {
var piece = this.pieces_[n];
if (piece.completedTime_ <= 0 && piece.receiveStartTime_ > 0) {
pendingPieceCount++;
}
var resultPiecesStatus = resultPieces[n] = {};
piece.getAllStatus_(resultPiecesStatus);
}
result["pendingPieceCount"] = pendingPieceCount;
}
});
p2p$.ns('com.webp2p.logic.base');
p2p$.com.webp2p.logic.base.Channel = JClass.extend_({
tag_:"com::webp2p::logic::base::Channel",
channelType_ : "base",
type_ : 0,
groupType_ : 0,
id_ : "",
playerTaskId_ : "",
playerHistoryKey_ : "",
globalParams_ : "",
context_ : null,//
url_ : null,//
player_:null,

protocolPool_ : null,
manager_ : null,

stablePeers_ : null,
otherPeers_ : null,
statData_ : null,

opened_ : false,
paused_ : false,
reopenMode_ : false,
redirectMode_ : false,
hlsMode_ : false,
directMetaMode_ : false,
icpCode_ : 0,
createTime_ : 0,
openTime_ : 0,
activeTime_ : 0,
closeTime_ : 0,
urlTagTime_ : 0,
maxSleepTime_ : 0,
maxSilentTime_ : 0,
channelOpenedTime_ : 0,
mediaStartTime_ : 0,
mediaActiveTime_ : 0,
playerStartTime_ : 0,
playerFlushTime_ : 0,
playerFlushInterval_ : 0,
playerFlushMaxInterval_ : 0,
playerInitialPosition_ : 0,
playerSkipPosition_ : 0,
playerSkipDuration_ : 0,
lastScheduleTime_ : 0,
lastPeerSortTime_ : 0,
lastPieceShareInUpdateTime_ : 0,
lastMessageUpdateTime_ : 0,
firstSegmentId_ : 0,
playerSegmentId_ : 0,
urgentSegmentId_ : 0,
urgentSegmentEndId_ : 0,
completedSegmentId_ : 0,
urgentSegmentIndex_ : 0,
urgentIncompleteCount_ : 0,
otherPeerRequestCount_ : 0,
checksumTryTimes_ : 0,

gslb_:null,//调出
meta_:null,//m3u8
metaData_ : null,//切片数据
/*meta信息*/
metaResponseCode_ : 0,
metaResponseDetails_ : "",
metaResponseType_ : "",
metaResponseBody_ : "",

checksumServerResponseCode_ : 0,
segmentNotFoundTimes_ : 0,
checksumLoadTime_ : 0,
checksumFileData_ : "",

peerReceiveTimeout_ : 0,
peerDeadTimeout_ : 0,
selectorReported_ : false,

rtmfpServerReported_ : false,
rtmfpGatherReported_ : false,
cdeTrackerReported_ : false,
webrtcServerReported_ : false,

firstReceivePieceReported_ : false,
p2pFirstPieceReported_ : false,
playerPositionSkipped_ : false,
playerBufferingSkipped_ : false,
selfRanges_ : "",
firstSeekTime_ : 0,
scheduleTimer_ : null,
reportTimer_ : null,
static_:null,//统计上报
strings_:null,
global_:null,
config_:null,
/**
* params
* type:播放类型
* channelUrl:下载地址
**/
init : function(type, channelUrl, decodedUrl, mgr) {
// console.debug("base.Channel init");
this.strings_ = p2p$.com.common.String;
this.global_ = p2p$.com.common.Global;
this.config_ = p2p$.com.selector.Config;
this.context_ = new p2p$.com.webp2p.core.supernode.Context();
this.metaData_ = new p2p$.com.webp2p.core.supernode.MetaData();
this.statData_ = new p2p$.com.webp2p.logic.base.StatData();
this.gslb_ = new p2p$.com.webp2p.logic.base.Gslb(this,decodedUrl);
this.meta_ = new p2p$.com.webp2p.logic.base.Meta(this,type);
this.selfRangesMessage_ = new p2p$.com.webp2p.protocol.base.Message();
this.stablePeers_ = [];
this.otherPeers_ = [];
this.id_ = p2p$.com.webp2p.core.common.Md5.hexString_(channelUrl).toLowerCase();
this.metaData_.type_ = type;
this.metaData_.channelUrl_ = channelUrl;
this.metaData_.storageId_ = this.id_;
this.manager_ = mgr;
this.type_ = type;
this.url_ = decodedUrl;

this.groupType_ = 0;
this.opened_ = false;//
this.paused_ = false;//
this.reopenMode_ = false;
this.redirectMode_ = false;
this.hlsMode_ = true;
this.directMetaMode_ = false;
this.icpCode_ = 0; // default icp
this.closeTime_ = 0;
this.urlTagTime_ = 0;
this.maxSleepTime_ = 60 * 1000;
this.maxSilentTime_ = 120 * 1000;
this.channelOpenedTime_ = 0;
this.mediaStartTime_ = 0;
this.mediaActiveTime_ = 0;
this.playerStartTime_ = 0;
this.playerFlushTime_ = 0;
this.playerFlushInterval_ = 0;
this.playerFlushMaxInterval_ = 0;
this.playerInitialPosition_ = -1;
this.playerSkipPosition_ = -1;
this.playerSkipDuration_ = 0;
this.lastScheduleTime_ = 0;
this.lastPeerSortTime_ = 0;
this.lastPieceShareInUpdateTime_ = 0;
this.lastMessageUpdateTime_ = 0;
this.firstSegmentId_ = -1;
this.playerSegmentId_ = -1;
this.urgentSegmentId_ = -1;
this.urgentSegmentEndId_ = -1;
this.completedSegmentId_ = -1;
this.urgentSegmentIndex_ = 0;
this.urgentIncompleteCount_ = 0;
this.otherPeerRequestCount_ = 0;

this.selectorReported_ = false;
this.rtmfpServerReported_ = false;
this.rtmfpGatherReported_ = false;
this.webrtcServerReported_ = false;
this.cdeTrackerReported_ = false;
this.firstReceivePieceReported_ = false;
this.p2pFirstPieceReported_ = false;
this.playerPositionSkipped_ = false;
this.playerBufferingSkipped_ = false;

this.checksumTryTimes_ = 0;
this.checksumServerResponseCode_ = 0;
this.segmentNotFoundTimes_ = 0;
this.openTime_ = 0;
this.createTime_ = this.activeTime_ = this.global_.getMilliTime_();

// default config
this.peerReceiveTimeout_ = 30 * 1000;
this.peerDeadTimeout_ = 30 * 1000;

// gslb reload
this.checksumLoadTime_ = 0;
this.selfRanges_ = "";
this.scheduleTimer_ = null;
this.reportTimer_ = null;
this.player_ = null;
if(p2p$.com.tools)
{
this.static_ = new p2p$.com.tools.collector.Statics(this);
}
},
setPlayer_:function(player)
{
this.player_ = player;
},
loadParams_ : function(params, customParams) {
this.globalParams_ = params;
this.playerTaskId_ = params["taskid"];
if (params.hasOwnProperty("icp")) {
this.icpCode_ = params["icp"];
}
this.metaData_.taskId_ = this.playerTaskId_;
this.metaData_.rangeParamsSupported_ = (this.icpCode_ == 0); // only default icp support range params
this.context_.loadParams_(this.globalParams_, customParams);
},

updateActiveTime_ : function(activate) {
this.activeTime_ = this.global_.getMilliTime_();
},

setUrlTagTime_ : function(tagTime) {
this.urlTagTime_ = tagTime;
},

open : function() {

this.checksumTryTimes_ = 0;
this.checksumServerResponseCode_ = 0;
this.segmentNotFoundTimes_ = 0;
this.openTime_ = this.activeTime_ = this.global_.getMilliTime_();
this.mediaActiveTime_ = 0;
this.urgentSegmentId_ = 0;
this.urgentIncompleteCount_ = 0;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}:open channel",this.tag_));
if (this.protocolPool_ != null) {
this.protocolPool_.exit();
}
this.protocolPool_ = new p2p$.com.webp2p.protocol.base.Pool(this.manager_.getEnviroment_(), this.context_, this.metaData_, this);
this.opened_ = true;
var env = this.manager_.getEnviroment_();
env.setChannelParams_(this.url_.params_);
this.context_.initialize_(this.url_, env);
this.sendStatus_({type:"VIDEO.INIT"});
return true;
},
onOpened_:function() {},
onTimeout_:function()
{
return true;
},
onSchedule_:function()
{
return true;
},
close_ : function() {
this.opened_ = false;
this.closeTime_ = this.global_.getMilliTime_();
this.stablePeers_ = [];
this.otherPeers_ = [];
this.meta_.close_();
if(this.static_){
this.static_.close_();
this.static_ = null;
}
if (this.timer_) {
clearTimeout(this.timer_);
this.timer_ = null;
}
if (this.scheduleTimer_) {
clearTimeout(this.scheduleTimer_);
this.scheduleTimer_ = null;
}
if (this.reportTimer_) {
clearTimeout(this.reportTimer_);
this.reportTimer_ = null;
}
if (this.protocolPool_ != null) {
this.protocolPool_.exit();
// if( responseSchedule_.get() ) responseSchedule_->close();
}

this.protocolPool_ = null;
// responseSchedule_.reset();

if (this.type_ != p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeDownload) {
var bucket = this.getStorageBucket_();
for ( var n = 0; n < this.metaData_.segments_.length; n++) {
var segment = this.metaData_.segments_[n];
var objectId = this.metaData_.getSegmentStorageId_(segment.id_);
bucket.remove(objectId);
}
}
this.metaData_.segments_ = [];
return true;
},

pause : function() {
},

setChecksumTimeout_ : function() {
},
setProtocolTimeout_ : function() {
},
flushMetaCache_ : function() {
},

isOpened_ : function() {
return this.opened_;
},

isPaused_ : function() {
return this.paused_;
},
onGslbComplete_:function()
{
if (!("" == this.metaData_.sourceUrl_)) {
var params={
utime:this.gslb_.gslbTotalUseTime_,
err:200,
sn:this.gslb_.sn_
};
this.sendStatus_({type:"VIDEO.GSLB.LOADED",params:params});
if (this.hlsMode_) {
this.downloadMeta_();
}
}
},
downloadMeta_ : function() {
this.activeTime_ = this.global_.getMilliTime_();
this.sendStatus_({type:"VIDEO.META.LOADING"});
this.meta_.load_(this.context_.gslbData_["nodelist"]);
},

onMetaComplete_ : function(code, info, data) {
this.metaResponseCode_ = code;
this.metaResponseDetails_ = info;
if (200 != code && 302 != code) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Meta complete, channel({1}) open failed, response code({2}),info({3}) to player",this.tag_,this.id_,code,info));
var params={};
params["err"] = code;
switch(code){
case 20500:
case 20501:
params["utime"]=this.gslb_.gslbTotalUseTime_;
break;
case 20601:
params["utime"]=this.meta_.metaUseTime_;
break;
}
this.sendStatus_({type:"VIDEO.PLAY.ERROR",code:code,info:info,params:params});
} else {
var params={
utime:this.meta_.metaUseTime_
};
this.sendStatus_({type:"VIDEO.META.LOADED",code:0,params:params});
this.onOpened_();
if (this.channelOpenedTime_ <= 0) {
this.channelOpenedTime_ = this.global_.getMilliTime_();
}
if (this.firstSeekTime_ > 0) {

if (this.metaData_) {
for ( var n = 0; n < this.metaData_.segments_.length; n++) {
var segment = this.metaData_.segments_[n];
if (segment.startTime_ <= this.firstSeekTime_ * 1000 && this.firstSeekTime_ * 1000 < segment.startTime_ + segment.duration_) {
this.urgentSegmentId_ = segment.id_;
break;
}
}
}
}
if (this.firstSegmentId_ < 0 && this.metaData_.segments_.length > 0) {
this.firstSegmentId_ = this.metaData_.segments_[0].id_;
}
}
},

setScheduleTimeout_ : function(tag, timeoutMs) {
var me = this;
this.scheduleTimer_ = setTimeout(function() {
me.onTimeout_(tag);
}, timeoutMs);
},
setReportTimeout_ : function(tag, timeoutMs) {
var me = this;
this.reportTimer_ = setTimeout(function() {
me.onTimeout_(tag);
}, timeoutMs);
},
onReport_ : function() {
if (this.static_) {
this.static_.sendTraffic_(4,false);
}
},
/*自身piece信息*/
fillSelfPieceRanges_ : function(message) {
message.ranges_ = [];
if (!this.context_.p2pUploadEnabled_ || !this.manager_.getEnviroment_().p2pUploadEnabled_) {
var littleRange = new p2p$.com.webp2p.protocol.base.PieceRangeItem();
littleRange.type_ = p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn;
littleRange.start_ = 0;
littleRange.count_ = 1;
message.ranges_.push(littleRange);
return;
}

var lastTnRange = new p2p$.com.webp2p.protocol.base.PieceRangeItem();
var lastPnRange = new p2p$.com.webp2p.protocol.base.PieceRangeItem();

lastTnRange.type_ = p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn;
lastTnRange.start_ = -1;
lastTnRange.count_ = 0;
lastPnRange.type_ = p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypePn;
lastPnRange.start_ = -1;
lastPnRange.count_ = 0;
for ( var n = 0; n < this.metaData_.segments_.length; n++) {
var segment = this.metaData_.segments_[n];
if (segment.p2pDisabled_) {
continue;
}
for ( var k = 0; k < segment.pieces_.length; k++) {
var piece = segment.pieces_[k];
var lastRange = (piece.type_ == p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn) ? lastTnRange : lastPnRange;
if (piece.completedTime_ <= 0) {
// complete
if (lastRange.start_ >= 0) {
message.ranges_.push(lastRange);
if (piece.type_ == p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn) {
lastTnRange = new p2p$.com.webp2p.protocol.base.PieceRangeItem();
lastTnRange.type_ = p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn;
lastTnRange.start_ = -1;
lastTnRange.count_ = 0;
} else {
// lastPnRange
lastPnRange = new p2p$.com.webp2p.protocol.base.PieceRangeItem();
lastPnRange.type_ = p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypePn;
lastPnRange.start_ = -1;
lastPnRange.count_ = 0;
}
}
continue;
}
if (lastRange.start_ < 0) {
lastRange.start_ = piece.id_;
}
lastRange.count_ = Math.max(0, piece.id_ - lastRange.start_) + 1;
}
}
if (lastTnRange.start_ >= 0) {
message.ranges_.push(lastTnRange);
}
if (lastPnRange.start_ >= 0) {
message.ranges_.push(lastPnRange);
}
this.selfRanges_ = "";
for ( var n = 0; n < message.ranges_.length; n++) {
var range = message.ranges_[n];
if (range.type_ == 0) {
var end = range.start_ + range.count_ - 1;
this.selfRanges_ += "type:" + range.type_ + ",start:" + range.start_ + ",end:" + end + ",count:" + range.count_ + "\n";
}
}
},

resetPeerMessage_ : function(nowTime, resetSpeed, peer) {
// send clean message
var message = new p2p$.com.webp2p.protocol.base.Message();
var cleanRequest = new p2p$.com.webp2p.protocol.base.RequestDataItem();
cleanRequest.pieceId_ = -1;
message.requests_.push(cleanRequest);
peer.lastSegmentId_ = -1;
peer.pendingRequestCount_ = 0;
if (resetSpeed) {
peer.lastReceiveSpeed_ = 0;
}
peer.totalSendRequests_ = peer.totalReceiveResponses_;
peer.lastTimeoutTime_ = peer.activeTime_ = nowTime;
peer.session_.send(message);
},

checkTimeoutPeers_ : function(nowTime) {
var expireTime = nowTime - this.peerReceiveTimeout_;
if (this.metaData_.p2pGroupId_ == "") {
expireTime += (this.peerReceiveTimeout_ / 2);
}
for ( var n = 0; n < this.stablePeers_.length; n++) {
var item = this.stablePeers_[n];
if (item.pendingRequestCount_ <= 0) {
continue;
}
if ((item.activeTime_ >= expireTime) && (item.lastSegmentId_ < 0 || item.lastSegmentId_ >= this.urgentSegmentId_)) {
// all pending downloads before urgent segment should be clear
continue;
}

item.timeoutTimes_++;

P2P_ULOG_INFO(P2P_ULOG_FMT("{0} [{1}]Peer stable blocked {2} times, peer id({3}), address({4}),lastSegment({5}),urgentSegment({6}),isTiemout({7})",this.tag_,p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.type_), item.timeoutTimes_, item.session_.getRemoteId_(), item.session_.getRemoteAddress_(), item.lastSegmentId_, this.urgentSegmentId_, (item.activeTime_ < expireTime ? "true" : "false")));

this.resetPieceReceivingBySession_(item.sessionId_);
this.resetPeerMessage_(nowTime, false, item);
}

for ( var n = 0; n < this.otherPeers_.length; n++) {
var item = this.otherPeers_[n];
if (item.receivePiece_.receiveStartTime_ <= 0) {
continue;
}

if (item.receivePiece_.receiveStartTime_ + this.peerReceiveTimeout_ > nowTime) {
continue;
}

// timeout
item.lastReceiveSpeed_ = 0;
item.timeoutTimes_++;
item.lastTimeoutTime_ = nowTime;
item.receivePiece_.receiveStartTime_ = 0;
item.receivePiece_.receiveByOther_ = false;

// release piece mark
var segmentIndex = this.metaData_.getSegmentIndexByPieceId_(item.receivePiece_.type_, item.receivePiece_.id_);
if (segmentIndex < 0 || segmentIndex >= this.metaData_.segments_.length) {
continue;
}
var segment = this.metaData_.segments_[segmentIndex];
var pieceIndex = segment.getPieceIndex_(item.receivePiece_.type_, item.receivePiece_.id_);
if (pieceIndex < 0 || pieceIndex >= segment.pieces_.length) {
continue;
}
var piece = segment.pieces_[pieceIndex];
piece.receiveStartTime_ = 0;
piece.receiveSessionId_ = 0;
piece.receiveByOther_ = false;

P2P_ULOG_INFO(P2P_ULOG_FMT("{0} [{1}]Peer timeout {2} times, peer({3}://{4}), address({5}), segment id({6}), piece type({7}), id({8}), {9}/{10}",this.tag_, this.getTypeName_(), item.timeoutTimes_, item.session_.getTypeName_(), item.session_.getRemoteId_(), item.session_.getRemoteAddress_(),segment.id_, p2p$.com.webp2p.core.common.Enum.getPieceTypeName_(item.receivePiece_.type_), item.receivePiece_.id_, (piece.index_ + 1),segment.pieces_.length));
}
},

checkTimeoutPieces_ : function(nowTime) {
for ( var n = 0; n < this.metaData_.segments_.length; n++) {
var segment = this.metaData_.segments_[n];
if (segment.p2pDisabled_) {
continue;
}
if (segment.id_ < this.urgentSegmentId_ || segment.completedTime_ > 0) {
continue;
}
for ( var k = 0; k < segment.pieces_.length; k++) {
var piece = segment.pieces_[k];
if (piece.completedTime_ > 0 || // already complete
!piece.receiveByStable_ || // not receving
piece.receiveStartTime_ <= 0 || // not receving by stable
(piece.receiveStartTime_ + this.peerReceiveTimeout_ > nowTime)) // not timeout yet
{
continue;
}

// timeout
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} [{1}]Piece stable timeout, channel://{2}/{3}/{4}/{5}, {6}/{7}, release",this.tag_,p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.type_), this.id_, segment.id_, piece.getTypeName_(), piece.id_,(piece.index_ + 1), segment.pieces_.legnth));
piece.receiveByStable_ = false;
piece.receiveStartTime_ = 0;
piece.receiveSessionId_ = 0;
}
}
},

checkPeerPieceRanges_ : function(nowTime) {
var minInterval = this.context_.p2pShareRangeInterval_ * 1000;
for ( var n = 0; n < this.otherPeers_.length; n++) {
var item = this.otherPeers_[n];
if (item.lastRangeExchangeTime_ + minInterval > nowTime) {
continue;
}

if (!this.selfRangesMessage_.ranges_.length == 0) {
item.lastRangeExchangeTime_ = nowTime;
item.statSendMessage_(this.selfRangesMessage_);
item.session_.send(this.selfRangesMessage_);
}
}
},

resetPieceReceivingBySession_ : function(sessionId) {
for ( var n = 0; n < this.metaData_.segments_.length; n++) {
var segment = this.metaData_.segments_[n];
if (segment.completedTime_ > 0) {
continue;
}
for ( var k = 0; k < segment.pieces_.length; k++) {
var piece = segment.pieces_[k];
if (piece.receiveSessionId_ == sessionId) {
piece.receiveByStable_ = false;
piece.receiveByOther_ = false;
piece.receiveStartTime_ = 0;
piece.receiveSessionId_ = 0;
}
}
}
},

getStorageBucket_ : function() {
return p2p$.com.webp2p.core.storage.Pool.getDefaultBucket_();
},

resetSegmentPieceCompletion_ : function(segmentId) {
var segmentIndex = this.metaData_.getSegmentIndexById_(segmentId);
if (segmentIndex < 0 || segmentIndex >= this.metaData_.segments_.length) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Reset segment piece completion find segment({1}) failed",this.tag_, segmentId));
return false;
}
var segment = this.metaData_.segments_[segmentIndex];
segment.resetPieceCompletion_();
P2P_ULOG_TRACE(P2P_ULOG_FMT("{0}::Reset segment piece completion reset segment({1}) success",this.tag_, segmentId));
return true;
},

processMessageResponses_ : function(nowTime, peer, message) {
var updatePieceCount = 0;
var invalidPieces = 0;
var bucket = this.getStorageBucket_();
var session = peer.session_;
// responses: update storage data
for ( var n = 0; n < message.responses_.length; n++) {
var item = message.responses_[n];
if (item.pieceId_ < 0) {
// empty response
break;
}
var segmentIndex = -1;
if (item.segmentId_ >= 0) {
segmentIndex = this.metaData_.getSegmentIndexById_(item.segmentId_);
} else {
segmentIndex = this.metaData_.getSegmentIndexByPieceId_(item.pieceType_, item.pieceId_);
}
if (segmentIndex < 0 || segmentIndex >= this.metaData_.segments_.length) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0} [{1}]Response piece from session({2}://{3}) segment not found for channel({4}),segment idx({5}), piece type({6}), id({7}), drop it!",this.tag_, p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.type_), session.getTypeName_(), session.getRemoteAddress_(), this.id_, segmentIndex, p2p$.com.webp2p.core.common.Enum.getPieceTypeName_(item.pieceType_), item.pieceId_));
invalidPieces++;
peer.totalInvalidErrors_++;
if(this.static_)
{
this.static_.sendTraffic_(0,session.getType(),0,0,item.data_.length);
}
continue;
}
var segment = this.metaData_.segments_[segmentIndex];
var pieceIndex = segment.getPieceIndex_(item.pieceType_, item.pieceId_);
if (pieceIndex < 0 || pieceIndex >= segment.pieces_.length) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0} [{1}]Response piece from session({2}://{3}) piece not found for channel({4}),segment idx({5}), piece type({6}), id({7}), idx({8}), drop it!",this.tag_, p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.type_),session.getTypeName_(), session.getRemoteAddress_(), this.id_, segmentIndex, p2p$.com.webp2p.core.common.Enum.getPieceTypeName_(item.pieceType_), item.pieceId_, pieceIndex));
invalidPieces++;
peer.totalInvalidErrors_++;
if(this.static_)
{
this.static_.sendTraffic_(0,session.getType(),0,0,item.data_.length);
}
continue;
}
// verify checksum
var piece = segment.pieces_[pieceIndex];
piece.receiveByStable_ = false;
piece.receiveStartTime_ = 0;
if (item.data_.length == 0) {
continue;
}
if ((piece.size_ > 0 && item.data_.length != piece.size_) || !this.metaData_.verifyPiece_(piece, item.data_, item.data_.length)) {
// checksum check failed
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0} [{1}]Verify piece size/checksum failed from session({2}://{3}), peer id({4}),segment({5}), piece type({6}), id({7}), size({8}/{9})",this.tag_, p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.type_), session.getTypeName_(), session.getRemoteAddress_(), session.getRemoteId_(), segment.id_, p2p$.com.webp2p.core.common.Enum.getPieceTypeName_(piece.type_), piece.id_, item.data_.length, piece.size_));
peer.lastReceiveSpeed_ = 0; // reset speed
peer.totalInvalidErrors_++;
peer.setPieceInvalid_(piece.type_, piece.id_, true);
invalidPieces++;
if (!(piece.size_ > 0 && item.data_.length != piece.size_)) {
peer.totalChecksumErrors_++;
}
if(this.static_)
{
this.static_.sendTraffic_(0,session.getType(), 0, 1,item.data_.length);
}
continue;
}

var objectId = this.metaData_.getSegmentStorageId_(segment.id_);
if (!bucket.exists(objectId)) {
if (segment.completedPieceCount_ > 0) {
updatePieceCount++;
segment.resetPieceCompletion_();
}
}

if (segment.size_ > 0) {
bucket.reserve(objectId, segment.size_);
} else if (segment.size_ == 0 && segment.pieces_.length == 1) {
bucket.reserve(objectId, item.data_.length);
}
if (!bucket.write(objectId, piece.offset_, item.data_, item.data_.length)) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0} [{1}]Write piece to storage({2}) failed from session({3}://{4}), peer id({5}),segment({6}), piece type({7}), id({8}), size({9}/{10})",this.tag_, p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.type_), bucket.getName_(), session.getTypeName_(), session.getRemoteAddress_(), session.getRemoteId_(), segment.id_, p2p$.com.webp2p.core.common.Enum.getPieceTypeName_(piece.type_), piece.id_, item.data_.length, piece.size_));
bucket.remove(objectId);
segment.resetPieceCompletion_();
if(this.static_)
{
this.static_.sendTraffic_(0,session.getType(), 0, 0,item.data_.length);
}
continue;
}
piece.writeTimes_ = this.global_.getMilliTime_();
peer.lastSegmentId_ = peer.lastSegmentId_ > segment.id_ ? peer.lastSegmentId_ : segment.id_;
if (this.mediaStartTime_ <= 0) {
this.mediaStartTime_ = this.global_.getMilliTime_();
}

piece.receiveSessionId_ = 0;
if (piece.recvTimes_++ < 1) {
// stat, avoid duplicated data
var isUrgent = (this.urgentSegmentId_ < 0 || this.urgentSegmentEndId_ < 0)
|| (segment.id_ >= this.urgentSegmentId_ && segment.id_ <= this.urgentSegmentEndId_);
updatePieceCount++;
piece.completedTime_ = nowTime;
piece.receiveProtocol_ = session.getType();
peer.statReceiveData_(1, item.data_.length);
this.statData_.addReceiveData_(isUrgent, session.getType(), 1, item.data_.length);
if(this.static_)
{
this.static_.sendTraffic_(1,session.getType(), session.getTerminalType_(), item.data_.length);
}
if (this.statData_.firstPieceFetchTime_ <= 0) {
this.statData_.firstPieceFetchTime_ = nowTime - this.createTime_;
}

if (!this.firstReceivePieceReported_) {
this.firstReceivePieceReported_ = true;
this.sendStatus_({type:"ACTION.FIRST.PIECE",code:p2p$.com.webp2p.core.common.ERROR_CODE.kErrorSuccess, host:session.getRemoteAddress_(), ut:nowTime - this.createTime_});
}
if (!this.p2pFirstPieceReported_ && !session.isStable_()) {
this.p2pFirstPieceReported_ = true;
this.sendStatus_({type:"ACTION.FIRST.P2P.PIECE",code:p2p$.com.webp2p.core.common.ERROR_CODE.kErrorSuccess, host:session.getRemoteAddress_(), ut:nowTime - this.createTime_});
}
}

segment.lastActiveTime_ = nowTime;
if (segment.size_ <= 0) {
segment.size_ = item.data_.length;
}
segment.checkPieceCompletion_();
if (segment.completedTime_ > 0) {
this.completedSegmentId_ = this.completedSegmentId_ > segment.id_ ? this.completedSegmentId_ : segment.id_;
this.statData_.totalReceiveDuration_ += segment.duration_;
// asyncSchedule(true);
}
}

if (message.responses_.length > 0) {
peer.timeoutTimes_ = 0;
var pendingRequestCount = peer.pendingRequestCount_ - message.responses_.length;
peer.pendingRequestCount_ = 0 > pendingRequestCount ? 0 : pendingRequestCount;
peer.receivePiece_.receiveStartTime_ = 0;
peer.updateSpeed_(nowTime);
}
return updatePieceCount;
},

updatePeersSpeed_ : function(nowTime, peers) {
for ( var n = 0; n < peers.length; n++) {
var peer = peers[n];
peer.updateSpeed_(nowTime);
}
},

getNextIdleStablePeer_ : function() {
var result = null;
for ( var n = 0; n < this.stablePeers_.length; n++) {
var item = this.stablePeers_[n];
if (item.pendingRequestCount_ <= 0) {
result = item;
break;
}
}
return result;
},

getUrgentMaxDuration_ : function(ratio) {
var maxDuration = this.context_.p2pUrgentSize_ * ratio;
if (this.urgentSegmentIndex_ >= 0 && this.urgentSegmentIndex_ < this.metaData_.segments_.length
&& this.urgentSegmentIndex_ + 1 < this.metaData_.segments_.length) {
// at least 2 segment(s)
var segment1 = this.metaData_.segments_[this.urgentSegmentIndex_];
var segment2 = this.metaData_.segments_[this.urgentSegmentIndex_ + 1];
if (maxDuration <= segment1.duration_) {
maxDuration = segment1.duration_ + segment2.duration_;
// P2P_ULOG_TRACE(P2P_ULOG_FMT("{0}+{1}={2}",segment1.duration_,segment2.duration_,maxDuration));
}
}
return maxDuration;
},

requireSegmentData_ : function(requestSegmentId, urgentSegmentId) {
var segmentId = requestSegmentId;
this.updateActiveTime_(true);
this.mediaActiveTime_ = this.global_.getMilliTime_();
if (this.playerStartTime_ <= 0) {
this.playerStartTime_ = this.mediaActiveTime_;
}
this.updateUrgentSegment_(urgentSegmentId);
if (this.metaData_.segments_.length <= 0) {
// not load yet
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}:requireSegmentData_ Segment({0}) not load yet", this.tag_,segmentId));
return null;
}
var segment = this.metaData_.getSegmentById_(segmentId);
if (segment == null) {
this.segmentNotFoundTimes_++;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}:requireSegmentData_ Segment({0}) Not Found",this.tag_, segmentId));
return null;
}
var bucket = this.getStorageBucket_();
var objectId = this.metaData_.getSegmentStorageId_(segmentId);
var objectExists = bucket.exists(objectId);
var retStream = null;
if (segment.completedTime_ > 0 && objectExists) {
retStream = bucket.read(objectId, 0);
segment.lastPlayTime_ = this.activeTime_;
this.statData_.totalPlayedDuration_ += segment.duration_;
for ( var n = 0; n < segment.pieces_.length; n++) {
var piece = segment.pieces_[n];
piece.playedTime_ = this.activeTime_;
this.statData_.totalPlayedPieces_++;
this.statData_.totalPlayedBytes_ += piece.size_;
}
} else {
if (segment.completedTime_ > 0 && !objectExists) {
// has been clearExpiredBlock ，need resetPieceCompletion_
segment.resetPieceCompletion_();
this.fillSelfPieceRanges_(this.selfRangesMessage_);
}
// need re download
this.onSchedule_(false);
}
return {
segment : segment,
stream : retStream
};
},
setFirstSeekTime_ : function(firstseektime) {
this.firstSeekTime_ = firstseektime;
},
updateUrgentSegment_ : function(requireId) {
//		P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::updateUrgentSegment_ id({1})",this.tag_,requireId));
this.urgentSegmentId_ = requireId;
},

onProtocolSelectorOpen_ : function(errorCode) {
if (this.protocolPool_ == null || !this.protocolPool_.isValid_()) {
// already closed
return;
}

P2P_ULOG_INFO(P2P_ULOG_FMT("{0} [{1}]Protocol selector({2}) open, channel({3}), code({4}), {5}",this.tag_, p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.type_), this.context_.selectorServerHost_, this.id_, errorCode,(this.opened_ && p2p$.com.webp2p.core.common.ERROR_CODE.kErrorSuccess != errorCode) ? "FAILED" : "OK"));

if (p2p$.com.webp2p.core.common.ERROR_CODE.kErrorSuccess == errorCode) {
// report only open successfully
if (!this.selectorReported_ && this.context_.selectorConnectedTime_ > 0) {
this.selectorReported_ = true;
// update gather and websocket trakcer info
if(this.static_)
{
var url = new p2p$.com.common.Url();
url.fromString_(this.context_.trackerServerHost_);
var params_={};
params_["trackerServerIp_"]=url.host_;
params_["trackerServerPort_"]=url.port_;
url.fromString_(this.context_.webrtcServerHost_);
params_["webrtcServerIp_"]=url.host_;
params_["webrtcServerPort_"]=url.port_;
url.fromString_(this.context_.stunServerHost_);
params_["stunServerIp_"]=url.host_;
params_["stunServerPort_"]=url.port_;
this.static_.setTrafficParams_(params_);
this.sendStatus_({type:"ACTION.SELECTOR.CONNECTED", code:0,host:this.context_.selectorServerHost_, ut:this.context_.selectorConnectedTime_});
}
}
}
},

onProtocolSessionOpen_ : function(session) {
if (this.protocolPool_ == null) {
return;
}
var peer = null;// = new p2p$.com.webp2p.logic.base.Peer();
var peers = session.isStable_() ? this.stablePeers_ : this.otherPeers_;
session.updateTerminalType_();

// bool alreadyExists = false;
var sameTypeCount = 0;
for ( var n = 0; n < peers.length; n++) {
var item = peers[n];
if (item.session_ == session) {
peer = item;
}
if (item.session_ && item.session_.getType() == session.getType()) {
sameTypeCount++;
}
}
//
if (peer != null) {
// reset peer timeout
peer.timeoutTimes_ = 0;
} else {
sameTypeCount++;
peer = new p2p$.com.webp2p.logic.base.Peer();
peer.session_ = session;
peers.push(peer);
}
peer.activeTime_ = this.global_.getMilliTime_();

if (!session.isStable_()) {
if(this.static_)
{
this.static_.sendTraffic_(2, session.getType(), sameTypeCount);
}
}

// tell him my piece ranges
if (!this.selfRangesMessage_.empty() && this.manager_.getEnviroment_().p2pEnabled_ && !session.isStable_()) {
peer.statSendMessage_(this.selfRangesMessage_);
session.send(this.selfRangesMessage_);
this.lastPieceShareInUpdateTime_ = this.global_.getMilliTime_();
}
this.onSchedule_(!session.isStable_());
},

onProtocolSessionMessage_ : function(session, message) {
if (this.protocolPool_ == null) {
return;
}
if (session == null) {
return;
}
// onProtocolSessionAccept(session);
var updatePieceCount = 0;
var nowTime = this.global_.getMilliTime_();
var peer = null;
var peers = session.isStable_() ? this.stablePeers_ : this.otherPeers_;
for ( var n = 0; n < peers.length; n++) {
var item = peers[n];
if (item.session_ == session) {
peer = item;
break;
}
}
if (peer == null) {
return;
}
peer.activeTime_ = nowTime;
peer.statReceiveMessage_(message);

var rangeUpdateCount = 0;
if (message.ranges_.length > 0) {
// ranges: update bitmap
rangeUpdateCount = this.processMessageRanges_(nowTime, peer, message);
}
//
var uploadable = (this.urgentIncompleteCount_ <= 0 || this.context_.p2pUrgentUploadEnabled_);
if (this.manager_.getEnviroment_().p2pEnabled_ && uploadable && !message.requests_.length == 0) {
this.processMessageRequests_(nowTime, peer, message);
}
//
if (message.responses_.length > 0) {
updatePieceCount += this.processMessageResponses_(nowTime, peer, message);
}
//
// if( updatePieceCount > 0 )
// {
this.fillSelfPieceRanges_(this.selfRangesMessage_);
// }
//
if ((rangeUpdateCount > 0 && (this.lastMessageUpdateTime_ + 300 * this.global_.kMicroUnitsPerMilli < nowTime))
|| message.responses_.length > 0) {
lastMessageUpdateTime_ = nowTime;
this.onSchedule_(!session.isStable_());
}
},

processMessageRequests_ : function(nowTime, peer, message) {
// requests: get piece
var totalResponsedSize = 0;
var responseMessage = new p2p$.com.webp2p.protocol.base.Message();
var bucket = this.getStorageBucket_();
var session = peer.session_;

// responseMessage.responses_.resize(message.requests_.size());
for ( var n = 0; n < message.requests_.length; n++) {
var item = message.requests_[n];
var responseItem = new p2p$.com.webp2p.protocol.base.ResponseDataItem();
responseMessage.responses_.push(responseItem);
responseItem.pieceId_ = item.pieceId_;
responseItem.pieceType_ = item.pieceType_;

do {
var segmentIndex = -1;
if (item.segmentId_ >= 0) {
segmentIndex = this.metaData_.getSegmentIndexById_(item.segmentId_);
} else {
segmentIndex = this.metaData_.getSegmentIndexByPieceId_(item.pieceType_, item.pieceId_);
}
if (segmentIndex < 0 || segmentIndex >= this.metaData_.segments_.length) {
// __ULOG_TRACE(__ULOG_FMT("logic::base::Channel", "[%s]Request piece from session(%s://%s) segment not found for channel(%s), "
// "segment idx(%d), piece type(%s), id(" _I64FMT_ "), ignore it!"),
// core::common::getMetaTypeName_(type_),
// session.getTypeName_(), session.getRemoteAddress_().c_str(), id_.c_str(),
// (int)segmentIndex, core::common::getPieceTypeName_(item.pieceType_), item.pieceId_);
break;
}

var segment = this.metaData_.segments_[segmentIndex];
if (segment.p2pDisabled_) {
// p2p disabled
break;
}

var objectId = this.metaData_.getSegmentStorageId_(segment.id_);
var objectExists = bucket.exists(objectId);
if (!objectExists) {
if (segment.completedPieceCount_ > 0) {
// expired, reset
segment.resetPieceCompletion_();
this.fillSelfPieceRanges_(this.selfRangesMessage_);
}
break;
}

var pieceIndex = segment.getPieceIndex_(item.pieceType_, item.pieceId_);
if (pieceIndex < 0 || pieceIndex >= segment.pieces_.length) {
// __ULOG_TRACE(__ULOG_FMT("logic::base::Channel", "[%s]Request piece from session(%s://%s) piece not found for channel(%s), "
// "segment idx(%d), piece type(%s), id(" _I64FMT_ "), idx(%d), ignore it!"),
// core::common::getMetaTypeName_(type_),
// session.getTypeName_(), session.getRemoteAddress_().c_str(), id_.c_str(),
// (int)segmentIndex, core::common::getPieceTypeName_(item.pieceType_), item.pieceId_, (int)pieceIndex);
break;
}

// verify checksum
var piece = segment.pieces_[pieceIndex];
// if( (piece.size_ > 0 && item.checksum_ != (size_t)piece.checksum_) || piece.completedTime_ <= 0 )
if (piece.completedTime_ <= 0) {
// checksum check failed
// __ULOG_TRACE(__ULOG_FMT("logic::base::Channel", "[%s]Request verify piece checksum/complete failed from session(%s://%s), peer
// id(%s), "
// "segment(" _I64FMT_ "), piece type(%s), id(" _I64FMT_ ")"),
// core::common::getMetaTypeName_(type_),
// session.getTypeName_(), session.getRemoteAddress_().c_str(), session.getRemoteId_().c_str(),
// segment.id_, core::common::getPieceTypeName_(piece.type_), piece.id_);
break;
}

responseItem.segmentId_ = segment.id_;
responseItem.pieceKey_ = piece.key_;
if (piece.size_ <= 0) {
// bucket.read(objectId, 0, responseItem.data_);
break;
} else {
responseItem.data_ = bucket.read(objectId, piece.offset_, piece.size_);
}
totalResponsedSize += responseItem.data_.length;
} while (false);
}

// if( !context_.p2pUploadLimit_ || !responseSchedule_ || !responseSchedule_->scheduleRequest(nowTime, peer, std::move(responseMessage),
// (int)totalResponsedSize))
// {
this.statData_.addSendData_(session.getType(), responseMessage.responses_.length, totalResponsedSize);
if(this.static_){
this.static_.sendTraffic_(3, session.getType(), session.getTerminalType_(), totalResponsedSize);
}
peer.statSendData_(responseMessage.responses_.length, totalResponsedSize);
peer.statSendMessage_(responseMessage);
session.send(responseMessage);
// }

return 0;
},

getOtherPeerRequestCount_ : function() {
var requestCount = 0;
for ( var n = 0; n < this.otherPeers_.length; n++) {
var item = this.otherPeers_[n];
if (item.receivePiece_.receiveStartTime_ <= 0) {
continue;
}
requestCount++;
}
return requestCount;
},

getStablePeersSpeedTooSlow_ : function() {
if (this.urgentSegmentIndex_ < 0 || this.urgentSegmentIndex_ >= this.metaData_.segments_.length) {
return false;
}

var stableTooSlow = false;
var firstSegment = this.metaData_.segments_[this.urgentSegmentIndex_];
if (firstSegment.size_ > 0 && firstSegment.duration_ > 0) {
var firstRate = firstSegment.size_ * 1000 / firstSegment.duration_;
var thresoldRate = firstRate * this.context_.cdnSlowThresholdRate_;
var fastStableSpeed = 0;
for ( var n = 0; n < this.stablePeers_.length; n++) {
var fastPeer = this.stablePeers_[n];
if (fastPeer.pendingRequestCount_ > 0) {
fastStableSpeed = fastPeer.lastReceiveSpeed_;
break;
}
}
if (fastStableSpeed >= 0 && fastStableSpeed < thresoldRate) {
stableTooSlow = true;
}
}

return stableTooSlow;
},

updateUrgentIncompleteCount_ : function() {
this.urgentIncompleteCount_ = 0;
if (this.urgentSegmentIndex_ < 0 || this.urgentSegmentIndex_ >= this.metaData_.segments_.length) {
return;
}

var maxDuration = this.context_.p2pUrgentSize_ * 1000;
var totalDuration = 0;
var urgentCount = 0;
for ( var n = this.urgentSegmentIndex_; n < this.metaData_.segments_.length; n++) {
var segment = this.metaData_.segments_[n];
if (segment.completedTime_ <= 0) {
this.urgentIncompleteCount_++;
}
totalDuration += segment.duration_;
urgentCount++;
if (urgentCount > 1 && totalDuration >= maxDuration) {
// urgent should has 2 segments at least if more segments eixst
break;
}
}
},

getNextIdleOtherPeer_ : function(pieceType, pieceId) {
var result = null;
for ( var n = 0; n < this.otherPeers_.length; n++) {
var item = this.otherPeers_[n];
if (item.timeoutTimes_ > 5) {
continue;
}

if (item.receivePiece_.receiveStartTime_ <= 0 && item.hasPiece_(pieceType, pieceId)) {
result = item;
break;
}
}
return result;
},

processMessageRanges_ : function(nowTime, peer, message) {
var rangeUpdateCount = 0;
var session = peer.session_;

// clean old bitmap status
peer.tnPieceMark_.clear(true);
peer.pnPieceMark_.clear(true);
peer.selfRanges_ = "";
for ( var n = 0; n < message.ranges_.length; n++) {
var range = message.ranges_[n];
if (range.type_ == 0) {
var end = range.start_ + range.count_ - 1;
peer.selfRanges_ += "type:" + range.type_ + ",start:" + range.start_ + ",end:" + end + ",count:" + range.count_ + "\n";
}

var bitmap = (range.type_ == p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn) ? peer.tnPieceMark_ : peer.pnPieceMark_;
var maxBits = p2p$.com.webp2p.core.supernode.BitmapStatic.kMaxBitCount;
for ( var index = range.start_, count = 0; count < range.count_ && count <= maxBits; index++, count++) {
var old = bitmap.setValue(index, true);
if (!old) {
rangeUpdateCount++;
}
}
}
if (this.manager_.getEnviroment_().p2pEnabled_ && message.ranges_.length != 0
&& (peer.lastRangeExchangeTime_ + this.context_.p2pShareRangeInterval_ * 1000 < nowTime)) {
if (!this.selfRangesMessage_.empty()) {
peer.lastRangeExchangeTime_ = nowTime;
peer.statSendMessage_(this.selfRangesMessage_);
session.send(this.selfRangesMessage_);
}
}
if (rangeUpdateCount > 0 && this.lastPieceShareInUpdateTime_ + 2000 < nowTime) {
this.lastPieceShareInUpdateTime_ = nowTime;
this.updateMetaPieceShareInRanges_(true);
}

return rangeUpdateCount;
},

updateMetaPieceShareInRanges_ : function(startFromUrgent) {
var startIndex = startFromUrgent ? ((this.urgentSegmentIndex_ < 0) ? 0 : this.urgentSegmentIndex_) : 0;
for ( var n = startIndex; n < this.metaData_.segments_.length; n++) {
var segment = this.metaData_.segments_[n];
if (segment.p2pDisabled_) {
continue;
}
for ( var k = 0; k < segment.pieces_.length; k++) {
var piece = segment.pieces_[k];
piece.shareInRanges_ = 0;
for ( var j = 0; j < this.otherPeers_.length; j++) {
var peer = this.otherPeers_[j];
if (peer.hasPiece_(piece.type_, piece.id_)) {
piece.shareInRanges_++;
}
}
}
}
},

getTypeName_ : function() {
return p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.type_);
},

onProtocolManagerOpen_ : function(mgr, errorCode) {
if (this.protocolPool_ == null || !this.protocolPool_.isValid_()) {
// already closed
return;
}
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::[{1}] Protocol manager({2}://{3}) open, channel({4}), code({5}), {6}",this.tag_,p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.type_), mgr.getTypeName_(), mgr.getId_(), this.id_, errorCode,(this.opened_ && p2p$.com.webp2p.core.common.ERROR_CODE.kErrorSuccess != errorCode) ? "try open after 10 seconds..." : "OK"));
// report only open successfully
if (p2p$.com.webp2p.core.common.ERROR_CODE.kErrorSuccess == errorCode) {
var url = new p2p$.com.common.Url();
var params={};
params["err"]=0;
if (!this.rtmfpServerReported_ && mgr.getType() == p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeRtmfp && this.context_.rtmfpServerConnectedTime_ > 0) {
this.rtmfpServerReported_ = true;
url.fromString_(this.context_.rtmfpServerHost_);
params["rip"]=url.host_;
params["rport"]=url.port_;
params["utime"]=this.context_.rtmfpServerConnectedTime_;
this.sendStatus_({type:"ACTION.RTMFP.CONNECTED", code:0,params:params});
}
if (!this.cdeTrackerReported_ && mgr.getType() == p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeWebSocket && this.context_.trackerServerConnectedTime_ > 0) {
this.cdeTrackerReported_ = true;
url.fromString_(this.context_.trackerServerHost_);
params["gip"]=url.host_;
params["gport"]=url.port_;
params["utime"]=this.context_.trackerServerConnectedTime_;
this.sendStatus_({type:"ACTION.SOCKET.CONNECTED", code:0,params:params});
}
if (!this.webrtcServerReported_ && mgr.getType() == p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeWebrtc && this.context_.webrtcServerConnectedTime_ > 0) {
this.webrtcServerReported_ = true;
url.fromString_(this.context_.webrtcServerHost_);
params["wrip"]=url.host_;
params["wrport"]=url.port_;
params["utime"]=this.context_.webrtcServerConnectedTime_;
this.sendStatus_({type:"ACTION.WEBRTC.CONNECTED", code:0, params:params});
}
}
},

onProtocolSessionClose_ : function(session) {
if (this.protocolPool_ == null || session == null) {
// already closed
return;
}

var erased = false;
var sameTypeCount = 0;
var peers = session.isStable_() ? this.stablePeers_ : this.otherPeers_;
for ( var n = 0; n < peers.length; n++) {
var item = peers[n];
if (item.session_ == session) {
erased = true;
this.resetPieceReceivingBySession_(item.sessionId_);
peers.splice(n--, 1);
} else {
if (item.session_ && item.session_.getType() == session.getType()) {
sameTypeCount++;
}
}
}

if (erased) {
// this.updateMetaPieceShareInRanges_(true);
if (!session.isStable_()) {
if(this.static_){
this.static_.sendTraffic_(2, session.getType(), sameTypeCount);
}
}
}
},

getActiveTime_ : function() {
return this.activeTime_;
},//

getMaxSleepTime_ : function() {
return this.maxSleepTime_;
},

getChannelUrl_ : function() {
return this.metaData_.channelUrl_;
},

getMaxSilentTime_ : function() {
return this.maxSilentTime_;
},

p2pIsReady_ : function() {
if (this.protocolPool_ != null) {
return this.protocolPool_.p2pIsReady_();
}
return false;
},

p2pisActive_ : function() {
if (this.protocolPool_ != null) {
return this.protocolPool_.p2pisActive_();
}
return false;
},

p2pDeactive_ : function() {
this.otherPeers_ = [];
if (this.protocolPool_ != null) {
return this.protocolPool_.p2pDeactive_();
}
return false;
},

p2pActivate_ : function() {
if (this.protocolPool_ != null) {
return this.protocolPool_.p2pActivate_();
}
return false;
},
//get set
getId_ : function() {
return this.id_;
},
getChannelType_ : function() {
return this.channelType_;
},

setGroupType : function(type) {
this.groupType_ = type;
},

setReopenMode : function(mode) {
this.reopenMode_ = mode;
},
setListener_ : function(listener) {
this.wrapper_ = listener;
},
onGslbExpiredError_ : function() {
var code = 30404;
var info = "GSLB has expired";
this.sendStatus_({type:"VIDEO.PLAY.ERROR",code:code,info:info});
},
sendStatus_:function(params,type)
{
if(this.static_){
this.static_.sendStatus_(params);
}
if(this.wrapper_&&!type){
this.wrapper_.sendStatus_(params);
}
},

getAllStatus_ : function(params, result) {
var simpleMode = params.get("simple");
var needGslbData = params.get("gslb");
var segmentStartWithPlayer = params.get("segmentStartWithPlayer") == "1";
var maxDuration = params.get("maxDuration");
if (segmentStartWithPlayer && maxDuration <= 0) {
maxDuration = 300; // default
}

result["id"] = this.id_;
result["type"] = this.getTypeName_();
result["opened"] = this.opened_;
result["paused"] = this.paused_;
result["groupType"] = this.groupType_;
result["redirectMode"] = this.redirectMode_;
result["directMetaMode"] = this.directMetaMode_;
result["playerHistoryKey"] = this.playerHistoryKey_;
result["icpCode"] = this.icpCode_;
result["channelUrl"] = this.metaData_.channelUrl_;
result["channelPlayUrl"] = p2p$.com.common.String.format("/play?debug={0}&mcdn={1}&enc=base64&ext=m3u8&url={2}", this.context_.debug_ ? 1
: 0, this.context_.cdnMultiRequest_ ? 1 : 0, p2p$.com.common.String.urlEncode_(p2p$.com.common.String
.base64Encode_(this.metaData_.channelUrl_)));
result["gslbEncryptUrl"] = this.gslb_.gslbRequestUrl_;
result["createTime"] = this.createTime_;
result["openTime"] = this.openTime_;
result["activeTime"] = this.activeTime_;
result["urlTagTime"] = this.urlTagTime_;
result["gslbTryTimes"] = this.gslb_.gslbTryTimes_;
result["metaTryTimes"] = this.meta_.metaTryTimes_;
result["gslbServerResponseCode"] = this.gslb_.gslbServerResponseCode_;
result["gslbServerErrorCode"] = this.gslb_.gslbServerErrorCode_;
result["gslbServerErrorDetails"] = this.gslb_.gslbServerErrorDetails_;
result["metaServerResponseCode"] = this.meta_.metaServerResponseCode_;
result["checksumServerResponseCode"] = this.checksumServerResponseCode_;
result["channelOpenedTime"] = this.channelOpenedTime_;
result["maxSleepTime"] = this.maxSleepTime_;
result["playerFlushTime"] = this.playerFlushTime_;
result["playerFlushInterval"] = this.playerFlushInterval_;
result["playerFlushMaxInterval"] = this.playerFlushMaxInterval_;
result["playerInitialPosition"] = this.playerInitialPosition_;
result["playerSkipPosition"] = this.playerSkipPosition_;
result["playerSkipDuration"] = this.playerSkipDuration_;
result["playerSegmentId"] = this.playerSegmentId_;
result["urgentSegmentId"] = this.urgentSegmentId_;
result["urgentSegmentEndId"] = this.urgentSegmentEndId_;
result["urgentIncompleteCount"] = this.urgentIncompleteCount_;
result["otherPeerRequestCount"] = this.otherPeerRequestCount_;
result["completedSegmentId"] = this.completedSegmentId_;
result["downloadedRate"] = this.statData_.urgentReceiveSpeed_;
// result["downloadedDuration"] = getDownloadedDuration();
result["downloadedDuration"] = this.statData_.downloadedDuration_;
result["mediaStartTime"] = this.mediaStartTime_;
result["metaResponseCode"] = this.metaResponseCode_;
result["metaResponseDetails"] = this.metaResponseDetails_;
result["metaResponseType"] = this.metaResponseType_;
result["peerReceiveTimeout"] = this.peerReceiveTimeout_;
result["gslbReloadInterval"] = this.gslb_.gslbReloadInterval_ * 1000;
result["gslbLoadTime"] = this.gslb_.gslbLoadTime_;
result["gslbReloadTimes"] = this.gslb_.gslbReloadTimes_;
result["gslbConsumedTime"] = this.gslb_.gslbConsumedTime_;
result["gslbTotalUseTime"] = this.gslb_.gslbTotalUseTime_;
result["checksumLoadTime"] = this.checksumLoadTime_;
result["metaLoadTime"] = this.meta_.metaLoadTime_;
result["metaReloadTimes"] = this.meta_.metaReloadTimes_;
result["selfRanges"] = this.selfRanges_;
if (needGslbData) {
result["gslbData"] = this.context_.gslbData_;
}

if (simpleMode) {
return;
}
var contextStatus = result["context"] = {};
this.context_.getAllStatus_(contextStatus);

var statDataStatus = result["statData"] = {};
this.statData_.getAllStatus_(statDataStatus);

var metaDataStatus = result["metaData"] = {};
this.metaData_.getAllStatus_(segmentStartWithPlayer ? this.urgentSegmentId_ : -1, maxDuration, params, metaDataStatus);
if(this.static_){
var reportTrafficStatus = result["reportTraffic"] = {};
this.static_.reportTraffic_.getAllStatus_(reportTrafficStatus);
}

var resultStablePeers = result["stablePeers"] = [];
for ( var n = 0; n < this.stablePeers_.length; n++) {
var peer = this.stablePeers_[n];
var stablePeersStatus = resultStablePeers[n] = {};
peer.getAllStatus_(stablePeersStatus);
}

var resultOtherPeers = result["otherPeers"] = [];
for ( var n = 0; n < this.otherPeers_.length; n++) {
var peer = this.otherPeers_[n];
var otherPeersStatus = resultOtherPeers[n] = {};
peer.getAllStatus_(otherPeersStatus);
}
}
});
/**
* Created by chenzhaofei on 2017/5/19.
*/
p2p$.ns('com.webp2p.logic.base');
p2p$.com.webp2p.logic.base.Gslb = JClass.extend_({
tag_:"com::webp2p::logic::base::Gslb",
gslbTryTimes_ : 0,
gslbServerResponseCode_ : 0,
gslbServerErrorCode_ : 0,
gslbServerErrorDetails_ : "",
gslbReloadInterval_ : 0,
gslbLoadTime_ : 0,
gslbConsumedTime_ : 0,
gslbTotalUseTime_:0,
gslbReloadTimes_ : 0,
gslbCompleteReported_ : false,
openTime_:0,
downloader_:null,
gslbRequestUrl_:null,
location_:null,
nodelist_:null,
url_:null,
config_:null,
global_:null,
timer_:null,
wrapper_:null,
data_:null,
createTime_:0,
activeTime_:0,
sn_:0,

//调度请求

init:function(wrapper,url)
{
this.wrapper_=wrapper;
this.config_ = p2p$.com.selector.Config;
this.global_ = p2p$.com.common.Global;
this.gslbTryTimes_ = 0;
this.gslbServerResponseCode_ = 0;
this.gslbServerErrorCode_ = -1;
this.gslbCompleteReported_ = false;
this.gslbReloadTimes_ = 0;
this.gslbReloadInterval_ = 0;
this.gslbConsumedTime_ = 0;
this.sn_ = -1;
this.createTime_ = this.activeTime_ = this.global_.getMilliTime_();
this.url_=url;
this.addTionalParams_();
},
start_:function()
{
if(this.url_ == null){
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}:start url is null",this.tag_));
return;
}
this.stop_();
if(this.openTime_==0){
this.openTime_ = this.global_.getMilliTime_();
}
this.sn_++;
var timeoutMs = 5000 + (this.gslbTryTimes_ * 3000); // 5 seconds
var type_="json";
if(this.config_.jsonp==1){
type_="jsonp";
timeoutMs = 1000;
}
this.setTimeout_(timeoutMs);
this.gslbRequestUrl_ = this.url_.toString();
this.downloader_ = new p2p$.com.loaders.HttpDownLoader({url_:this.gslbRequestUrl_, scope_:this,type_:type_, tag_:"base::gslb"});
this.downloader_.load_();
},
addTionalParams_:function()
{
this.url_.params_.set("appid", 800);
this.url_.params_.set("format", "1");
this.url_.params_.set("expect", "3");
this.url_.params_.set("ajax", "1");

var tss = this.url_.params_.get("tss");
var m3v = this.url_.params_.get("m3v");
if (tss != "ios") {
tss = "tvts";
}
if (!m3v || m3v == "0") {
m3v = "1";
}
// m3v = "0";
this.url_.params_.set("tss", tss);
this.url_.params_.set("m3v", m3v);
},
stop_:function()
{
if(this.downloader_ != null)
{
this.downloader_.close();
this.downloader_ = null;
}
},
onHttpDownloadCompleted_:function(downloader){
this.stop_();
this.gslbConsumedTime_ = downloader.totalUsedTime_;
this.activeTime_ = this.global_.getMilliTime_();
this.gslbTotalUseTime_ = this.activeTime_-this.openTime_;
this.gslbServerResponseCode_ = downloader.successed_ ? downloader.responseCode_ : -1;
if (!downloader.successed_ || downloader.responseCode_ < 200 || downloader.responseCode_ >= 300) {
// waiting for timeout and retry ...
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onHttpDownloadComplete_ success_({1}),responseCode({2})",this.tag_,downloader.successed_,downloader.responseCode_));
this.stopTimer_();
this.onTimeout_();
return;
}

if (!this.parseResponse_(downloader, "")) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onHttpDownloadComplete_ parseGslbResponse_->false",this.tag_));
if (52001 == this.gslbServerErrorCode_) {
// json parse failed, waiting timeout and retry
this.stopTimer_();
this.onTimeout_();
return;
}
// stop timer
this.stopTimer_();
this.wrapper_.onMetaComplete_(20501, "GSLB Response Failed " + this.gslbServerErrorCode_);
return;
}

// stop timer
this.stopTimer_();
if (!this.gslbCompleteReported_) {
this.gslbCompleteReported_ = true;
this.wrapper_.sendStatus_({type:"ACTION.SCHEDULE.COMPLETED",code:p2p$.com.webp2p.core.common.ERROR_CODE.kErrorSuccess, host:downloader.remoteEndpoint_, ut:this.activeTime_ - this.createTime_});
if (this.wrapper_.onGslbComplete_) {
this.wrapper_.onGslbComplete_();
}
}
},
parseResponse_ : function(downloader, data) {
var gslbData = downloader.responseData_;
if (gslbData == "" || gslbData == null) {
if (this.gslbServerErrorCode_ <= 0) {
gslbServerErrorCode_ = 52001;
}
return false;
}
// parse responseData
gslbData["ercode"] = 0;
gslbData["errinfo"] = "Direct Meta";

this.gslbServerErrorCode_ = gslbData.ercode;
this.gslbServerErrorDetails_ = gslbData.errinfo || "";
this.gslbLoadTime_ = this.global_.getMilliTime_();
this.gslbReloadInterval_ = gslbData.forcegslb * 1000;
// url timeout or linkshell timeout
if (this.gslbServerErrorCode_ == 424 || this.gslbServerErrorCode_ == 428) {
// sync time with server again
// this.manager_.getAuthorization().update();
}

this.wrapper_.context_.loadData_(gslbData);
// test for cdn meta timeout
this.wrapper_.manager_.getEnviroment_().attachContext_(this.wrapper_.context_);

this.wrapper_.context_.detectSpecialPlayerTimeOffset_();
this.wrapper_.metaData_.directMetaMode_ = false;

this.wrapper_.metaData_.sourceUrl_ = this.wrapper_.context_.gslbData_["location"];
var allMetaNodes = this.wrapper_.context_.gslbData_["nodelist"];
if ("" == this.wrapper_.metaData_.sourceUrl_ && allMetaNodes.length > 0) {
this.metaData_.sourceUrl_ = allMetaNodes[0]["location"];
}
if ("" == this.wrapper_.metaData_.sourceUrl_) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0} Gslb response failed, no g3 meta url location, url({1}))",this.tag_,downloader.url_));
if (this.gslbServerErrorCode_ <= 0) {
this.gslbServerErrorCode_ = 52002;
}
return false;
}

return true;
},
setTimeout_ : function(timeoutMs) {
var me = this;
this.timer_ = setTimeout(function() {
me.onTimeout_();
}, timeoutMs);
},
stopTimer_:function()
{
if (this.timer_) {
clearTimeout(this.timer_);
this.timer_ = null;
}
},
onTimeout_ : function() {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onGslbTimeout_",this.tag_));
this.stop_();
this.gslbTryTimes_++;
if (this.gslbTryTimes_ <= 2) {
this.start_();
} else {
this.wrapper_.onMetaComplete_(20500, "GSLB Request Failed", "");
}
},
updateBackupIp_ : function() {
var predefinedStrings = this.wrapper_.manager_.getEnviroment_().getBackupHostIps_();
if (!predefinedStrings) {
return;
}
// standard domain
var predefineIps = null;
predefineIps = predefinedStrings.split(",");
if (!predefineIps) {
return;
}
var seed = Math.floor(Math.random() * (100 + 1));
var randIdx = seed % predefineIps.length;
if (randIdx < 0 || randIdx >= predefineIps.length) {
randIdx = 0;
}
var retryIndex = this.gslbTryTimes_ % 4;
switch (retryIndex) {
case 1:
case 2:
this.gslbBackupIp_ = predefineIps[randIdx];
break;
default:
// try default domain at the last time
this.gslbBackupIp_ = "";
break;
}
},
});

p2p$.ns('com.webp2p.logic.base');
p2p$.com.webp2p.logic.base.Manager = JClass.extend_({
channels_ : null,
defaultMultiMode_ : false,
channelCapacity_ : 0,
downloadCapacity_ : 0,
downloadParallelCount_ : 0,
enviroment_ : null,
tag_:"com::webp2p::logic::base::Manager",

init : function(enviroment) {
this.channels_ = new p2p$.com.common.Map();
this.enviroment_ = enviroment;
this.defaultMultiMode_ = false;
this.channelCapacity_ = 3;
this.downloadCapacity_ = 1000;
this.downloadParallelCount_ = 1;
},

getEnviroment_ : function() {
return this.enviroment_;
},

openChannel_ : function(channelUrl, params, scope) {
P2P_ULOG_TRACE(P2P_ULOG_FMT("{0}::openChannel_",this.tag_));
var groupType = params.find("pip") ? params.get("pip") : 0;
var streamMode = params.find("stream") ? params.get("stream") : 0;
if (params.find("group")) {
groupType = params.get("group");
}
var urlTagTime = params.find("tagtime") ? (params.get("tagtime") * 1000 * 1000) : 0;
var channel = null;

if (this.channels_.has(channelUrl)) {
channel = this.channels_.get(channelUrl);
channel.updateActiveTime_(false);
return channel;
}

var programUrl = new p2p$.com.common.Url();
programUrl.fromString_(channelUrl);
var tagName = (programUrl.params_.find("tag")) ? programUrl.params_.get("tag") : "";
var streamId = (programUrl.params_.find("stream_id")) ? programUrl.params_.get("stream_id") : "";
var isLiveStream = (streamMode > 0) || streamId != "";

if (isLiveStream) {
channel = new p2p$.com.webp2p.logic.live.Channel(channelUrl, programUrl, this);
} else {
channel = new p2p$.com.webp2p.logic.vod.Channel(channelUrl, programUrl, this);
}
channel.setGroupType(groupType);
channel.setReopenMode(false);
channel.loadParams_(params, this.enviroment_.customContextParams_);
channel.updateActiveTime_(false);
channel.setUrlTagTime_(urlTagTime);
this.channels_.set(channelUrl, channel);
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Open new {1} channel url({2}) OK",this.tag_,tagName || "vod", channelUrl));
return channel;
},

closeChannel_ : function(channelUrl) {
for ( var n = 0; n < this.channels_.length; n++) {
var mapItem = this.channels_.element(n);
if (mapItem.key == channelUrl) {
var item = mapItem.value;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Close channel id({1}), type({2}), url({3}), total {4} channel(s) now",this.tag_,item.getId_(), item.getTypeName_(), item.getChannelUrl_(), this.channels_.size() - 1));
item.close();
this.channels_.erase(this.channels_.element(n).key);
item=null;
return true;
}
}
},

checkTimeout_ : function() {
var isMobileNow = this.enviroment_.isMobileNetwork_();
var nowTime = p2p$.com.common.Global.getMilliTime_();
for ( var n = 0; n < this.channels_.length; n++) {
var item = this.channels_.element(n).value;
if (!item.isOpened_() || !item.p2pIsReady_()) {
continue;
}
var needDeactivate = (item.getActiveTime_() + item.getMaxSilentTime_() < nowTime) || isMobileNow || item.isPaused_();
if (needDeactivate && item.p2pisActive_()) {
item.p2pDeactive_();
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Deactive slient channel, mobile network({1}), id({2}), type({3}), url({4})",this.tag_,isMobileNow ? "yes" : "no", item.getId_(), item.getTypeName_(), item.getChannelUrl_()));
} else if (!needDeactivate && !item.p2pisActive_()) {
item.p2pActivate_();
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Activate slient channel, mobile network({1}), id({2}), type({3}), url({4})",this.tag_,isMobileNow ? "yes" : "no", item.getId_(), item.getTypeName_(), item.getChannelUrl_()));
}
}
},

getChannelById_ : function(id) {
var channel = null;
for ( var n = 0; n < this.channels_.length; n++) {
var item = this.channels_.element(n).value;
if (item.getId_() == id) {
channel = item;
break;
}
}
return channel;
},
getAllStatus_ : function(params, result) {
var jsonManager = result["manager"] = {};
jsonManager["defaultMultiMode"] = this.defaultMultiMode_;
jsonManager["channelCapacity"] = this.channelCapacity_;
jsonManager["downloadCapacity"] = this.downloadCapacity_;
jsonManager["downloadParallelCount"] = this.downloadParallelCount_;
// jsonManager["authSynced"] = authorization_.synced();
// jsonManager["authSyncedSuccess"] = authorization_.syncedSuccess();
// jsonManager["authServerTimeNow"] = authorization_.serverTimeNow();
// jsonManager["authRemoteServerTime"] = authorization_.remoteServerTime();
// jsonManager["authAbsoluteCdeTime"] = authorization_.absoluteCdeTime();
// jsonManager["authLocalCdeTime"] = authorization_.localCdeTime();
// jsonManager["authTimeDiff"] = authorization_.timeDiff();
// jsonManager["playedHistoryCount"] = playedHistoryKeys_.size();

var jsonChannels = result["channels"] = [];

for ( var n = 0; n < this.channels_.length; n++) {
var channel = this.channels_.element(n).value;
var channelTemp = jsonChannels[n] = {};
channel.getAllStatus_(params, channelTemp);
}
// for( logic::base::ChannelPtrList::const_iterator itr = downloads_.begin(); itr != downloads_.end(); itr ++ )
// {
// const logic::base::ChannelPtr &channel = (*itr);
// channel->getAllStatus_(params, jsonChannels[jsonChannels.size()]);
// }
}
});
p2p$.ns('com.webp2p.logic.base');
p2p$.com.webp2p.logic.base.Meta = JClass.extend_({
tag_: "com::webp2p::logic::base::Meta",
activeTime_:0,
scope_:null,
channelType_:"vod",
metaLoadTime_ : 0,
metaUseTime_ : 0,
metaReloadTimes_ : 0,
metaResponsed_ : false,
metaServerResponseCode_ : 0,
metaCompleteReported_ : false,

liveMetaRefreshInterval_ : 0,//直播刷新时间
liveMaxSegmentStartTime_ : 0,
livePlayOffset_ : 0,
livePlayMaxTimeLength_ : 0,
liveMetaTryTimeoutTimes_ : 0,
liveTimeShift_ : 0,
livePlayerShift_ : 0,
liveCurrentTime_ : 0,
liveStartTime_ : 0,
liveAbTimeShift_ : 0,
liveNowPlayOffset_ : 0,
liveMetaLoadTime_ : 0,
liveMetaUpdateTime_ : 0,
updateLiveTimer_:null,
lastProgramChangeTime_ : 0,

timer_:null,
nodelist_:null,
sourceMetaUrl_:"",
updateMetaUrl_ : "",
config_:null,
global_:null,
strings_:null,
loaders_:[],
init:function(scope,type)
{
this.config_ = p2p$.com.selector.Config;
this.global_ = p2p$.com.common.Global;
this.strings_ = p2p$.com.common.String;
this.scope_=scope;
this.channelType_ = type;
this.liveMetaRefreshInterval_ = 5000; // ms
this.lastProgramChangeTime_ = 0;
this.livePlayOffset_ = 120; // seconds
this.livePlayMaxTimeLength_ = 200; // 200 seconds
this.liveMetaTryTimeoutTimes_ = 0;
this.liveTimeShift_ = -1;
this.livePlayerShift_ = 0;
this.liveCurrentTime_ = 0;
this.liveStartTime_ = 0;
this.liveAbTimeShift_ = 0;
this.liveNowPlayOffset_ = 0;
this.liveMetaLoadTime_ = 0;
this.liveMetaUpdateTime_ = 0;
this.liveMaxSegmentStartTime_ = 0;
this.updateLiveTimer_ = null;
this.sourceMetaUrl_="";
},
load_:function(nodelist)
{
if(nodelist != null){
this.nodelist_ = nodelist;
}
var gslbEncryptUrl_;
switch(this.channelType_){
case p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeLive:
this.setUpdateLiveMetaTimeout_(p2p$.com.webp2p.logic.live.ChannelStatic.kTimerTagMetaUpdate, this.liveMetaRefreshInterval_);
gslbEncryptUrl_ = this.getNowRequestMetaUrl_();
this.openLoader_({url_:gslbEncryptUrl_, scope_:this, tag_:"live::meta_"});
case p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeVod:
if(this.metaLoadTime_<=0){
this.metaLoadTime_ = this.global_.getMilliTime_();
}
for(var i=0;i<this.nodelist_.length&&i<this.config_.maxMetaNum;i++)
{
gslbEncryptUrl_ = this.nodelist_[i]["location"];
this.openLoader_({url_:gslbEncryptUrl_, scope_:this, tag_:"base::meta_"+i});
}
var timeoutMs = 10 * 1000;
this.setTimeout_(timeoutMs);
}
},
setLiveParams_:function()
{
var gslbData = this.scope_.context_.gslbData_;
var nowTime = this.global_.getMilliTime_();
this.liveMaxSegmentStartTime_ = 0;
this.liveTimeShift_ = gslbData["livesftime"];
if (this.liveTimeShift_ >= 0) {
// use gslb configure, max 180 seconds (livePlayMaxTimeLength_ - 20)
this.livePlayOffset_ = this.liveTimeShift_ > (this.livePlayMaxTimeLength_ - 20) ? (this.livePlayMaxTimeLength_ - 20) : this.liveTimeShift_;
}
this.livePlayMaxTimeLength_ = (this.livePlayOffset_ > 30 ? this.livePlayOffset_ : 30) + 60;
this.liveCurrentTime_ = gslbData["curtime"];
this.liveStartTime_ = gslbData["starttime"];
this.liveNowPlayOffset_ = this.livePlayOffset_;
if (this.livePlayerShift_ != 0) {
this.liveCurrentTime_ += (this.livePlayerShift_ + this.livePlayOffset_);
}
this.liveCurrentTime_ += 10;
this.liveAbTimeShift_ = this.liveCurrentTime_ - this.liveNowPlayOffset_ - 10;
this.liveMetaLoadTime_ = nowTime;
this.liveMetaUpdateTime_ = nowTime;
this.activeTime_ = this.global_.getMilliTime_();
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Detect channel({1}), time shift({2} sec), gslb reload({3} sec), current time({4}), start time({5})",this.tag_,this.id_,this.liveTimeShift_, this.gslbReloadInterval_ / 1000, p2p$.com.common.String.formatTime_(this.liveCurrentTime_),p2p$.com.common.String.formatTime_(this.liveStartTime_)));
},

openLoader_:function(params)
{
var downloader = new p2p$.com.loaders.HttpDownLoader(params);
downloader.load_();
this.loaders_.push(downloader);
},
onHttpDownloadCompleted_:function(downloader)
{
if(downloader.tag_ == "live::meta_"){
this.onLiveMetaComplete_(downloader);
return;
}
var tag_= downloader.tag_.split("_")[1];
if (downloader.successed_) {//加载成功,关闭其他m3u8的加载
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} close other loaders",this.tag_));
//通知meta加载完毕
this.onMetaCompleted_(downloader);
var loader_,index_=-1;
for(var i=0;i<this.loaders_.length;i++) {
loader_ = this.loaders_[i];
index_ = loader_.tag_.split("_")[1];
if (tag_ != index_) {
loader_.close();
}
}
}
},
onLiveMetaComplete_:function(downloader)
{
this.metaServerResponseCode_ = downloader.successed_ ? downloader.responseCode_ : -1;
this.scope_.context_.metaServerIp_ = downloader.remoteEndpoint_;
if (!downloader.successed_ || downloader.responseCode_ < 200 || downloader.responseCode_ >= 300) {
// failed
this.scope_.onSchedule_(false);
this.switchNextMetaSource_();
return;
}
if (!this.parseUpdateMetaResponse_(downloader)) {
this.switchNextMetaSource_();
return;
}
this.metaReloadTimes_++;
this.activeTime_ = this.global_.getMilliTime_();
this.metaUseTime_ = this.activeTime_-this.metaLoadTime_;
},
onMetaCompleted_:function(downloader)
{
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onMetaComplete_",this.tag_));
var handled = true;
this.activeTime_ = this.global_.getMilliTime_();
this.metaServerResponseCode_ = downloader.successed_ ? downloader.responseCode_ : -1;
// stop timer
this.stopTimer_();
this.scope_.metaData_.finalUrl_ = downloader.url_;
this.scope_.metaData_.lastReceiveSpeed_ = downloader.transferedSpeed_;
if (!this.parseMetaResponse_(downloader)) {
this.scope_.onMetaComplete_(20601, "Meta Response Failed", "");
return;
}
this.metaReloadTimes_++;
this.metaUseTime_ = this.activeTime_-this.metaLoadTime_;
this.scope_.context_.videoFormat_ = this.scope_.metaData_.p2pGroupId_ == "" ? "m3u8" : "lm3u8";
if (this.scope_.metaData_.p2pGroupId_ == "") {
// standard hls redirect
this.onMetaCompleteCode_ = 302;
this.scope_.onMetaComplete_(302, "Moved", this.scope_.metaData_.sourceUrl_);
return;
}
if (!this.metaCompleteReported_) {
this.metaCompleteReported_ = true;
}
this.scope_.onMetaComplete_(200, "OK", this.scope_.metaData_.getLocalMetaContent_());
},
parseMetaResponse_ : function(downloader) {
var metaTypeName = p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.scope_.type_);
if (!this.scope_.metaData_.load(downloader.responseData_, downloader.totalUsedTime_, true)) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0} [{1}]Parse hls meta response failed, url({2}), channel({3}), size({4})",this.tag_,metaTypeName,downloader.url_,this.id_,downloader.responseData_.length));
return false;
}
return true;
},
parseUpdateMetaResponse_ : function(downloader) {
var metaChanged = false;
var p2pGroupIdChanged = false;
var nowTime = this.global_.getMilliTime_();
var updateMeta = new p2p$.com.webp2p.core.supernode.MetaData();
updateMeta.type_ = this.scope_.metaData_.type_;
updateMeta.rangeParamsSupported_ = this.scope_.metaData_.rangeParamsSupported_;
updateMeta.verifyMethod_ = this.scope_.metaData_.verifyMethod_;
updateMeta.sourceUrl_ = downloader.url_;
updateMeta.finalUrl_ = downloader.url_;
updateMeta.channelUrl_ = this.scope_.metaData_.channelUrl_;
updateMeta.storageId_ = this.scope_.metaData_.storageId_;
if (!updateMeta.load(downloader.responseData_, downloader.totalUsedTime_)) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::parseUpdateMetaResponse_ Parse meta response failed, url({1}), channel({2}), size({3})"),this.tag_,downloader.url_,this.id_,this.downloader_.responseData_.length);
this.metaServerResponseCode_ = 701; // content error
this.scope_.onSchedule_(false);
return false;
}

if (updateMeta.p2pGroupId_ != this.scope_.metaData_.p2pGroupId_) {//gid发生变化
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::parseUpdateMetaResponse_ Meta group id change from({1}) to({2}), reopen p2p protocols...",this.tag_,this.scope_.metaData_.p2pGroupId_,updateMeta.p2pGroupId_));
if (this.lastProgramChangeTime_ <= 0) {
this.lastProgramChangeTime_ = this.global_.getMilliTime_();
var retval = {
newSegmentCount_ : 0,
newSegments_ : []
};
retval = this.scope_.metaData_.combineSameGroup_(updateMeta);
if (retval.newSegmentCount_ > 0) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Add2 ({1}) new meta segment({2}) to channel({3}), total {4} segment(s) now",this.tag_,retval.newSegmentCount_, retval.newSegments_.join(','), this.scope_.id_, this.scope_.metaData_.segments_.length));
}
}
if (this.lastProgramChangeTime_ + (120 * 1000) > nowTime) {
// check if all segments are completed
var allSegmentsCompleted = true;
for ( var k = 0; k < this.scope_.metaData_.segments_.length; k++) {
var segment = this.scope_.metaData_.segments_[k];
if (segment.id_ < this.scope_.urgentSegmentId_) {
continue;
}
if (segment.completedTime_ <= 0) {
allSegmentsCompleted = false;
break;
}
}
if (!allSegmentsCompleted) {
// wait for next time
this.scope_.onSchedule_(false);
return true;
}
}
metaChanged = true;
p2pGroupIdChanged = true;
this.scope_.metaData_.p2pGroupId_ = updateMeta.p2pGroupId_;
this.scope_.metaData_.markAllSegmentP2pDisabled_();
var retval = {
newSegmentCount_ : 0,
newSegments_ : []
};
retval = this.scope_.metaData_.combineWith_(updateMeta, false, true);
if (retval.newSegmentCount_ <= 0) {
// rebuild segment and piece indexes while all p2p segments disabled
this.scope_.metaData_.buildIndexes_();
}
if (retval.newSegmentCount_ > 0) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Add3 ({1}) new meta segment({2}) to channel({3}), total {4} segment(s) now",this.tag_,retval.newSegmentCount_, retval.newSegments_.join(','), this.scope_.id_, this.scope_.metaData_.segments_.length));
}
// update self range cache
this.scope_.fillSelfPieceRanges_(this.scope_.selfRangesMessage_);

} else {
// {newSegmentCount_:newSegmentCount,newSegments_:newSegments};
var retval = this.scope_.metaData_.combineWith_(updateMeta, false, false);
if (retval.newSegmentCount_ > 0) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Add4 ({1}) new meta segment({2}) to channel({3}), total {4} segment(s) now",this.tag_,retval.newSegmentCount_, retval.newSegments_.join(','), this.scope_.id_, this.scope_.metaData_.segments_.length));
metaChanged = true;
}
}

this.scope_.metaData_.updateTime_ = nowTime;
if (metaChanged) {
this.scope_.removeExpiredSegments_();
this.scope_.updateMetaPieceShareInRanges_(true);
this.scope_.metaResponseBody_ = this.scope_.metaData_.localMetaContent_;
}

this.lastProgramChangeTime_ = 0;
this.liveMaxSegmentStartTime_ = 0;
for ( var k = 0; k < this.scope_.metaData_.segments_.length; k++) {
var segment = this.scope_.metaData_.segments_[k];
this.liveMaxSegmentStartTime_ = this.liveMaxSegmentStartTime_ > segment.startTime_ ? this.liveMaxSegmentStartTime_ : segment.startTime_;
}
this.scope_.onSchedule_(false);
return true;
},
switchNextMetaSource_ : function() {
this.liveMetaTryTimeoutTimes_++;
var bak = this.sourceMetaUrl_;
var allMetaNodes = this.nodelist_;
for ( var n = 0; n < allMetaNodes.length; n++) {
var metaItem = allMetaNodes[(n + this.liveMetaTryTimeoutTimes_) % allMetaNodes.length];
var locationUrl = metaItem["location"];
if (!(locationUrl == "") && locationUrl != this.scope_.metaData_.sourceUrl_) {
this.sourceMetaUrl_ = locationUrl;
break;
}
}

var url = new p2p$.com.common.Url();
url.fromString_(this.sourceMetaUrl_);
this.scope_.context_.metaServerIp_ = this.strings_.format("{0}:{1}", url.host_, (url.port_) == 0 ? 80 : url.port_);
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::switchNextMetaSource_ [{1}]Meta timeout/error for url({2}), channel({3}), {4} try times, switch next source({4})...",this.tag_,p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.type_), bak, this.scope_.id_, this.liveMetaTryTimeoutTimes_, this.sourceMetaUrl_));
},
updateMeta_ : function() {
var nowTime = this.global_.getMilliTime_();
if (this.liveNowPlayOffset_ > 0) {
if (this.liveNowPlayOffset_ > this.liveTimeShift_) {
this.liveNowPlayOffset_ -= this.liveTimeShift_;
} else {
this.liveNowPlayOffset_ = 0;
}
}
this.liveAbTimeShift_ = this.liveMaxSegmentStartTime_ / 1000;
if (this.liveAbTimeShift_ <= 0) {
this.liveAbTimeShift_ = this.liveCurrentTime_ - this.liveTimeShift_;
}
this.liveMetaUpdateTime_ = nowTime;
this.load_();
},
setTimeout_:function(timeoutMs)
{
var me = this;
this.timer_ = setTimeout(function() {
me.onMetaTimeout_();
}, timeoutMs);
},
onMetaTimeout_:function()
{
this.close_();
this.scope_.onMetaComplete_(20600, "Meta Request Failed", "");
},
stopTimer_:function()
{
if (this.timer_) {
clearTimeout(this.timer_);
this.timer_ = null;
}
},
setUpdateLiveMetaTimeout_ : function(tag, timeoutMs) {
var me = this;
this.updateLiveTimer_ = setTimeout(function() {
me.onUpdateLiveMetaTimeout_(tag);
}, timeoutMs);
},

stopUpdateLiveMetaTimer_ : function() {
if (this.updateLiveTimer_) {
clearTimeout(this.updateLiveTimer_);
this.updateLiveTimer_ = null;
}
},
onUpdateLiveMetaTimeout_ : function(tag) {
switch (tag) {
case p2p$.com.webp2p.logic.live.ChannelStatic.kTimerTagMetaUpdate:
this.close_();
this.switchNextMetaSource_();
this.updateMeta_();
break;
default:
break;
}
},
getNowRequestMetaUrl_ : function() {
var url = this.sourceMetaUrl_ == "" ? this.scope_.metaData_.sourceUrl_ : this.sourceMetaUrl_;
var time = this.global_.getMilliTime_();
url += (url.indexOf('?') < 0) ? "?" : "&";
if (this.livePlayerShift_ == 0) {
// auto delay
url += p2p$.com.common.String.format("abtimeshift={0}&cdernd={1}", this.liveAbTimeShift_, time);
} else if (url.indexOf("&timeshift=") < 0 && url.indexOf("?timeshift=") < 0) {
// shift time not found, repair it
url += p2p$.com.common.String.format("timeshift={0}&cdernd={1}", this.livePlayerShift_, time);
} else {
url += p2p$.com.common.String.format("cdernd={0}", time);
}

return url;
},
close_:function()
{
for(var i=0;i<this.loaders_.length;i++)
{
loader_ = this.loaders_[i];
loader_.close();
}
this.loaders_=[];
this.stopUpdateLiveMetaTimer_();
this.stopTimer_();
}
});
p2p$.ns('com.webp2p.logic.base');
p2p$.com.webp2p.logic.base.PeerStatic = {
nextSessionId_ : 0,
};
p2p$.com.webp2p.logic.base.Peer = JClass.extend_({

session_ : null,
tnPieceMark_ : null,
pnPieceMark_ : null,
tnPieceInvalid_ : null,
pnPieceInvalid_ : null,

activeTime_ : 0,
lastTimeoutTime_ : 0,
totalSendBytes_ : 0,
totalSendPieces_ : 0,
totalReceiveBytes_ : 0,
totalReceivePieces_ : 0,
totalSendSpeed_ : 0,
totalReceiveSpeed_ : 0,
totalChecksumErrors_ : 0,
totalInvalidErrors_ : 0,
lastSendTime_ : 0,
lastReceiveTime_ : 0,
lastSendSpeed_ : 0,
lastReceiveSpeed_ : 0,

totalSendRanges_ : 0,
totalSendRequests_ : 0,
totalSendResponses_ : 0,
totalReceiveRanges_ : 0,
totalReceiveRequests_ : 0,
totalReceiveResponses_ : 0,
lastSendStartBytes_ : 0,
lastReceiveStartBytes_ : 0,
lastReceiveStartTime_ : 0,
lastRangeExchangeTime_ : 0,

sessionId_ : 0,
lastSegmentId_ : 0,
maxQuotaPieces_ : 0,
timeoutTimes_ : 0,
praisedTimes_ : 0,
pendingRequestCount_ : 0,
scheduleLocked_ : false,
receivePiece_ : null,
streamMark_ : 0,
streamAvaiable_ : false,
streamDetected_ : false,
streamUploading_ : false,
selfRanges_ : "",

init : function() {
this.sessionId_ = ++p2p$.com.webp2p.logic.base.PeerStatic.nextSessionId_;
if (this.sessionId_ <= 0) {
this.sessionId_ = p2p$.com.webp2p.logic.base.PeerStatic.nextSessionId_ = 1;
}
this.receivePiece_ = new p2p$.com.webp2p.core.supernode.MetaPiece();
this.activeTime_ = 0;
this.lastTimeoutTime_ = 0;
this.totalSendBytes_ = 0;
this.totalSendPieces_ = 0;
this.totalReceiveBytes_ = 0;
this.totalReceivePieces_ = 0;
this.totalSendSpeed_ = 0;
this.totalReceiveSpeed_ = 0;
this.totalChecksumErrors_ = 0;
this.totalInvalidErrors_ = 0;
this.lastSendTime_ = 0;
this.lastReceiveTime_ = 0;
this.lastSendSpeed_ = 0;// used by peer upload schedule
this.lastReceiveSpeed_ = -1;
this.lastSegmentId_ = -1;
this.maxQuotaPieces_ = 2;
this.timeoutTimes_ = 0;
this.praisedTimes_ = 0;
this.pendingRequestCount_ = 0;

this.totalSendRanges_ = 0;
this.totalSendRequests_ = 0;
this.totalSendResponses_ = 0;
this.totalReceiveRanges_ = 0;
this.totalReceiveRequests_ = 0;
this.totalReceiveResponses_ = 0;

this.lastSendStartBytes_ = 0;
this.lastReceiveStartBytes_ = 0;
this.lastReceiveStartTime_ = 0;
this.lastRangeExchangeTime_ = 0;
this.scheduleLocked_ = false;

this.streamMark_ = -1;
this.streamDetected_ = false;
this.streamAvaiable_ = false;
this.streamUploading_ = false;
this.tnPieceMark_ = new p2p$.com.webp2p.core.supernode.Bitmap();
this.pnPieceMark_ = new p2p$.com.webp2p.core.supernode.Bitmap();
this.tnPieceInvalid_ = new p2p$.com.webp2p.core.supernode.Bitmap();
this.pnPieceInvalid_ = new p2p$.com.webp2p.core.supernode.Bitmap();
this.selfRanges_ = "";
},

hasPiece_ : function(type, id) {
var bitmap = (type == p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn) ? this.tnPieceMark_ : this.pnPieceMark_;
var invalid = (type == p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn) ? this.tnPieceInvalid_ : this.pnPieceInvalid_;

if (invalid.getValue(id)) {
// already invalid
return false;
}
return bitmap.getValue(id);
},

setPieceMark_ : function(type, id, on) {
var mark = (type == p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn) ? this.tnPieceMark_ : this.pnPieceMark_;
mark.setValue(id, on);
},

setPieceInvalid_ : function(type, id, on) {
var invalid = (type == p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn) ? this.tnPieceInvalid_ : this.pnPieceInvalid_;
invalid.setValue(id, on);
},

updateSpeed_ : function(nowTime) {
var speed = this.session_.getUpdateReceiveSpeed_(nowTime, this.pendingRequestCount_ > 0);
if (speed >= 0) {
this.lastReceiveSpeed_ = speed;
}
},

statSendMessage_ : function(message) {
this.totalSendRanges_ += (message.ranges_.length == 0 ? 0 : 1);
this.totalSendRequests_ += message.requests_.length;
this.totalSendResponses_ += message.responses_.length;
},

statSendData_ : function(pieces, bytes) {
this.lastSendStartBytes_ = this.totalSendBytes_;
this.totalSendBytes_ += bytes;
this.totalSendPieces_ += pieces;
this.lastSendTime_ = p2p$.com.common.Global.getMilliTime_();
},
statReceiveBegin_ : function() {
this.lastReceiveStartBytes_ = this.totalReceiveBytes_;
this.lastReceiveStartTime_ = p2p$.com.common.Global.getMilliTime_();
},

statReceiveEnd_ : function() {
this.lastReceiveStartTime_ = 0;
},

statReceiveMessage_ : function(message) {
this.totalReceiveRanges_ += message.ranges_.length;
this.totalReceiveRequests_ += message.requests_.length;
this.totalReceiveResponses_ += message.responses_.length;
},

statReceiveData_ : function(pieces, bytes) {
this.totalReceivePieces_ += pieces;
this.statReceiveData2_(bytes);
},

statReceiveData2_ : function(bytes) {
var nowTime = p2p$.com.common.Global.getMilliTime_();

this.totalReceiveBytes_ += bytes;
this.lastReceiveTime_ = nowTime;
if (this.lastReceiveStartTime_ > 0 && nowTime > this.lastReceiveStartTime_) {
var sizeDiff = this.totalReceiveBytes_ - this.lastReceiveStartBytes_;
this.lastReceiveSpeed_ = sizeDiff * 1000 / (nowTime - this.lastReceiveStartTime_);
}
},
getAllStatus_ : function(result) {
result["name"] = this.session_.getName_();
result["type"] = this.session_.getManager_().getTypeName_();
result["remoteId"] = this.session_.getRemoteId_();
result["remoteAddress"] = this.session_.getRemoteAddress_();
result["remoteType"] = this.session_.getRemoteType_();
result["lastReceiveSpeed"] = this.lastReceiveSpeed_;
result["lastReceiveTime"] = this.lastReceiveTime_;
result["lastSendTime"] = this.lastSendTime_;
result["pendingRequestCount"] = this.pendingRequestCount_;
result["totalReceiveBytes"] = this.totalReceiveBytes_;
result["totalReceivePieces"] = this.totalReceivePieces_;
result["totalSendBytes"] = this.totalSendBytes_;
result["totalSendPieces"] = this.totalSendPieces_;
result["totalChecksumErrors"] = this.totalChecksumErrors_;
result["totalInvalidErrors"] = this.totalInvalidErrors_;
result["totalSendRanges"] = this.totalSendRanges_;
result["totalSendRequests"] = this.totalSendRequests_;
result["totalSendResponses"] = this.totalSendResponses_;
result["totalReceiveRanges"] = this.totalReceiveRanges_;
result["totalReceiveRequests"] = this.totalReceiveRequests_;
result["totalReceiveResponses"] = this.totalReceiveResponses_;
result["selfRanges"] = this.selfRanges_;
}
});
p2p$.ns('com.webp2p.logic.base');

p2p$.com.webp2p.logic.base.StatData = JClass.extend_({
totalSendPieces_ : 0,
totalSendBytes_ : 0,
totalReceivePieces_ : 0,
totalReceiveBytes_ : 0,
actualSendPieces_ : 0,
actualSendBytes_ : 0,
actualReceivePieces_ : 0,
actualReceiveBytes_ : 0,
urgentReceiveBytes_ : 0,
lastReceiveBytes_ : 0,

firstSendTime_ : 0,
firstReceiveTime_ : 0,
urgentReceiveBeginTime_ : 0,
lastReceiveBeginTime_ : 0,

avgSendSpeed_ : 0,
avgReceiveSpeed_ : 0,
urgentReceiveSpeed_ : 0,
lastReceiveSpeed_ : 0,
restrictedSendSpeed_ : 0,

protocolSendPieces_ : null,
protocolSendBytes_ : null,
protocolSendSpeeds_ : null,
protocolReceivePieces_ : null,
protocolReceiveBytes_ : null,
protocolReceiveSpeeds_ : null,

shareSendRatio_ : 0,
shareReceiveRatio_ : 0,
firstPieceFetchTime_ : 0,

totalReceiveDuration_ : 0,
downloadedDuration_ : 0,
totalPlayedBytes_ : 0,
totalPlayedPieces_ : 0,
totalPlayedDuration_ : 0,

init : function() {
this.totalSendPieces_ = 0;
this.totalSendBytes_ = 0;
this.actualSendPieces_ = 0;
this.actualSendBytes_ = 0;
this.totalReceivePieces_ = 0;
this.totalReceiveBytes_ = 0;
this.actualReceivePieces_ = 0;
this.actualReceiveBytes_ = 0;
this.urgentReceiveBytes_ = 0;
this.lastReceiveBytes_ = 0;

this.firstSendTime_ = 0;
this.firstReceiveTime_ = 0;
this.urgentReceiveBeginTime_ = 0;
this.lastReceiveBeginTime_ = 0;

this.avgSendSpeed_ = 0;
this.avgReceiveSpeed_ = 0;
this.urgentReceiveSpeed_ = 0;
this.lastReceiveSpeed_ = 0;
this.restrictedSendSpeed_ = 0;

this.protocolSendPieces_ = [];
this.protocolSendBytes_ = [];
this.protocolSendSpeeds_ = [];
this.protocolReceivePieces_ = [];
this.protocolReceiveBytes_ = [];
this.protocolReceiveSpeeds_ = [];
for ( var n = 0; n < p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeMax; n++) {
this.protocolSendPieces_[n] = 0;
this.protocolSendBytes_[n] = 0;
this.protocolSendSpeeds_[n] = 0;
this.protocolReceivePieces_[n] = 0;
this.protocolReceiveBytes_[n] = 0;
this.protocolReceiveSpeeds_[n] = 0;
}
this.shareSendRatio_ = 0;
this.shareReceiveRatio_ = 0;
this.firstPieceFetchTime_ = 0;

this.totalReceiveDuration_ = 0;
this.downloadedDuration_ = 0;
this.totalPlayedBytes_ = 0;
this.totalPlayedPieces_ = 0;
this.totalPlayedDuration_ = 0;
},

addSendData_ : function(protocolType, pieces, bytes) {
this.addSendData2_(protocolType, bytes, pieces);
this.statSendData_();
},

addSendData2_ : function(protocolType, bytes, pieces) {
if (protocolType < 0 || protocolType >= p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeMax) {
return;
}

this.totalSendPieces_ += pieces;
this.totalSendBytes_ += bytes;
this.actualSendPieces_ += pieces;
this.actualSendBytes_ += bytes;
this.protocolSendPieces_[protocolType] += pieces;
this.protocolSendBytes_[protocolType] += bytes;
},

statSendData_ : function() {
if (this.totalReceiveBytes_ > 0) {
this.shareSendRatio_ = this.totalSendBytes_ / this.totalReceiveBytes_;
}

var nowTime = p2p$.com.common.Global.getMilliTime_();
if (this.firstSendTime_ > 0 && nowTime > this.firstSendTime_) {
var timeEclipse = nowTime - this.firstSendTime_;
this.avgSendSpeed_ = this.actualSendPieces_ * 1000 / timeEclipse;
} else {
this.firstSendTime_ = nowTime;
}
},

addReceiveData_ : function(urgent, protocolType, pieces, bytes) {
this.addReceiveData2_(protocolType, bytes, pieces);
if (urgent) {
this.urgentReceiveBytes_ += bytes;
}

this.statReceiveData_(urgent);
},

addReceiveData2_ : function(protocolType, bytes, pieces) {
if (protocolType < 0 || protocolType >= p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeMax) {
return;
}

this.totalReceivePieces_ += pieces;
this.totalReceiveBytes_ += bytes;
this.actualReceivePieces_ += bytes;
this.actualReceiveBytes_ += bytes;
this.protocolReceivePieces_[protocolType] += pieces;
this.protocolReceiveBytes_[protocolType] += bytes;

this.lastReceiveBytes_ += bytes;
},

statReceiveData_ : function(urgent) {
if (this.totalReceiveBytes_ > 0) {
var p2pReceiveBytes = this.totalReceiveBytes_ - this.protocolReceiveBytes_[p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeCdn];
this.shareSendRatio_ = this.totalSendBytes_ / this.totalReceiveBytes_;
this.shareReceiveRatio_ = p2pReceiveBytes / this.totalReceiveBytes_;
}

var nowTime = p2p$.com.common.Global.getMilliTime_();
if (this.firstReceiveTime_ > 0 && nowTime > this.firstReceiveTime_) {
var timeEclipse = nowTime - this.firstReceiveTime_;
this.avgReceiveSpeed_ = this.actualReceiveBytes_ * 1000 / timeEclipse;
} else {
this.firstReceiveTime_ = nowTime;
}

if (this.lastReceiveBeginTime_ > 0 && nowTime > this.lastReceiveBeginTime_) {
var timeEclipse = nowTime - this.lastReceiveBeginTime_;
this.lastReceiveSpeed_ = this.lastReceiveBytes_ * 1000 / timeEclipse;
if (timeEclipse > 5 * 1000) {
// reset
this.lastReceiveBeginTime_ = nowTime;
this.lastReceiveBytes_ = 0;
}
} else {
this.lastReceiveBeginTime_ = nowTime;
}

if (urgent) {
if (this.urgentReceiveBeginTime_ > 0 && nowTime > this.urgentReceiveBeginTime_) {
var timeEclipse = nowTime - this.urgentReceiveBeginTime_;
this.urgentReceiveSpeed_ = this.urgentReceiveBytes_ * 1000 / timeEclipse;
if (timeEclipse > 5 * 1000) {
// reset
this.urgentReceiveBeginTime_ = nowTime;
this.urgentReceiveBytes_ = 0;
}
} else {
this.urgentReceiveBeginTime_ = nowTime;
}
}
},
getAllStatus_ : function(result) {
result["totalSendPieces"] = this.totalSendPieces_;
result["totalSendBytes"] = this.totalSendBytes_;
result["actualSendPieces"] = this.actualSendPieces_;
result["actualSendBytes"] = this.actualSendBytes_;
result["totalReceivePieces"] = this.totalReceivePieces_;
result["totalReceiveBytes"] = this.totalReceiveBytes_;
result["actualReceivePieces"] = this.actualReceivePieces_;
result["actualReceiveBytes"] = this.actualReceiveBytes_;
result["urgentReceiveBytes"] = this.urgentReceiveBytes_;
result["lastReceiveBytes"] = this.lastReceiveBytes_;

result["shareSendRatio"] = this.shareSendRatio_;
result["shareReceiveRatio"] = this.shareReceiveRatio_;

result["avgSendSpeed"] = this.avgSendSpeed_;
result["avgReceiveSpeed"] = this.avgReceiveSpeed_;
result["urgentReceiveSpeed"] = this.urgentReceiveSpeed_;
result["lastReceiveSpeed"] = this.lastReceiveSpeed_;
result["restrictedSendSpeed"] = this.restrictedSendSpeed_;

result["totalReceiveDuration"] = this.totalReceiveDuration_;
result["downloadedDuration"] = this.downloadedDuration_;
result["totalPlayedBytes"] = this.totalPlayedBytes_;
result["totalPlayedPieces"] = this.totalPlayedPieces_;
result["totalPlayedDuration"] = this.totalPlayedDuration_;

var protocolValues = result["protocols"] = [];
var ptypes = p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES;
for ( var type = ptypes.kProtocolTypeReserved + 1; type < ptypes.kProtocolTypeMax; type++) {
var protocolItem = protocolValues[type] = {};
protocolItem["totalSendPieces"] = this.protocolReceivePieces_[type];
protocolItem["totalSendBytes"] = this.protocolSendBytes_[type];
protocolItem["totalReceivePieces"] = this.protocolReceivePieces_[type];
protocolItem["totalReceiveBytes"] = this.protocolReceiveBytes_[type];
protocolItem["shareSendRatio"] = this.protocolReceiveBytes_[type] > 0 ? (this.protocolSendBytes_[type] / this.protocolReceiveBytes_[type]) : 0;
protocolItem["shareReceiveRatio"] = this.totalReceiveBytes_ > 0 ? (this.protocolReceiveBytes_[type] / this.totalReceiveBytes_) : 0;
}
}
});
p2p$.ns('com.webp2p.logic.live');

p2p$.com.webp2p.logic.live.ChannelStatic = {
kTimerTagMetaUpdate : 0,
};

p2p$.com.webp2p.logic.live.Channel = p2p$.com.webp2p.logic.base.Channel.extend_({
channelType_ : "liv",
playLastSegmentCount_ : 0,
lastFetchEndSegmentId_ : 0,
liveFirstUrgentUpdated_ : false,
liveSkipSegmentTime_ : 0,
liveStreamId_ : "",
backupMetaData_ : null,
// boost::asio::deadline_timer liveTimer_;

init : function(channelUrl, decodedUrl, mgr) {
this._super(p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeLive, channelUrl, decodedUrl, mgr);
this.tag_ = "com::webp2p::logic::live::Channel";
this.context_.playType_ = "liv";
this.maxSleepTime_ = 60 * 1000;
this.lastFetchEndSegmentId_ = 0;
this.liveFirstUrgentUpdated_ = false;
this.liveSkipSegmentTime_ = 0;
},

getChannelType_ : function() {
return this.channelType_;
},

open : function() {
this._super();
if (this.manager_.getEnviroment_().livePlayOffset_ > 0) {
this.meta_.livePlayOffset_ = this.manager_.getEnviroment_().livePlayOffset_;
}
this.liveStreamId_ = this.url_.params_.get("stream_id");
this.playerHistoryKey_ = "live:" + this.liveStreamId_;
// this.updateUrlParams(false);
this.gslb_.url_.params_.set("mslice", 5);
var timeshift = this.gslb_.url_.params_.get("timeshift");
if (timeshift != null) {
this.meta_.livePlayerShift_ = this.strings_.parseNumber_(timeshift.value, 0);
if (this.meta_.livePlayerShift_ == 0) {
this.gslb_.url_.params_.erase(timeshift.key);
}
}
this.gslb_.start_();
return true;
},
close : function() {
this._super();
return true;
},
// override logic::base::Channel
onOpened_ : function() {

var minSegmentTime = -1;
for ( var n = 0; n < this.metaData_.segments_.length; n++) {
var segment = this.metaData_.segments_[n];
this.meta_.liveMaxSegmentStartTime_ = Math.max(this.meta_.liveMaxSegmentStartTime_, segment.startTime_);
if (minSegmentTime < 0 || minSegmentTime > segment.startTime_) {
minSegmentTime = segment.startTime_;
}
}
if (this.gslb_.gslbReloadTimes_ <= 0 && (minSegmentTime / 1000) > this.meta_.liveAbTimeShift_) {
// fixed abtimeshift
this.meta_.liveCurrentTime_ += (minSegmentTime / 1000 - this.meta_.liveAbTimeShift_);
}

var p2pGroupIdChanged = false;
if (this.gslb_.gslbReloadTimes_ > 0) {
var newSegment = {
newSegmentCount_ : 0,
newSegments_ : []
};
if (this.backupMetaData_ && this.backupMetaData_.p2pGroupId_ == this.metaData_.p2pGroupId_) {
p2pGroupIdChanged = false;
newSegment = this.metaData_.combineWith_(this.backupMetaData_, true, false);
} else {
p2pGroupIdChanged = true;
}
this.backupMetaData_.tidy();
this.meta_.liveMaxSegmentStartTime_ = 0;
for ( var k = 0; k < this.metaData_.segments_.length; k++) {
var segment = this.metaData_.segments_[k];
this.meta_.liveMaxSegmentStartTime_ = Math.max(this.meta_.liveMaxSegmentStartTime_, segment.startTime_);
}

P2P_ULOG_TRACE(P2P_ULOG_FMT("{0}::Add {1} backup meta segment(s) to reloaded channel({2}), total {3} segment(s) now",this.tag_,newSegment.newSegmentCount_, this.id_, this.metaData_.segments_.length));
}

this.stablePeers_ = [];
this.otherPeers_ = [];
if (this.protocolPool_ != null && !this.protocolPool_.initialize_()) {
return false;
}
return true;
},
onGslbComplete_:function()
{
this.meta_.setLiveParams_();
this._super();
},

removeExpiredSegments_ : function() {
var validDuration = 0;
var validSegmentCount = 0;
var endIndex = this.metaData_.segments_.length;
for (; endIndex != -1; endIndex--) {
if (endIndex == this.metaData_.segments_.length) {
continue;
}

var segment = this.metaData_.segments_[endIndex];
validDuration += segment.duration_;
validSegmentCount++;
if (validDuration >= (this.livePlayMaxTimeLength_) * 1000) {
break;
}
}
if (endIndex > 0) {
var expiredSegmentCount = this.metaData_.segments_.length - validSegmentCount;
var expiredSegmentNames = "";
var bucket = this.getStorageBucket_();
for ( var n = 0; n < endIndex; n++) {
var segment = this.metaData_.segments_[n];
var objectId = this.metaData_.getSegmentStorageId_(segment.id_);
if (n == endIndex - 1) {
expiredSegmentNames += segment.id_;
} else {
expiredSegmentNames += (segment.id_ + ",");
}
bucket.remove(objectId);
}
for ( var n = 0; n < endIndex; n++) {
var segment = this.metaData_.segments_[n];
this.metaData_.p2pPieceCount_ -= segment.pieces_.length;
}
this.metaData_.segments_.splice(0, endIndex);
P2P_ULOG_TRACE(P2P_ULOG_FMT("{0} Remove {1} ({2}) expired meta segment(s) from channel({3}), total {4} segment(s) now",this.tag_,expiredSegmentCount, expiredSegmentNames, this.id_, this.metaData_.segments_.length));

if (expiredSegmentCount > 0) {
this.fillSelfPieceRanges_(this.selfRangesMessage_);
this.metaData_.buildIndexes_();
}
}
},

onSchedule_ : function(shareMode) {
var nowTime = this.global_.getMilliTime_();
if (this.paused_) {
return;
}
// P2P_ULOG_TRACE(P2P_ULOG_FMT("logic::live::Channel", "Schedule %s for channel(%s) ..."), shareMode ? "share only" : "multi mode", id_.c_str());
this.lastScheduleTime_ = nowTime;
this.updatePeersSpeed_(nowTime, this.stablePeers_);

// check pieces to download
var totalDuration = 0;
var maxDuration = this.context_.p2pUrgentSize_ * 1000;
this.urgentSegmentIndex_ = -1;
for ( var n = 0; (this.urgentSegmentId_ >= 0) && (n < this.metaData_.segments_.length); n++) {
var segment = this.metaData_.segments_[n];
if (segment.id_ == this.urgentSegmentId_) {
// find urgent segment index
this.urgentSegmentIndex_ = n;
this.context_.playingPosition_ = segment.startTime_ / 1000;
}
if (n >= this.urgentSegmentIndex_) {
if (totalDuration < maxDuration || this.urgentSegmentEndId_ <= this.urgentSegmentId_) {
// urgent should has 2 segments at least if more segments eixst
this.urgentSegmentEndId_ = segment.id_;
}
totalDuration += segment.duration_;
}
}

if (this.urgentSegmentIndex_ < 0 && this.metaData_.segments_.length > 0) {
this.urgentSegmentIndex_ = 0;
}
this.updateUrgentIncompleteCount_();
if (!shareMode) {
this.checkTimeoutPieces_(nowTime);
this.checkTimeoutPeers_(nowTime);
this.checkPeerPieceRanges_(nowTime);

this.lastPeerSortTime_ = nowTime;
this.stablePeers_.sort(function(item1, item2) {
if (item1.lastReceiveSpeed_ == item2.lastReceiveSpeed_) {
return item1.lastTimeoutTime_ - item2.lastTimeoutTime_;
}
return item2.lastReceiveSpeed_ - item1.lastReceiveSpeed_;
});
this.otherPeers_.sort(function(item1, item2) {
if (item1.lastReceiveSpeed_ == item2.lastReceiveSpeed_) {
return item1.lastTimeoutTime_ - item2.lastTimeoutTime_;
}
return item2.lastReceiveSpeed_ - item1.lastReceiveSpeed_;
});
this.statData_.addReceiveData_(true, p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeCdn, 0, 0); // flush speed
// updateStatSyncSpeeds_();
}

this.metaData_.urgentSegmentId_ = this.urgentSegmentId_;
if (this.urgentSegmentIndex_ < 0) {
// all segments completed
return;
}

// urgent area stable peers first
var stableDispatchPiece = 0;
if (!shareMode && this.stablePeers_.length > 0) {
stableDispatchPiece = this.dispatchStablePeers_(this.urgentSegmentIndex_);
}

// p2p area try other peers, sort by last receive speed
// if( manager_.getEnviroment_().p2pEnabled_ )
// if( urgentIncompleteCount_ <= 0 )
this.otherPeerRequestCount_ = this.dispatchOtherPeers_(this.urgentSegmentIndex_);

// active cdn fetch area
var fetchPieces = 0;
if (!shareMode && (this.urgentSegmentIndex_ >= 0) && this.manager_.getEnviroment_().p2pEnabled_ && this.urgentIncompleteCount_ <= 0
&& this.otherPeers_.length > 0) {
fetchPieces = this.dispatchFetchRate_(this.urgentSegmentIndex_);
}

// updateStatDownloadedDuration();

P2P_ULOG_TRACE(P2P_ULOG_FMT("{0}::Schedule {1} stable pieces ...",this.tag_,stableDispatchPiece));
},
dispatchFetchRate_ : function(startSegmentIndex) {
if (this.stablePeers_.length == 0 || this.metaData_.segments_.length == 0) {
return 0;
}

// active cdn fetch area
var fetchPieceCount = 0;
var idlePieceCount = 0;
// var maxRatioFetchCount = 1;
var maxFetchNumber = this.context_.p2pFetchRate_ * 100;
var startFetchId = this.lastFetchEndSegmentId_;
var nowTime = this.global_.getMilliTime_();
var usedSegmentCount = 0;
var usedOffsetBytes = 0;
var maxOffsetBytes = (this.getStorageBucket_().getDataCapacity_()) * 2 / 3;

var message = new p2p$.com.webp2p.protocol.base.Message();
var peer = this.getNextIdleStablePeer_();
for ( var n = startSegmentIndex; n < this.metaData_.segments_.length && peer; n++) {
var segment = this.metaData_.segments_[n];
if (this.urgentIncompleteCount_ > 0 && this.urgentSegmentEndId_ >= 0 && segment.id_ >= this.urgentSegmentEndId_) {
// urgent incompleted
break;
}

usedSegmentCount++;
if (segment.size_ > 0) {
// to avoid too many bytes
usedOffsetBytes += segment.size_;
if (usedOffsetBytes > maxOffsetBytes) {
break;
}
} else if (usedSegmentCount > 10) {
// to avoid too many segments
break;
}

this.lastFetchEndSegmentId_ = segment.id_;
if (segment.id_ <= startFetchId) {
continue;
} else if (segment.completedTime_ > 0) {
continue;
}

var previousTn = false;
var previousHit = false;
for ( var k = 0; k < segment.pieces_.length && peer; k++) {
var piece = segment.pieces_[k];
if (piece.completedTime_ > 0 || piece.receiveStartTime_ > 0 || piece.shareInRanges_ > 0 || piece.size_ <= 0) {
// completed or receiving or exits other peer
previousHit = false;
continue;
}

if (piece.randomNumber_ >= maxFetchNumber) {
if (piece.type_ == p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn) {
if (k + 1 >= segment.pieces_.length) {
continue;
}
var next = segment.pieces_[k + 1];
if (next.completedTime_ > 0 || next.receiveStartTime_ > 0 || next.shareInRanges_ > 0) {
continue;
} else if (next.randomNumber_ >= maxFetchNumber) {
continue;
}
} else if (!previousHit || !previousTn) {
continue;
}
}

var requestItem = new p2p$.com.webp2p.protocol.base.RequestDataItem();
requestItem.segmentId_ = segment.id_;
requestItem.pieceType_ = piece.type_;
requestItem.pieceId_ = piece.id_;
requestItem.checksum_ = piece.checksum_;
message.requests_.push(requestItem);
piece.receiveByStable_ = true;
piece.receiveStartTime_ = nowTime;
piece.receiveSessionId_ = peer.sessionId_;
if (segment.startReceiveTime_ <= 0) {
segment.startReceiveTime_ = nowTime;
}
fetchPieceCount++;
previousTn = (piece.type_ == p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn);
previousHit = true;
}
if (message.requests_.length > 0) {
if (peer.pendingRequestCount_ <= 0) {
peer.lastSegmentId_ = segment.id_;
}
peer.pendingRequestCount_ += message.requests_.length;
peer.statSendMessage_(message);
peer.session_.send(message);
message.requests_ = [];
peer = this.getNextIdleStablePeer_();
}
}

P2P_ULOG_TRACE(P2P_ULOG_FMT("{0} Random fetch, start index ({1}), total ({2}) idle pieces, fetched ({3}) fetch rate({4})",this.tag_,startFetchId, idlePieceCount, fetchPieceCount, this.context_.p2pFetchRate_ * 100));

return fetchPieceCount;
},
dispatchStablePeers_ : function(startSegmentIndex) {
if (this.stablePeers_.length == 0 || this.metaData_.segments_.length == 0) {
return 0;
}

// urgent area stable peers first
var totalDuration = 0;
var stableDispatchPiece = 0;
// var allPeersBusy = false;
var busyPieceCount = 0;
var appendDuration = 0;
var nowTime = this.global_.getMilliTime_();
var maxDuration = this.getUrgentMaxDuration_(this.manager_.getEnviroment_().isMobileNetwork_() ? 1000 : 1500); // 1.5 ratio for p2p
var message = new p2p$.com.webp2p.protocol.base.Message();

var peer = this.getNextIdleStablePeer_();
for ( var n = startSegmentIndex;
// n < endSegmentIndex && n < metaData_.segments_.size() && eachStablePiece > 0 && stableIterator != stablePeers_.end() && totalDuration <
// maxDuration;
n < this.metaData_.segments_.length && totalDuration < maxDuration; n++) {
var segment = this.metaData_.segments_[n];
this.lastFetchEndSegmentId_ = Math.max(this.lastFetchEndSegmentId_, segment.id_);
totalDuration += segment.duration_;
// if( segment.lastPlayTime_ > 0 ) continue;
if (segment.completedTime_ > 0) {
continue;
}

for ( var k = 0; k < segment.pieces_.length && peer != null && busyPieceCount <= 0; k++) {
var piece = segment.pieces_[k];
if (piece.completedTime_ > 0) {
if (message.requests_.length > 0) {
// if message.requests_.length > 0
// Keep downloadrange Continuous
// break
break;
} else {
// already complete
// continue;
continue;
}
} else if (piece.receiveStartTime_ > 0) {
// duplicate receiving
var pieceTimeout = ((piece.size_ > 0) ? (this.context_.p2pUrgentSize_ / 2) : this.context_.p2pUrgentSize_) * 1000;
if (piece.receiveByStable_ && (piece.receiveStartTime_ + pieceTimeout > nowTime)) {
// receving by stable cdn peer
busyPieceCount++;
continue;
}
}

if (segment.size_ > 0 && segment.duration_ > 0) {
appendDuration += piece.size_ / segment.size_ * segment.duration_ * 1000.0;
}

var requestItem = new p2p$.com.webp2p.protocol.base.RequestDataItem();
requestItem.urgent_ = true;
requestItem.segmentId_ = segment.id_;
requestItem.pieceType_ = piece.type_;
requestItem.pieceId_ = piece.id_;
requestItem.checksum_ = piece.checksum_;
message.requests_.push(requestItem);
piece.receiveByStable_ = true;
piece.receiveStartTime_ = nowTime + appendDuration;
piece.receiveSessionId_ = peer.sessionId_;
if (segment.startReceiveTime_ <= 0) {
segment.startReceiveTime_ = nowTime;
}

stableDispatchPiece++;
if (message.requests_.length >= 50) {
if (peer.pendingRequestCount_ <= 0) {
peer.lastSegmentId_ = segment.id_;
}
peer.activeTime_ = nowTime;
peer.pendingRequestCount_ += message.requests_.length;
peer.statSendMessage_(message);
peer.session_.send(message);
message.requests_ = [];
appendDuration = 0;
peer = null;
break;
}
}
if (message.requests_.length > 0 && peer != null) {
if (peer.pendingRequestCount_ <= 0) {
peer.lastSegmentId_ = segment.id_;
}
peer.activeTime_ = nowTime;
peer.pendingRequestCount_ += message.requests_.length;
peer.statSendMessage_(message);
peer.session_.send(message);
message.requests_ = [];
appendDuration = 0;
peer = null;
}
}

return stableDispatchPiece;
},

dispatchOtherPeers_ : function(startSegmentIndex) {
if (this.otherPeers_.length == 0 || this.metaData_.segments_.length == 0) {
return 0;
}

// p2p area try other peers, sort by last receive speed
var stableTooSlow = false;
var requestCount = this.getOtherPeerRequestCount_();
var maxCount = this.urgentIncompleteCount_ > 0 ? this.context_.p2pMaxUrgentRequestPieces_ : this.context_.p2pMaxParallelRequestPieces_;
var bucket = this.getStorageBucket_();
var offsetIndex = -1;
var usedSegmentCount = 0;
var usedOffsetBytes = 0;
var maxOffsetBytes = bucket.getDataCapacity_() * 2 / 3;

// forward offset
if (startSegmentIndex >= 0) {
// var startIndex = startSegmentIndex;
var totalDuration = 0;
var maxDuration = this.getUrgentMaxDuration_(this.manager_.getEnviroment_().isMobileNetwork_() ? 1500 : 2000); // 2 ratio of urgent size
stableTooSlow = this.getStablePeersSpeedTooSlow_();
for ( var n = startSegmentIndex; requestCount < maxCount && n < this.metaData_.segments_.length; n++) {
var segment = this.metaData_.segments_[n];
totalDuration += segment.duration_;
usedSegmentCount++;
if (segment.size_ > 0) {
// to avoid too many bytes
usedOffsetBytes += segment.size_;
if (usedOffsetBytes > maxOffsetBytes || (usedSegmentCount + 5) > bucket.getMaxOpenBlocks_()) {
break;
}
} else if (usedSegmentCount > 10) {
// to avoid too many segments
break;
}

if (segment.p2pDisabled_) {
continue;
}
if (totalDuration <= maxDuration && !stableTooSlow && this.urgentSegmentIndex_ >= 0) {
continue;
}
if (offsetIndex < 0) {
offsetIndex = n;
}
requestCount = this.dispatchSegmentForOtherPeers_(stableTooSlow, requestCount, maxCount, segment);
if (this.urgentIncompleteCount_ > 0 && this.urgentSegmentEndId_ >= 0 && segment.id_ >= this.urgentSegmentEndId_) {
// urgent incompleted
break;
}
}
}
if (offsetIndex < 0) {
offsetIndex = this.metaData_.segments_.length - 1;
}
// backward check
for ( var n = offsetIndex; requestCount < maxCount && n >= 0 && n >= startSegmentIndex; n--) {
var segment = this.metaData_.segments_[n];
if (segment.p2pDisabled_ || segment.completedTime_ > 0) {
continue;
}
requestCount += this.dispatchSegmentForOtherPeers_(stableTooSlow, requestCount, maxCount, segment);
}
return requestCount;
},

dispatchSegmentForOtherPeers_ : function(stableTooSlow, requestCount, maxCount, segment) {
var nowTime = this.global_.getMilliTime_();
for ( var k = 0; requestCount < maxCount && k < segment.pieces_.length; k++) {
var piece = segment.pieces_[k];
if (piece.completedTime_ > 0 || piece.size_ <= 0) {
// completed
continue;
} else if (piece.receiveStartTime_ > 0)
{
// duplicate receiving
var pieceTimeout = ((piece.size_ > 0) ? (this.context_.p2pUrgentSize_ / 2) : this.context_.p2pUrgentSize_) * 1000;
if (piece.receiveStartTime_ + pieceTimeout > nowTime) {
if (!piece.receiveByStable_ || !stableTooSlow) {
// not expired
continue;
}
}
}

var peer = this.getNextIdleOtherPeer_(piece.type_, piece.id_);

if (peer == null) {
// no idle peer has this piece
continue;
}

var message = new p2p$.com.webp2p.protocol.base.Message();
var requestItem = new p2p$.com.webp2p.protocol.base.RequestDataItem();
requestItem.segmentId_ = segment.id_;
requestItem.pieceType_ = piece.type_;
requestItem.pieceId_ = piece.id_;
requestItem.checksum_ = piece.checksum_;
message.requests_.push(requestItem);
piece.receiveByOther_ = true;
piece.receiveSessionId_ = peer.sessionId_;
piece.receiveStartTime_ = nowTime;
peer.activeTime_ = nowTime;
peer.lastSegmentId_ = segment.id_;
peer.receivePiece_ = piece;
peer.statSendMessage_(message);
peer.statReceiveBegin_();
peer.session_.send(message);
requestCount++;

// P2P_ULOG_TRACE(P2P_ULOG_FMT("logic::vod::Channel::dispatchSegmentForOtherPeer"));
}

return requestCount;
},

getAllStatus_2_ : function(params, result) {
this._super(params, result);
result["liveStreamId"] = this.liveStreamId_;
// result["liveStartTime"] = this.liveStartTime_;
// result["liveCurrentTime"] = this.liveCurrentTime_;
// result["livePlayerShift"] = this.livePlayerShift_;
// result["liveAbTimeShift"] = this.liveAbTimeShift_;
// result["livePseudoPlayTime"] = this.getPseudoPlayTime_(nowTime);
// result["liveNowPlayOffset"] = this.liveNowPlayOffset_;
// result["livePlayOffset"] = this.livePlayOffset_;
// result["livePlayMaxTimeLength"] = this.livePlayMaxTimeLength_;
// result["liveMetaRefreshInterval"] = this.liveMetaRefreshInterval_;
// result["liveSkipSegmentTime"] = this.liveSkipSegmentTime_;
},

getPseudoPlayTime_ : function(nowTime) {
var liveSkipTime = Math.floor(this.liveSkipSegmentTime_ / 1000);
this.liveSkipTime = Math.max(Math.min(liveSkipTime, 60), 0);
var playFlushGap = 0;
var pseudoTime = this.liveCurrentTime_ + (nowTime - this.liveMetaLoadTime_) / 1000;
return pseudoTime - this.livePlayOffset_ + this.context_.specialPlayerTimeOffset_ + playFlushGap + liveSkipTime; // +
// (time_t)(metaData_.totalGapDuration_ / 1000);
},

updateUrgentSegment_ : function(requireId) {
this._super(requireId);
if ( /* fromPlayer && */requireId >= 0 && !this.liveFirstUrgentUpdated_) {
this.liveFirstUrgentUpdated_ = true;
this.liveSkipSegmentTime_ = 0;
for ( var n = 0; n < this.metaData_.segments_.length; n++) {
var segment = this.metaData_.segments_[n];
if (segment.id_ >= requireId) {
break;
}
if (segment.duration_ > 0) {
this.liveSkipSegmentTime_ += segment.duration_;
}
}
}
}
});
p2p$.ns('com.webp2p.logic.vod');
p2p$.com.webp2p.logic.vod.ChannelStatic = {
kTimerSchedule : 0,
kTimerReport : 1,
};
p2p$.com.webp2p.logic.vod.Channel = p2p$.com.webp2p.logic.base.Channel.extend_({
// 初始化参数
lastUrgentStartAbsTime_ : 0,
lastUrgentStartMetaTime_ : 0,
lastRequireSegmentId_ : 0,

init : function(channelUrl, decodedUrl, mgr) {
this._super(p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeVod, channelUrl, decodedUrl, mgr);
this.tag_="com::webp2p::logic::vod::Channel";
this.channelType_="vod";
this.context_.playType_ = "vod";
this.lastUrgentStartAbsTime_ = 0;
this.lastUrgentStartMetaTime_ = 0;
this.lastRequireSegmentId_ = 0;
},

open : function() {
this._super();
this.sendStatus_({type:"VIDEO.GSLB.LOADING"});
this.gslb_.start_();
return true;
},

onOpened_ : function() {
if (this.protocolPool_ == null) {
return;
}
this.stablePeers = [];
this.otherPeers_ = [];
this.protocolPool_.initialize_();
this.setScheduleTimeout_(p2p$.com.webp2p.logic.vod.ChannelStatic.kTimerSchedule, 3 * 1000);
},

close : function() {
this._super();
},

detectAutoRedirectMode_ : function() {
},

dispatchStablePeers_ : function(startSegmentIndex) {
if (this.stablePeers_.length == 0 || this.metaData_.segments_.length == 0) {
return null;
}
// urgent area stable peers first
var totalDuration = 0;
var stableDispatchPiece = 0;
// bool allPeersBusy = false;
var busyPieceCount = 0;
var appendDuration = 0;
var nowTime = this.global_.getMilliTime_();
var maxDuration = this.getUrgentMaxDuration_(this.manager_.getEnviroment_().isMobileNetwork_() ? 1000 : 1500); // 1.5 ratio for p2p
var message = new p2p$.com.webp2p.protocol.base.Message();

if (this.urgentSegmentIndex_ >= 0 && this.urgentSegmentIndex_ < this.metaData_.segments_.length
&& this.metaData_.segments_[this.urgentSegmentIndex_].completedTime_ <= 0) {
// cancel all far downloading stable peers when urgent segment is not completed
for ( var n = 0; n < this.stablePeers_.length; n++) {
var item = this.stablePeers_[n];
if (item == null || item.pendingRequestCount_ <= 0 || item.lastSegmentId_ == this.urgentSegmentId_) {
continue;
}

P2P_ULOG_INFO(P2P_ULOG_FMT("{0} [{1}]Cancel far downloading stable peer, segment({2}), pending({3}), id({4}), address({5})",this.tag_,p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.type_), item.lastSegmentId_, item.pendingRequestCount_, item.session_.getRemoteId_(), item.session_.getRemoteAddress_()));
this.resetPieceReceivingBySession_(item.sessionId_);
this.resetPeerMessage_(nowTime, false, item);
}
}
var peer = this.getNextIdleStablePeer_();
var retPeer = peer;
var retSegment = null;
for ( var n = startSegmentIndex;n < this.metaData_.segments_.length && totalDuration < maxDuration; n++) {
var segment = this.metaData_.segments_[n];
totalDuration += segment.duration_;
if (segment.completedTime_ > 0) {
continue;
}
for ( var k = 0; k < segment.pieces_.length && peer != null && busyPieceCount <= 0; k++) {
var piece = segment.pieces_[k];
if (piece.completedTime_ > 0) {
if (message.requests_.length > 0) {
break;
} else {
continue;
}
} else if (piece.receiveStartTime_ > 0) {
// duplicate receiving
var pieceTimeout = ((piece.size_ > 0) ? (this.context_.p2pUrgentSize_ / 2) : this.context_.p2pUrgentSize_) * 1000;
if (piece.receiveByStable_ && (piece.receiveStartTime_ + pieceTimeout > nowTime)) {
// receving by stable cdn peer
busyPieceCount++;
continue;
}
// busyPieceCount ++;
// break;
}
retSegment = segment;
if (segment.size_ > 0 && segment.duration_ > 0) {
appendDuration += piece.size_ / segment.size_ * segment.duration_ * 1000.0;
}

var requestItem = new p2p$.com.webp2p.protocol.base.RequestDataItem();
requestItem.urgent_ = true;
requestItem.segmentId_ = segment.id_;
requestItem.pieceType_ = piece.type_;
requestItem.pieceId_ = piece.id_;
requestItem.checksum_ = piece.checksum_;
message.requests_.push(requestItem);
piece.receiveByStable_ = true;
piece.receiveStartTime_ = nowTime + appendDuration;
piece.receiveSessionId_ = peer.sessionId_;
if (segment.startReceiveTime_ <= 0) {
segment.startReceiveTime_ = nowTime;
}

stableDispatchPiece++;
if (message.requests_.length >= 50) {
if (peer.pendingRequestCount_ <= 0) {
peer.lastSegmentId_ = segment.id_;
}
peer.activeTime_ = nowTime;
peer.pendingRequestCount_ += message.requests_.length;
peer.statSendMessage_(message);
peer.session_.send(message);
message.requests_ = [];
appendDuration = 0;
peer = null;
break;
}
}
if (message.requests_.length > 0 && peer != null) {
if (peer.pendingRequestCount_ <= 0) {
peer.lastSegmentId_ = segment.id_;
}
peer.activeTime_ = nowTime;
peer.pendingRequestCount_ += message.requests_.length;
peer.statSendMessage_(message);
peer.session_.send(message);
message.requests_ = [];
appendDuration = 0;
peer = null;
}
}

return {
"stableDispatchPiece" : stableDispatchPiece,
"peerInfo" : retPeer,
"segmentInfo" : retSegment
};
},

onSchedule_ : function(shareMode) {
var nowTime = this.global_.getMilliTime_();
if (this.paused_) {
return;
}
this.lastScheduleTime_ = nowTime;
this.updatePeersSpeed_(nowTime, this.stablePeers_);
// check pieces to download
var totalDuration = 0;
var maxDuration = this.context_.p2pUrgentSize_ * 1000;
this.urgentSegmentIndex_ = -1;
for ( var n = 0; (this.urgentSegmentId_ >= 0) && (n < this.metaData_.segments_.length); n++) {
var segment = this.metaData_.segments_[n];
if (segment.id_ == this.urgentSegmentId_) {
// find urgent segment index
this.urgentSegmentIndex_ = n;
this.context_.playingPosition_ = segment.startTimeActual_ / 1000;
}
if (this.urgentSegmentIndex_ >= 0 && n >= this.urgentSegmentIndex_) {
if (totalDuration < maxDuration || this.urgentSegmentEndId_ <= this.urgentSegmentId_) {
// urgent should has 2 segments at least if more segments eixst
this.urgentSegmentEndId_ = segment.id_;
}
totalDuration += segment.duration_;
}
}
if (!shareMode) {
this.checkTimeoutPieces_(nowTime);
this.checkTimeoutPeers_(nowTime);
this.checkPeerPieceRanges_(nowTime);

this.lastPeerSortTime_ = nowTime;
this.stablePeers_.sort(function(item1, item2) {
if (item1.lastReceiveSpeed_ == item2.lastReceiveSpeed_) {
return item1.lastTimeoutTime_ - item2.lastTimeoutTime_;
}
return item2.lastReceiveSpeed_ - item1.lastReceiveSpeed_;
});
this.otherPeers_.sort(function(item1, item2) {
if (item1.lastReceiveSpeed_ == item2.lastReceiveSpeed_) {
return item1.lastTimeoutTime_ - item2.lastTimeoutTime_;
}
return item2.lastReceiveSpeed_ - item1.lastReceiveSpeed_;
});
this.statData_.addReceiveData_(true, p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeCdn, 0, 0); // flush speed
}
//
this.metaData_.urgentSegmentId_ = this.urgentSegmentId_;
this.updateUrgentIncompleteCount_();
// urgent area stable peers first
var retVal = null;
if (!shareMode && (this.urgentSegmentIndex_ >= 0) && this.stablePeers_.length > 0) {
retVal = this.dispatchStablePeers_(this.urgentSegmentIndex_);
if (retVal != null && retVal.segmentInfo != null) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} Schedule {1} piece request(s) to ({2}), channel({3}),urgentSegmentId({4}), segmentID({5}), segmentPieces({6})",this.tag_, retVal.stableDispatchPiece, retVal.peerInfo.session_.remoteAddress_,this.id_, this.urgentSegmentId_, retVal.segmentInfo.id_,((this.urgentSegmentIndex_ < this.metaData_.segments_.length) ? this.metaData_.segments_[retVal.segmentInfo.id_].pieces_.length : 0)));
}
}
this.otherPeerRequestCount_ = this.dispatchOtherPeers_((this.urgentSegmentIndex_ >= 0) ? this.urgentSegmentIndex_ : 0);
},

dispatchOtherPeers_ : function(startSegmentIndex) {
if (this.otherPeers_.length == 0 || this.metaData_.segments_.length == 0) {
return 0;
}

// p2p area try other peers, sort by last receive speed
var stableTooSlow = false;
var requestCount = this.getOtherPeerRequestCount_();
var maxCount = this.urgentIncompleteCount_ > 0 ? this.context_.p2pMaxUrgentRequestPieces_ : this.context_.p2pMaxParallelRequestPieces_;
var bucket = this.getStorageBucket_();
var offsetIndex = -1;
var usedSegmentCount = 0;
var usedOffsetBytes = 0;
var maxOffsetBytes = bucket.getDataCapacity_() * 2 / 3;
//
// // forward offset
if (startSegmentIndex >= 0) {
// size_t startIndex = startSegmentIndex;
var totalDuration = 0;
var maxDuration = this.getUrgentMaxDuration_(this.manager_.getEnviroment_().isMobileNetwork_() ? 1500 : 2000); // 2 ratio of urgent size
stableTooSlow = this.getStablePeersSpeedTooSlow_();
for ( var n = startSegmentIndex; requestCount < maxCount && n < this.metaData_.segments_.length; n++) {
var segment = this.metaData_.segments_[n];
totalDuration += segment.duration_;
usedSegmentCount++;
if (segment.size_ > 0) {
// to avoid too many bytes
usedOffsetBytes += segment.size_;
if (usedOffsetBytes > maxOffsetBytes || (usedSegmentCount + 5) > bucket.getMaxOpenBlocks_()) {
break;
}
} else if (usedSegmentCount > 10) {
// to avoid too many segments
break;
}

if (segment.p2pDisabled_) {
continue;
}
if (totalDuration <= maxDuration && !stableTooSlow && this.urgentSegmentIndex_ >= 0) {
continue;
}
if (offsetIndex < 0) {
offsetIndex = n;
}
requestCount = this.dispatchSegmentForOtherPeers_(stableTooSlow, requestCount, maxCount, segment);
if (this.urgentIncompleteCount_ > 0 && this.urgentSegmentEndId_ >= 0 && segment.id_ >= this.urgentSegmentEndId_) {
// urgent incompleted
break;
}
}
}
//
if (offsetIndex < 0) {
return requestCount;
}
//
// // backward check
for ( var n = offsetIndex; requestCount < maxCount && n >= 0 && n >= startSegmentIndex; n--) {
var segment = this.metaData_.segments_[n];
if (segment.p2pDisabled_ || segment.completedTime_ > 0) {
continue;
}
requestCount += this.dispatchSegmentForOtherPeers_(stableTooSlow, requestCount, maxCount, segment);
}
return requestCount;
},

dispatchSegmentForOtherPeers_ : function(stableTooSlow, requestCount, maxCount, segment) {
var nowTime = this.global_.getMilliTime_();
for ( var k = 0; requestCount < maxCount && k < segment.pieces_.length; k++) {
var piece = segment.pieces_[k];
if (piece.completedTime_ > 0 || piece.size_ <= 0) {
// completed
continue;
} else if (piece.receiveStartTime_ > 0)
{
// duplicate receiving
var pieceTimeout = ((piece.size_ > 0) ? (this.context_.p2pUrgentSize_ / 2) : this.context_.p2pUrgentSize_) * 1000;
if (piece.receiveStartTime_ + pieceTimeout > nowTime) {
if (!piece.receiveByStable_ || !stableTooSlow) {
// not expired
continue;
}
}
}

var peer = this.getNextIdleOtherPeer_(piece.type_, piece.id_);

if (peer == null) {
// no idle peer has this piece
continue;
}

var message = new p2p$.com.webp2p.protocol.base.Message();
var requestItem = new p2p$.com.webp2p.protocol.base.RequestDataItem();
requestItem.segmentId_ = segment.id_;
requestItem.pieceType_ = piece.type_;
requestItem.pieceId_ = piece.id_;
requestItem.checksum_ = piece.checksum_;
message.requests_.push(requestItem);
piece.receiveByOther_ = true;
piece.receiveSessionId_ = peer.sessionId_;
piece.receiveStartTime_ = nowTime;
peer.activeTime_ = nowTime;
peer.lastSegmentId_ = segment.id_;
peer.receivePiece_ = piece;
peer.statSendMessage_(message);
peer.statReceiveBegin_();
peer.session_.send(message);
requestCount++;

// P2P_ULOG_TRACE(P2P_ULOG_FMT("logic::vod::Channel::dispatchSegmentForOtherPeer"));
}

return requestCount;
},

sortStablePeers_ : function() {
// for ( var n = 0; n < this.stablePeers_.length; n++) {
// var item = this.stablePeers_[n];
// }
},

onTimeout_ : function(tag) {

switch (tag) {
case p2p$.com.webp2p.logic.vod.ChannelStatic.kTimerSchedule: {
this.onSchedule_(false);
this.setScheduleTimeout_(p2p$.com.webp2p.logic.vod.ChannelStatic.kTimerSchedule, 3 * 1000);
break;
}
default:
break;
}

},

// override protocol::base::EventListener
onProtocolSessionMessage_ : function(session, message) {
this._super(session, message);
}
});
p2p$.ns('com.webp2p.protocol.base');
p2p$.com.webp2p.protocol.base.PROTOCOL_STATES = {
kProtocolStateReady : 0,
kProtocolStateConnecting : 1,
kProtocolStateConnected : 2,
kProtocolStateDisconnecting : 3,
kProtocolStateDisconnected : 4
};

p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES = {
kProtocolTypeReserved : 0,
kProtocolTypeCdn : 1,
kProtocolTypeRtmfp : 2,
kProtocolTypeWebSocket : 3,
kProtocolTypeWebrtc : 4,
kProtocolTypeMax : 5
};

p2p$.com.webp2p.protocol.base.TERMINAL_TYPES = {
kTerminalTypeReserved : 0,
kTerminalTypePc : 1,
kTerminalTypeTv : 2,
kTerminalTypeBox : 3,
kTerminalTypeMobile : 4,
kTerminalTypeMax : 5
};

p2p$.com.webp2p.protocol.base.ManagerStatic = {
getTerminalType_ : function(type) {
var typeMark = null;
var pos = type.indexOf('/');
if (pos == -1) {
typeMark = type;
} else if (pos > 0) {
typeMark = type.substr(0, pos);
}
var strings_ = p2p$.com.common.String;
var lowerTypeMark = strings_.makeLower_(typeMark);
if (strings_.startsWith_(lowerTypeMark, "un")) {
return p2p$.com.webp2p.protocol.base.TERMINAL_TYPES.kTerminalTypePc;
} else if (strings_.startsWith_(lowerTypeMark, "pc")) {
return p2p$.com.webp2p.protocol.base.TERMINAL_TYPES.kTerminalTypePc;
} else if (strings_.startsWith_(lowerTypeMark, "tv")) {
return p2p$.com.webp2p.protocol.base.TERMINAL_TYPES.kTerminalTypeTv;
} else if (strings_.startsWith_(lowerTypeMark, "box")) {
return p2p$.com.webp2p.protocol.base.TERMINAL_TYPES.kTerminalTypeBox;
} else if (strings_.startsWith_(lowerTypeMark, "mp")) {
return p2p$.com.webp2p.protocol.base.TERMINAL_TYPES.kTerminalTypeMobile;
} else if (strings_.startsWith_(lowerTypeMark, "iphone")) {
return p2p$.com.webp2p.protocol.base.TERMINAL_TYPES.kTerminalTypeMobile;
} else if (lowerTypeMark.length > 0) {
switch (lowerTypeMark[0]) {
case 'C':
case 'c': // C1,C1S
case 'T':
case 't': // T1, T1S
return p2p$.com.webp2p.protocol.base.TERMINAL_TYPES.kTerminalTypeBox;
break;

case 'X':
case 'x': // X50 X60
case 'S':
case 's': // S40, S50, S70
return p2p$.com.webp2p.protocol.base.TERMINAL_TYPES.kTerminalTypeTv;
break;

default:
return p2p$.com.webp2p.protocol.base.TERMINAL_TYPES.kTerminalTypeMobile;
break;
}
} else {
return p2p$.com.webp2p.protocol.base.TERMINAL_TYPES.kTerminalTypeReserved;
}
},
};

p2p$.com.webp2p.protocol.base.Manager = JClass.extend_({
pool_ : null,//管理池
eventListener_ : null,
sessions_ : null,

type_ : 0,
protocolState_ : 0,
maxActiveSession_ : 0,
beginRegisterTime_:0,
id_ : "",
serverId_ : "",
serverUrl_ : "",
global_:null,
strings_:null,
config_:null,
module_:null,
tag_:"com::webp2p::protocol::base::Manager",

init : function(pool, evt, type) {
this.pool_ = pool;
this.eventListener_ = evt;
this.type_ = type;
this.protocolState_ = p2p$.com.webp2p.protocol.base.PROTOCOL_STATES.kProtocolStateReady;
this.maxActiveSession_ = 20;
this.sessions_ = [];
this.global_ = p2p$.com.common.Global;
this.strings_ = p2p$.com.common.String;
this.config_ = p2p$.com.selector.Config;
this.module_ = p2p$.com.selector.Module;
},

getId_ : function() {
return this.id_;
},
getType : function() {
return this.type_;
},
getTypeNames_ : function(type) {
switch (type) {
case p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeReserved:
return "reserved";
case p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeCdn:
return "cdn";
case p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeRtmfp:
return "rtmfp";
case p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeWebSocket:
return "websocket";
case p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeWebrtc:
return "webrtc";
default:
return "unknown";
}
},
getTypeName_ : function() {
return this.getTypeNames_(this.type_);
},

// boost::asio::io_service &getService(){ return service_; }
getPool_ : function() {
return this.pool_;
},

getEventListener_ : function() {
return this.eventListener_;
},

setTimeout_ : function(tag, timer, milliSeconds) {
var me = this;
timer = setTimeout(function() {
me.onTimeout_(tag, timer);
}, milliSeconds);
return timer;
},

onTimeout_ : function(tag, timer, errorCode) {
},

setMaxActiveSession_ : function(count) {
this.maxActiveSession_ = count;
},

isStable_ : function() {
return p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeCdn == this.type_;
},

open : function() {
},
close : function() {
}
});
p2p$.ns('com.webp2p.protocol.base');

p2p$.com.webp2p.protocol.base.PieceRangeItem = JClass.extend_({
type_ : 0,
count_ : 0,
start_ : 0,
init : function() {
this.type_ = 0;
this.count_ = 0;
this.start_ = 0;
},
});

p2p$.com.webp2p.protocol.base.RequestDataItem = JClass.extend_({
urgent_ : false,
segmentId_ : 0,
pieceId_ : 0,
pieceType_ : 0,
checksum_ : 0,
init : function() {
this.urgent_ = false;
this.segmentId_ = -1;
this.pieceId_ = 0;
this.pieceType_ = 0;
this.checksum_ = 0;
},
});

p2p$.com.webp2p.protocol.base.ResponseDataItem = JClass.extend_({
segmentId_ : 0,
pieceId_ : 0,
pieceType_ : 0,
pieceKey_ : 0,
data_ : "",
init : function() {
this.segmentId_ = -1;
this.pieceId_ = 0;
this.pieceType_ = 0;
this.pieceKey_ = 0;
},
});

p2p$.com.webp2p.protocol.base.Message = JClass.extend_({
type_ : "",
ranges_ : null,
requests_ : null,
responses_ : null,
init : function() {
this.type_ = 0;
this.ranges_ = [];
this.requests_ = [];
this.responses_ = [];
},
empty : function() {
return this.ranges_.length == 0 && this.requests_.length == 0 && this.responses_.length == 0;
}
});
p2p$.ns('com.webp2p.protocol.base');

p2p$.com.webp2p.protocol.base.Pool = JClass.extend_({
valid_ : false,
p2pActive_ : false,
enviroment_ : null,
context_ : null,
metaData_ : null,
http_ : null,
// service_:null,
timer_ : null,
eventListener_ : null,
managers_ : null,
strings_:null,

selectorRedirectTimes_ : 0,
selectorTryTimes_ : 0,
selectorSuccessTime_ : 0,
selectorRedirectNeeded_ : false,
selectorRedirectHost_ : "",
selectorResponseResult_ : "",
tag_:"com::webp2p::protocol::base::Pool",

init : function(enviroment, context, metaData, baseChannel) {
this.enviroment_ = enviroment;
this.context_ = context;
this.metaData_ = metaData;
this.eventListener_ = baseChannel;
this.strings_ = p2p$.com.common.String;
this.managers_ = [];
this.http_ = null;
this.valid_ = false;
this.context_.webrtcServerHost_ = "ws://123.125.89.103:3852";
this.context_.gatherServerHost_ = "111.206.208.61:80";
this.context_.stunServerHost_ = "stun:111.206.210.145:8124";
//检查webrtc是否可用
if(!window.RTCPeerConnection)
{
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::init webrtc can not use in this broswer",this.tag_));
this.enviroment_.protocolWebrtcDisabled_=true;
}
},

initialize_ : function() {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::initialuze_ pool for type({1}), channel({2})",this.tag_,p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.metaData_.type_),this.metaData_.storageId_));
this.exit();
this.valid_ = true;
//创建cdn管理
var newManager = new p2p$.com.webp2p.protocol.cdn.Manager(this, this.eventListener_);
newManager.open();
this.managers_.push(newManager);
//加载selector
this.queryFromSelector_();
},
/*selector*/
queryFromSelector_ : function() {
if (!this.metaData_.p2pGroupId_) {
return;
}
if (this.http_ != null) {
this.http_.log("cancel");
this.http_.close();
this.http_ = null;
}
var hostDomain = this.enviroment_.getHostDomain_("selector.webp2p.letv.com");
var localMacAddress = this.strings_.urlEncodeNonAscii_(this.enviroment_.getLocalMacAddresses_());
var hardwareType = this.strings_.urlEncodeNonAscii_(this.enviroment_.deviceType_);
var requestUrl = this.strings_.format("http://{0}/query?streamid={1}&type={2}&module=cde&version={3}&geo={4}&isp={5}&country={6}&province={7}&city={8}&area={9}&appid={10}&mac={11}&hwtype={12}"
,this.selectorRedirectNeeded_ ? this.selectorRedirectHost_ : hostDomain
,this.metaData_.p2pGroupId_
,p2p$.com.webp2p.core.common.SERVER_TYPES.kServerTypeWebRTC + p2p$.com.webp2p.core.common.SERVER_TYPES.kServerTypeHttpTracker + p2p$.com.webp2p.core.common.SERVER_TYPES.kServerTypeStunServer
,this.context_.moduleVersion_
,this.context_.geo_
,this.context_.isp_
,this.context_.country_
,this.context_.province_
,this.context_.city_
,this.context_.area_
,this.enviroment_.appId_
,localMacAddress
,hardwareType);
this.selectorRedirectNeeded_ = false;
this.http_ = new p2p$.com.loaders.HttpDownLoader({url_:requestUrl, scope_:this,type_:"json", tag_:"base::selector"});
this.http_.load_();
this.setSelectorTimeout_(10 * 1000);
},
//selector加载结束
onHttpDownloadCompleted_ : function(downloader) {
var myFunName = this.strings_.getFunName(arguments.callee.toString());
var handled = false;
if (this.http_ != downloader) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::{1} Expired http complete for tag({2}), channel({3}), ignore",this.tag_,myFunName,this.http_.tag_,this.metaData_.storageId_));
return handled;
}

this.http_ = null;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::{1} tag({2}), channel({3}), response code({4}),size({5})",this.tag_,myFunName,downloader.tag_, this.metaData_.storageId_, downloader.responseCode_,downloader.responseData_.length));
if (downloader.tag_ == "base::selector") {
handled = true;
if (!downloader.successed_ || downloader.responseCode_ < 200 || downloader.responseCode_ >= 300) {
return handled;
}
// parse selector response
if (!this.parseSelectorResponse_(downloader)) {
// waiting for timeout and retry ...
return handled;
} else if (this.selectorRedirectNeeded_) {
this.selectorRedirectTimes_++;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::{1} Selector redirect to({2}), total {3} redirect times ...",this.tag_,myFunName,this.selectorRedirectHost_,this.selectorRedirectTimes_));
if (this.selectorRedirectTimes_ > 3) {
// too much redirect, waiting for timeout and retry ...
this.selectorRedirectNeeded_ = false;
this.selectorRedirectTimes_ = 0;
} else {
this.removeSelectorTimer_();
this.queryFromSelector_();
}
return handled;
}
this.removeSelectorTimer_();

P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::{1} Query from selector successfully, gather(http://{2}), webrtc({3}), tracker(http://{4}),stun({5}),max peers({6}), urgent size({7}), channel({8}),rtmfp({9}), websocket({10}), webrtc({11}), upload({12}), urgent upload({13}), range interval({14} s), upload limit({15}), init throttle({16} B/s), avg throttle({17} B/s), max reserved({18} B/s)"
,this.tag_
,myFunName
,this.context_.gatherServerHost_
,this.context_.webrtcServerHost_
,this.context_.trackerServerHost_
,this.context_.stunServerHost_
,this.context_.p2pMaxPeers_
,this.context_.p2pUrgentSize_
,this.metaData_.storageId_
,this.context_.protocolRtmfpDisabled_ ? "no" : "yes"
,this.context_.protocolWebsocketDisabled_ ? "no" : "yes"
,this.context_.protocolWebrtcDisabled_ ? "no" : "yes"
,this.context_.p2pUploadEnabled_ ? "yes" : "no"
,this.context_.p2pUrgentUploadEnabled_ ? "yes" : "no"
,this.context_.p2pShareRangeInterval_
,this.context_.p2pUploadLimit_ ? "yes" : "no"
,this.context_.p2pUploadThrottleInit_
,this.context_.p2pUploadThrottleAverage_
,this.context_.p2pUploadMaxReserved_));

this.selectorSuccessTime_ = p2p$.com.common.Global.getMilliTime_();
this.context_.selectorServerHost_ = downloader.remoteEndpoint_;
this.context_.selectorConnectedTime_ = downloader.totalUsedTime_;
this.eventListener_.onProtocolSelectorOpen_(p2p$.com.webp2p.core.common.ERROR_CODE.kErrorSuccess);
this.createOtherProtocols_();
}

return handled;
},
//分析
parseSelectorResponse_ : function(downloader) {
var myFunName = this.strings_.getFunName(arguments.callee.toString());
var result = downloader.responseData_;
if (result == "" || result == null) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::{1} Parse selector response data failed: channel({2})"
,this.tag_
,myFunName
,this.metaData_.storageId_));
return false;
}
this.selectorResponseResult_ = result["status"];
if (p2p$.com.webp2p.core.common.ERROR_CODE.kErrorSuccess == this.selectorResponseResult_) {
this.context_.configData_ = result;
var value = this.context_.configData_;
var items = value.items;
for ( var n = 0; n < items.length; n++) {
var item = items[n];
if (item.type == p2p$.com.webp2p.core.common.SERVER_TYPES.kServerTypeWebRTC) {
var rets = item.serviceUrls.split(",");
if (rets && rets.length > 1) {
if (!this.context_.hasDefaultWebrtcServer_) {
this.context_.webrtcServerHost_ = rets[1];
}
}

}
if (item.type == p2p$.com.webp2p.core.common.SERVER_TYPES.kServerTypeHttpTracker) {
var rets = item.serviceUrls.split("//");
if (rets && rets.length > 1) {
if (!this.context_.hasDefaultTrackerServer_) {
this.context_.gatherServerHost_ = rets[1];
}
}
}
if (item.type == p2p$.com.webp2p.core.common.SERVER_TYPES.kServerTypeStunServer) {
if (!this.context_.hasDefaultStunServer_) {
this.context_.stunServerHost_ =  item.serviceUrls;
}
}

}
// var value = JSON.stringify(this.context_.configData_);

this.context_.trackerServerHost_ = value.hasOwnProperty("trackerId") ? value["trackerId"] : this.context_.gatherServerHost_;
this.context_.p2pMaxPeers_ = Math.max(value["maxPeers"], 1);
this.context_.p2pUrgentSize_ = Math.max(value["urgentSize"], 1);
if (value.hasOwnProperty("p2pUploadEnabled")) {
this.context_.p2pUploadEnabled_ = value["p2pUploadEnabled"];
}
// enviroment_.p2pUploadEnabled_ = this.context_.p2pUploadEnabled_ = false;
if (value.hasOwnProperty("p2pUploadLimit")) {
this.context_.p2pUploadLimit_ = value["p2pUploadLimit"];
}
if (value.hasOwnProperty("p2pUploadThrottleInit")) {
this.context_.p2pUploadThrottleInit_ = value["p2pUploadThrottleInit"];
}
if (value.hasOwnProperty("p2pUploadThrottleAverage")) {
this.context_.p2pUploadThrottleAverage_ = value["p2pUploadThrottleAverage"];
}
if (value.hasOwnProperty("p2pUploadMaxReserved")) {
this.context_.p2pUploadMaxReserved_ = value["p2pUploadMaxReserved"];
}
if (value.hasOwnProperty("p2pUrgentUploadEnabled")) {
this.context_.p2pUrgentUploadEnabled_ = value["p2pUrgentUploadEnabled"];// /
}
if (value.hasOwnProperty("p2pShareRangeInterval")) {
this.context_.p2pShareRangeInterval_ = Math.max(value["p2pShareRangeInterval_"], 2);// /
}
if (value.hasOwnProperty("p2pMaxParallelRequestPieces")) {
this.context_.p2pMaxParallelRequestPieces_ = value["p2pMaxParallelRequestPieces"];// /
}
if (value.hasOwnProperty("p2pMaxUrgentRequestPieces")) {
this.context_.p2pMaxUrgentRequestPieces_ = value["p2pMaxUrgentRequestPieces"];// /
}
if (value.hasOwnProperty("fetchRate")) {
this.context_.p2pFetchRate_ = value["fetchRate"];
}
if (value.hasOwnProperty("cdnSlowThresholdRate")) {
this.context_.cdnSlowThresholdRate_ = value["cdnSlowThresholdRate"];//
}
if (value.hasOwnProperty("hbInterval")) {
this.context_.p2pHeartbeatInterval_ = Math.max(2, value["hbInterval"]);
}
if (value["statReportInterval"] > 0) {
this.context_.statReportInterval_ = value["statReportInterval"];//
}
if (value["livePlayOffset"] > 0) {
this.enviroment_.livePlayOffset_ = value["livePlayOffset"];//
}
if (value.hasOwnProperty("protocols")) {
var specificProtocols = value["protocols"];
// this.context_.protocolCdnDisabled_ = specificProtocols["cdn"]["disabled"];
this.context_.protocolRtmfpDisabled_ = specificProtocols["rtmfp"]["disabled"];
this.context_.protocolWebsocketDisabled_ = specificProtocols["websocket"]["disabled"];
this.context_.protocolWebrtcDisabled_ = specificProtocols["webrtc"]["disabled"];
}

return true;
} else {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::{1} Selector response error:{2}, channel({3})"
,this.tag_
,myFunName
,this.selectorResponseResult_,
this.metaData_.storageId_));
this.removeSelectorTimer_();
// this.onSelectorTimeout_();
return false;
}
},

setSelectorTimeout_ : function(timeoutMs) {
var me = this;
this.timer_ = setTimeout(function() {
me.onSelectorTimeout_();
}, timeoutMs);
},

removeSelectorTimer_ : function() {
if (this.timer_) {
clearTimeout(this.timer_);
this.timer_ = null;
}
},

onSelectorTimeout_ : function(errorCode) {
if (!this.valid_) {
return;
}

if (this.http_ != null) {
this.http_.log("timeout");
this.http_.close();
this.http_ = null;
}
this.selectorTryTimes_++;
var myFunName = this.strings_.getFunName(arguments.callee.toString());
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::{1} Selector timeout for channel({2}), {3} try times..."
,this.tag_
,myFunName
,this.metaData_.storageId_
,this.selectorTryTimes_));
this.queryFromSelector_();
// this.selectorSuccessTime_ = 1;
// this.createOtherProtocols_();
},

createOtherProtocols_ : function() {
// p2p not support under mobile network
var myFunName = this.strings_.getFunName(arguments.callee.toString());
var isMobileNow = this.enviroment_.isMobileNetwork_();
if (this.metaData_.p2pGroupId_ == "" || this.p2pActive_ || this.selectorSuccessTime_ <= 0 || isMobileNow) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::{1} p2pGroupId_({2}),p2pActive({3}), selectorSuccessTime_({4}),isMobileNow({5})"
,this.tag_
,myFunName
,this.metaData_.p2pGroupId_
,this.p2pActive_
,this.selectorSuccessTime_
,isMobileNow));
return true;
}
if (!this.context_.protocolWebrtcDisabled_ && !this.enviroment_.protocolWebrtcDisabled_) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::{1} p2pGroupId_({2})"
,this.tag_
,myFunName
,this.metaData_.p2pGroupId_));
var newManager = new p2p$.com.webp2p.protocol.webrtc.Manager(this, this.eventListener_);
newManager.open();
newManager.setMaxActiveSession_(this.context_.p2pMaxPeers_);
this.managers_.push(newManager);
}

// this.context_.protocolWebsocketDisabled_ = true;
if (!this.context_.protocolWebsocketDisabled_ && !this.enviroment_.protocolWebsocketDisabled_) {
var newManager = new p2p$.com.webp2p.protocol.websocket.Manager(this, this.eventListener_);
newManager.open();
newManager.setMaxActiveSession_(this.context_.p2pMaxPeers_);
this.managers_.push(newManager);
}
this.p2pActive_ = true;
return true;
},
refreshStable_ : function() {
},

p2pGroupIdChange_ : function() {
},

p2pActivate_ : function() {
if (this.p2pActive_) {
return true;
}
return this.createOtherProtocols_();
},

p2pDeactive_ : function() {
if (!this.p2pActive_) {
return true;
}

// close all p2p managers
for ( var n = 0; n < this.managers_.length; n++) {
var mgr = this.managers_[n];
if (mgr.isStable_()) {
continue;
}
mgr.close();
}
this.managers_ = [];
this.context_.rtmfpServerConnectedTime_ = 0;
this.context_.webrtcServerConnectedTime_ = 0;
this.context_.trackerServerConnectedTime_ = 0;
this.p2pActive_ = false;
return true;
},

p2pisActive_ : function() {
return this.p2pActive_;
},

p2pIsReady_ : function() {
return this.selectorSuccessTime_ > 0;
},

isValid_ : function() {
return this.valid_;
},

getContext_ : function() {
return this.context_;
},

getEnviroment_ : function() {
return this.enviroment_;
},

getMetaData_ : function() {
return this.metaData_;
},

getManagers_ : function() {
return this.managers_;
},

exit : function() {
this.valid_ = false;
if (this.timer_) {
clearTimeout(this.timer_);
this.timer_ = null;
}
if (this.http_ != null) {
this.http_.log("cancel");
this.http_ = null;
}
this.p2pActive_ = false;
this.selectorSuccessTime_ = 0;
for ( var n = 0; n < this.managers_.length; n++) {
var mgr = this.managers_[n];
mgr.close();
}
this.managers_ = [];
return true;
}
});
p2p$.ns('com.webp2p.protocol.base');

p2p$.com.webp2p.protocol.base.Session = JClass.extend_({
manager_ : null,
name_ : "",
remoteId_ : "",
remoteAddress_ : "",
remoteType_ : "",
opened_ : false,
active_ : false,
terminalType_ : 0,
timer_:null,
tag_:"com::webp2p::protocol::base::Session",
global_:null,
strings_:null,
enum_:null,

init : function(mgr, remoteId) {
this.manager_ = mgr;
this.remoteId_ = remoteId;
this.opened_ = false;
this.active_ = false;
this.terminalType_ = p2p$.com.webp2p.protocol.base.TERMINAL_TYPES.kTerminalTypeReserved;
this.global_ = p2p$.com.common.Global;
this.strings_ = p2p$.com.common.String;
this.enum_ = p2p$.com.webp2p.core.common.Enum;
},

setTimeout_ : function(tag, timer, milliSeconds) {
var me = this;
me.timer_ = setTimeout(function() {
me.onTimeout_(tag, me.timer_);
}, milliSeconds);
},
onTimeout_:function()
{
return true;
},
open : function() {
this.opened_ = true;
return true;
},

close : function() {
this.opened_ = false;
return true;
},

send : function(message) {
return false;
},

control : function(ctrl) {
return false;
},

getLastReceiveSpeed_ : function() {
return -1;
},
getUpdateReceiveSpeed_ : function(nowTime, waiting) {
return -1;
},
isActive_ : function() {
return this.active_;
},
isStable_ : function() {
return this.manager_.isStable_();
},

getManager_ : function() {
return this.manager_;
},
getName_ : function() {
return this.name_;
},
getRemoteId_ : function() {
return this.remoteId_;
},
getRemoteAddress_ : function() {
return this.remoteAddress_;
},
getRemoteType_ : function() {
return this.remoteType_;
},
getTerminalType_ : function() {
return this.terminalType_;
},
getType : function() {
return this.manager_.getType();
},
getTypeName_ : function() {
return this.manager_.getTypeName_();
},

setName : function(name) {
this.name_ = name;
},
setRemoteAddress_ : function(address) {
this.remoteAddress_ = address;
},
setRemoteType_ : function(type) {
this.remoteType_ = type;
},
setTerminalType_ : function(type) {
this.terminalType_ = type;
},
updateTerminalType_ : function() {
if (this.manager_.isStable_() || p2p$.com.webp2p.protocol.base.TERMINAL_TYPES.kTerminalTypeReserved != this.terminalType_) {
return;
}
this.terminalType_ = p2p$.com.webp2p.protocol.base.ManagerStatic.getTerminalType_(this.remoteType_ == "" ? this.name_ : this.remoteType_);
}
});
p2p$.ns('com.webp2p.protocol.cdn');

p2p$.com.webp2p.protocol.cdn.Manager = p2p$.com.webp2p.protocol.base.Manager.extend_({
kTimerTypeEncryptKey : 0,
kTimerTypePieceTn : 1,

opened_ : false,
encryptTryTimes_ : 0,
pieceTnTryTimes_ : 0,
sn_ :-1,

init : function(pool, evt) {
this._super(pool, evt, p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeCdn);
this.tag_="com::webp2p::protocol::cdn::Manager";
this.opened_ = false;
this.encryptTryTimes_ = 0;
this.pieceTnTryTimes_ = 0;
this.sn_ = -1;
},

open : function() {
this.close();
this.opened_ = true;
this.doOpen_();
},

doOpen_ : function() {
if (!this.opened_ || !(this.sessions_.length == 0)) {
return;
}
// add primary session
var nodeIndex = 0;
var gslbResponseData = this.pool_.getContext_().gslbData_;
var nodeList = gslbResponseData["nodelist"];
var item,name,locationUrl,session;
for ( var n = 0; n < nodeList.length; n++) {
item = nodeList[n];
name = item["name"];
locationUrl = item["location"];
if (this.pool_.getContext_().cdnMultiRequest_ && this.sessions_.length < this.pool_.getContext_().cdnMultiMaxHost_) {
session = new p2p$.com.webp2p.protocol.cdn.Session(this, locationUrl, nodeIndex++);
session.setName(name);
this.sessions_.push(session);
}
}
//打开cdn下载
for ( var n = 0; n < this.sessions_.length; n++) {
var session = this.sessions_[n];
session.open();
}
this.pool_.getContext_().cdnTotalNodeCount_ = this.sessions_.length;
return true;
},

sleep : function(numberMillis) {
var now = new Date();
var exitTime = now.getTime() + numberMillis;
while (true) {
now = new Date();
if (now.getTime() > exitTime) {
return;
}
}
},

close : function() {
this.opened_ = false;
for ( var n = 0; n < this.sessions_.length; n++) {
var session = this.sessions_[n];
session.close();
}
this.sessions_ = [];
return true;
},

checkGslbExpired_ : function() {
var num = 0;
for ( var n = 0; n < this.sessions_.length; n++) {
var session = this.sessions_[n];
if (session.gslbExpired_) {
num++;
}
}
if (num == this.sessions_.length) {
// gslb timeout error
this.getEventListener_().onGslbExpiredError_();
}
}
});
p2p$.ns('com.webp2p.protocol.cdn');

p2p$.com.webp2p.protocol.cdn.RequestRange = JClass.extend_({
downloading_ : null,
updated_ : false,
urgent_ : false,
urlOffset_ : 0,
segmentId_ : 0,
segmentSize_ : 0,
tryTimes_ : 0,
offset_ : 0,
length_ : 0,
dataUsed_ : 0,
pieceUsed_ : 0,
url_ : "",
startIndex_ : 0,
endIndex_ : 0,
pieces_ : null,

init : function() {
this.pieces_ = [];
this.downloading_ = false;
this.updated_ = false;
this.urgent_ = false;
this.urlOffset_ = -1;
this.segmentId_ = -1;
this.segmentSize_ = 0;
this.tryTimes_ = 0;
this.offset_ = 0;
this.length_ = 0;
this.dataUsed_ = 0;
this.pieceUsed_ = 0;
this.startIndex_ = 0;
this.endIndex_ = 0;
},

addPiece_ : function(piece) {
this.updated_ = true;

var exists = false;
for ( var n = 0; n < this.pieces_.length; n++) {
var item = this.pieces_[n];
if (item.type_ == piece.type_ && item.id_ == piece.id_) {
exists = true;
break;
}
}
if (!exists) {
this.pieces_.push(piece.fork());
}
return !exists;
},

preparePieces_ : function(forkRange) {
this.offset_ = 0;
this.length_ = 0;
this.pieces_.sort(function(item1, item2) {
return item1.offset_ - item2.offset_;
});
// std::sort(pieces_.begin(), pieces_.end());
if (this.segmentSize_ <= 0) {
return;
}

var lastIndex = -1;
var newSize = 0;
for ( var n = 0; n < this.pieces_.length; n++) {
var piece = this.pieces_[n];
if (piece.size_ <= 0) {
this.offset_ = 0;
this.length_ = 0;
return;
} else if (piece.completedTime_ > 0) {
// alreay completed, skip
continue;
}

if (lastIndex < 0) {
lastIndex = piece.index_;
this.offset_ = piece.offset_;
this.length_ = piece.size_;
newSize++;
this.startIndex_ = this.endIndex_ = lastIndex;
continue;
}
if (lastIndex + 1 != piece.index_) {
// multi segments
forkRange.addPiece_(piece);
continue;
}
this.endIndex_ = lastIndex = piece.index_;
this.length_ += piece.size_;
newSize++;
}

if (this.length_ >= this.segmentSize_ && this.urlOffset_ < 0) {
// full request
this.length_ = 0;
}
}
});
p2p$.ns('com.webp2p.protocol.cdn');

p2p$.com.webp2p.protocol.cdn.TIMEER_TYPE = {
kTimerTypeOpen : 0,
kTimerTypeMeta : 1,
kTimerTypeRangeDownload : 2
};

p2p$.com.webp2p.protocol.cdn.Session = p2p$.com.webp2p.protocol.base.Session.extend_({
metaUrl_ : null,
firstSegmentUrl_ : null,
metaData_ : null,
downloader_ : null,
downloadingRange_ : null,
pendingRanges_ : null,

primary_ : false,
metaTryTimes_ : 0,
activeTime_ : 0,
maxRangeDownloadTime_ : 0,
lastReceiveSpeed_ : 0,
lastStartReceiveTime_ : 0,
lastTotalReceiveBytes_ : 0,

init : function(mgr, remoteId, nodeIndex) {
this._super(mgr, remoteId);
this.tag_="com::webp2p::protocol::cdn::Session";
this.nodeIndex_ = nodeIndex;
this.activeTime_ = 0;
this.metaTryTimes_ = 0;
this.maxRangeDownloadTime_ = 30 * 1000; // ms
this.lastReceiveSpeed_ = 0;
this.lastStartReceiveTime_ = 0;
this.lastTotalReceiveBytes_ = 0;
this.metaData_ = new p2p$.com.webp2p.core.supernode.MetaData();
var mainMeta = this.manager_.getPool_().getMetaData_();
this.metaUrl_ = new p2p$.com.common.Url();
this.firstSegmentUrl_ = new p2p$.com.common.Url();
this.pendingRanges_ = new p2p$.com.common.Map();
if(mainMeta.finalUrl_==remoteId)
{
// primary session
this.primary_ = true;
this.metaData_ = mainMeta;
this.lastReceiveSpeed_ = this.metaData_.lastReceiveSpeed_;
if (this.metaData_.segments_.length > 0) {
this.firstSegmentUrl_.fromString_(this.metaData_.segments_[0].mediaUrl_);
}
}else {
this.primary_ = false;
this.metaData_.verifyMethod_ = mainMeta.verifyMethod_;
this.metaData_.rangeParamsSupported_ = mainMeta.rangeParamsSupported_;
this.metaData_.sourceUrl_ = this.remoteId_;
}
this.metaUrl_.fromString_(this.metaData_.sourceUrl_);
this.remoteAddress_ = (this.primary_ ? "*" : "") + (this.metaUrl_.host_ + ":") + ((this.metaUrl_.port_ == 0) ? 80 : this.metaUrl_.port_);
this.metaData_.sourceServer_ = this.metaUrl_.host_ + ":" + ((this.metaUrl_.port_ == 0) ? 80 : this.metaUrl_.port_);
this.downloadingRange_ = new p2p$.com.webp2p.protocol.cdn.RequestRange();
},

open : function() {
if (this.active_) {
return true;
}
this._super();
if (this.metaData_.finalUrl_ != "") {
this.active_ = true;
// rank first
if (this.lastReceiveSpeed_ <= 0) {
this.lastReceiveSpeed_ = 200000;
}
this.lastReceiveSpeed_ = this.metaData_.lastReceiveSpeed_;
this.manager_.getEventListener_().onProtocolSessionOpen_(this);
} else {
// delay open to avoid network congestion
this.metaTryTimes_ = -1;
this.setTimeout_(p2p$.com.webp2p.protocol.cdn.TIMEER_TYPE.kTimerTypeMeta, this.timer_, 5 * 1000);
}
return true;
},

cleanAllPending_ : function() {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} [{1}]Clean all pending requests, session({2})",this.tag_,p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.manager_.getPool_().getMetaData_().type_), this.remoteAddress_));

// stop timer
if (this.timer_ != null) {
clearTimeout(this.timer_);
this.timer_ = null;
}
if (this.downloader_ != null) {
this.downloader_.log_("clean");
this.downloader_.close();
this.downloader_ = null;
}
this.pendingRanges_.clear();
this.downloadingRange_.downloading_ = false;
},

downloadMeta_ : function() {
this.activeTime_ = this.global_.getMilliTime_();
if (this.downloader_ != null) {
return;
}
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::downloadMeta_ name({1})",this.tag_,this.name_));
this.downloader_ = new p2p$.com.loaders.HttpDownLoader({url_:this.metaData_.sourceUrl_, scope_:this, tag_:"cdn::meta"});
this.downloader_.load_();
// set meta timer
this.setTimeout_(p2p$.com.webp2p.protocol.cdn.TIMEER_TYPE.kTimerTypeMeta, this.timer_, 10 * 1000);
},

downloadNextRange_ : function(retry) {
if (this.downloader_ != null) {
return;
}
if (!retry) {
if (this.pendingRanges_.empty()) {
// completed
return;
}
var forkRange = new p2p$.com.webp2p.protocol.cdn.RequestRange();
this.downloadingRange_ = this.pendingRanges_.element(0).value;
this.downloadingRange_.preparePieces_(forkRange);
if (forkRange.pieces_.length == 0) {
this.pendingRanges_.clear();
}
}

var requestUrl = this.downloadingRange_.url_;
this.downloadingRange_.downloading_ = true;
this.downloadingRange_.dataUsed_ = 0;
this.downloadingRange_.pieceUsed_ = 0;
if (this.downloadingRange_.length_ > 0) {
var offsetBegin = Math.max(this.downloadingRange_.urlOffset_, 0) + this.downloadingRange_.offset_;
var offsetEnd = offsetBegin + this.downloadingRange_.length_ - 1;
if (this.manager_.getPool_().getMetaData_().rangeParamsSupported_) {
if (requestUrl.indexOf('?') == -1) {
requestUrl += "?";
} else {
requestUrl += "&";
}
requestUrl += this.strings_.format("rstart={0}&rend={1}", offsetBegin, offsetEnd);
}
else {
this.requestRange_ = this.strings_.format("bytes={0}-{1}", offsetBegin, offsetEnd);
}
}

// addtional appid
if (requestUrl.indexOf("&appid=") == -1 && requestUrl.indexOf("?appid=") == -1) {
var externalAppId = this.strings_.urlEncode_(this.manager_.getPool_().getEnviroment_().externalAppId_);
var moduleVersion = this.strings_.fromNumber(p2p$.com.selector.Module.getkH5FullVersion_());
if (requestUrl.indexOf('?') == -1) {
requestUrl += "?";
} else {
requestUrl += "&";
}
requestUrl += this.strings_.format("appid={0}&cde={1}", externalAppId, moduleVersion);
}
//
// // p1,p2,p3 parameters, cdn server may take those parameters
if (this.manager_.getPool_().getContext_().addtionalParams_ != "" && requestUrl.indexOf("&p1=") == -1 && requestUrl.indexOf("?p1=") == -1) {
if (requestUrl.indexOf('?') == -1) {
requestUrl += "?";
} else {
requestUrl += "&";
}
requestUrl += this.manager_.getPool_().getContext_().addtionalParams_;
}

requestUrl += this.strings_.format("&ajax={0}", 1);
//
this.lastTotalReceiveBytes_ = 0;
this.lastStartReceiveTime_ = this.global_.getMilliTime_();
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::downloadNextrange_ url({1})",this.tag_,requestUrl));
this.manager_.sn_++;
var params={};
params["err"]=0;
params["sn"]=this.manager_.sn_;
this.manager_.eventListener_.sendStatus_({type:"VIDEO.TS.LOADING",params:params});
this.downloader_ = new p2p$.com.loaders.HttpDownLoader({url_:requestUrl, scope_:this,type_:"arraybuffer", tag_:"cdn::range-data"});
this.downloader_.setInfo_(this.downloadingRange_);
if (this.requestRange_) {
this.downloader_.setRequsetRange_(this.requestRange_);
}
this.downloader_.load_();
this.setTimeout_(p2p$.com.webp2p.protocol.cdn.TIMEER_TYPE.kTimerTypeRangeDownload, this.timer_, this.maxRangeDownloadTime_);
},

parseMetaResponse_ : function(downloader) {
if (!this.metaData_.load(downloader.responseData_, downloader.totalUsedTime_)) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}[{1}]Parse meta response failed,url({2}),channel({3}),size({4})",this.tag_,p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.manager_.getPool_().getMetaData_().type_),this.metaData_.sourceUrl_, this.manager_.getPool_().getMetaData_().storageId_,downloader.responseData_.length));
return false;
}
return true;
},

onOpenTimeout_ : function(errorCode) {
this.manager_.getEventListener_().onProtocolSessionOpen_(this);
},

onMetaTimeout_ : function(errorCode) {
if (this.downloader_ != null) {
this.downloader_.log_("timeout");
this.downloader_.close();
this.downloader_ = null;
}
if (++this.metaTryTimes_ != 0) {
var tryTimes = this.metaTryTimes_ < 3 ? "retry again ..." : "meta failed";
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0} [{1}]Meta timeout for url{2},channel({3}),try times({4}),result({5})",this.tag_,p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.manager_.getPool_().getMetaData_().type_),this.metaData_.sourceUrl_,this.manager_.getPool_().getMetaData_().storageId_,this.metaTryTimes_,tryTimes));
}
if (this.metaTryTimes_ < 3) {
this.downloadMeta_();
}
},

onRangeDownloadTimeout_ : function(errorCode) {

if (this.downloader_ != null) {
this.downloader_.log_("timeout");
this.downloader_.close();
this.downloader_ = null;
}

// retry by scheduler ...
this.downloadingRange_.downloading_ = false;
this.downloadingRange_.tryTimes_++;
this.lastReceiveSpeed_ = 0;
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0} [{1}] Range download timeout, segment({2}), items({3})",this.tag_,p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.manager_.getPool_().getMetaData_().type_), this.downloadingRange_.segmentId_, this.downloadingRange_.pieces_.length));

var segmentIndex = -1;
if (this.downloadingRange_.segmentId_ >= 0) {
segmentIndex = this.metaData_.getSegmentIndexById_(this.downloadingRange_.segmentId_);
}
if (segmentIndex < 0 || segmentIndex >= this.metaData_.segments_.length) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::onRangeDownloadTimeout segment({1}) not found",this.tag_,this.downloadingRange_.segmentId_));
return null;
}
var segment = this.metaData_.segments_[segmentIndex];
for ( var k = 0; k < segment.pieces_.length; k++) {
// setting receiveStartTime_ = 0
// waiting schedule
var piece = segment.pieces_[k];
if (piece.completedTime_ > 0) {
continue;
}
piece.receiveStartTime_ = 0;
}
},

// override protocol::base::Session
onTimeout_ : function(tag, timer, errorCode) {
if (timer != this.timer_ || !this.opened_) {
return;
}

// stop timer
if (this.timer_) {
clearTimeout(this.timer_);
this.timer_ = null;
}

switch (tag) {
case p2p$.com.webp2p.protocol.cdn.TIMEER_TYPE.kTimerTypeOpen:
this.onOpenTimeout_(errorCode);
break;
case p2p$.com.webp2p.protocol.cdn.TIMEER_TYPE.kTimerTypeMeta:
this.onMetaTimeout_(errorCode);
break;
case p2p$.com.webp2p.protocol.cdn.TIMEER_TYPE.kTimerTypeRangeDownload:
this.onRangeDownloadTimeout_(errorCode);
break;
default:
break;
}
},

// override core::supernode::HttpDownloaderListener
onHttpDownloadData_ : function(downloader) {
var handled = false;
if (this.downloader_ != downloader) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onHttpDownloadData type({1}),tag({2}),url({3}),channel({4}),code({5}),detail({6}),size({7})",this.tag_,p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.manager_.getPool_().getMetaData_().type_),downloader.tag_,downloader.url_,this.manager_.getPool_().getMetaData_().storageId_,downloader.responseCode_,downloader.responseDetails_,downloader.responseData_.length));
return handled;
}
if (downloader.tag_ == "cdn::range-data") {

}
},
onMetaCompleted_ :function(downloader)
{
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onMetaCompleted, channel({1})",this.tag_,this.manager_.getPool_().getMetaData_().storageId_));
if (!downloader.successed_ || downloader.responseCode_ < 200 || downloader.responseCode_ >= 300) {
// waiting for timeout and retry ...
return;
}
this.metaData_.lastReceiveSpeed_ = downloader.transferedSpeed_;
this.lastReceiveSpeed_ = downloader.transferedSpeed_;
this.lastTotalReceiveBytes_ = downloader.transferedBytes_;

// stop timer
if (this.timer_) {
clearTimeout(this.timer_);
this.timer_ = null;
}
// parse meta data
this.metaData_.storageId_ = this.manager_.getPool_().getMetaData_().storageId_;
this.metaData_.finalUrl_ = downloader.url_;
if (!this.parseMetaResponse_(downloader)) {
return;
}
if (this.metaData_.segments_.length > 0) {
this.firstSegmentUrl_.fromString_(this.metaData_.segments_[0].mediaUrl_);
}
this.active_ = true;
this.downloadNextRange_(false);
this.manager_.getEventListener_().onProtocolSessionOpen_(this);
},
onRangeDataCompleted_ :function(downloader){
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onRangeDataCompleted_ tag({1}) ",this.tag_,downloader.tag_));
this.downloadingRange_.downloading_ = false;
var params={};
params["err"]=downloader.responseCode_;
params["utime"]=downloader.totalUsedTime_;
params["sn"]=this.manager_.sn_;
if (downloader.responseCode_ < 200 || downloader.responseCode_ >= 300) {
this.lastReceiveSpeed_ = 0;
params["err"]=30001;
this.manager_.eventListener_.sendStatus_({type:"VIDEO.PLAY.ERROR",code:downloader.responseCode_,params:params});
if (downloader.responseCode_ == 403) {
this.gslbExpired_ = true;
this.manager_.checkGslbExpired_();
}
return;
}
this.manager_.eventListener_.sendStatus_({type:"VIDEO.TS.LOADED",params:params});
this.gslbExpired_ = false;
this.lastReceiveSpeed_ = downloader.transferedSpeed_;
this.lastTotalReceiveBytes_ = downloader.transferedBytes_;
// stop timer
if (this.timer_) {
clearTimeout(this.timer_);
this.timer_ = null;
}

var dataOffset = this.downloadingRange_.dataUsed_;
var message = new p2p$.com.webp2p.protocol.base.Message();
while (this.downloadingRange_.pieceUsed_ < this.downloadingRange_.pieces_.length) {
var piece = this.downloadingRange_.pieces_[this.downloadingRange_.pieceUsed_];
if (piece.size_ <= 0) {
if (piece.checksum_ != 0) {
// maybe AD
break;
}
} else if (piece.completedTime_ > 0) {
// already completed
if (this.downloadingRange_.length_ > 0) {
dataOffset += piece.size_;
}
this.downloadingRange_.dataUsed_ += piece.size_;
this.downloadingRange_.pieceUsed_++;
continue;
}

if (this.downloadingRange_.length_ <= 0) {
dataOffset = piece.offset_;
}
if ((dataOffset + piece.size_) > downloader.responseData_.length) {
// incompleted
break;
}

var responseData = new p2p$.com.webp2p.protocol.base.ResponseDataItem();
responseData.segmentId_ = this.downloadingRange_.segmentId_;
responseData.pieceType_ = piece.type_;
responseData.pieceId_ = piece.id_;
responseData.pieceKey_ = piece.key_;
if (piece.size_ <= 0) {
responseData.data_ = downloader.responseData_;
} else {
responseData.data_ = downloader.responseData_.subarray(dataOffset, piece.size_ + dataOffset);
}

if (this.downloadingRange_.length_ > 0) {
dataOffset += piece.size_;
}
this.downloadingRange_.dataUsed_ += piece.size_;
this.downloadingRange_.pieceUsed_++;
piece.completedTime_ = this.global_.getMilliTime_();
message.responses_.push(responseData);
}
if (message.responses_.length != 0) {
this.manager_.getEventListener_().onProtocolSessionMessage_(this, message);
}
},
onHttpDownloadCompleted_ : function(downloader) {
if (this.downloader_ != downloader) {
return;
}
this.downloader_ = null;
this.activeTime_ = this.global_.getMilliTime_();
if (downloader.tag_ == "cdn::meta") {
this.onMetaCompleted_(downloader);
return;
}
if (downloader.tag_ == "cdn::range-data") {
this.onRangeDataCompleted_(downloader);
return;
}
},

close : function() {
this._super();
if (this.timer_ != null) {
clearTimeout(this.timer_);
this.timer_ = null;
}
if (this.downloader_ != null) {
this.downloader_.log_("clean");
this.downloader_.close();
this.downloader_ = null;
}
return true;
},

send : function(message) {
var emptyResponseCount = 0;
var meta = this.metaData_.directMetaMode_ ? this.metaData_ : this.manager_.getPool_().getMetaData_();
var globalMeta = this.manager_.getPool_().getMetaData_();
// // check expire segments
if (this.downloadingRange_.downloading_ && this.downloadingRange_.segmentId_ < meta.urgentSegmentId_) {
// cancel
if (this.downloader_ != null) {
this.downloader_.log_("cancel");
this.downloader_.close();
this.downloader_ = null;
}
this.downloadingRange_.downloading_ = false;
}
for ( var n = 0; n < message.requests_.length; n++) {
var item = message.requests_[n];
if (item.pieceId_ == -1) {
// clean all requests
this.lastReceiveSpeed_ = -1;
this.lastStartReceiveTime_ = 0;
this.lastTotalReceiveBytes_ = 0;
this.cleanAllPending_();
return true;
}

var index = -1;
if (item.segmentId_ >= 0) {
index = meta.getSegmentIndexById_(item.segmentId_);
} else {
index = meta.getSegmentIndexByPieceId_(item.pieceType_, item.pieceId_);
}
if (index < 0 || index >= meta.segments_.length) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0} [{1}]Send piece from session({2}) not found, type({3}), id({4}), ignore it!",this.tag_,p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.manager_.getPool_().getMetaData_().type_), this.remoteAddress_,p2p$.com.webp2p.core.common.Enum.getPieceTypeName_(item.pieceType_), item.pieceId_));
emptyResponseCount++;
continue;
}
var segment = meta.segments_[index];
var pieceIndex = segment.getPieceIndex_(item.pieceType_, item.pieceId_);
if (pieceIndex < 0 || pieceIndex >= segment.pieces_.length) {
emptyResponseCount++;
continue;
}

var piece = segment.pieces_[pieceIndex];
// if( this.downloadingRange_.downloading_ && this.downloadingRange_.segmentId_ == segment.id_ && this.downloadingRange_.length_ <= 0 )
// {
// // full range request, add piece is ok
// if( !this.downloadingRange_.addPiece_(piece) )
// {
// emptyResponseCount ++;
// }
// continue;
// }
//
var range = this.pendingRanges_.get(index);
if (typeof range == 'undefined' || range == null) {
range = new p2p$.com.webp2p.protocol.cdn.RequestRange();
this.pendingRanges_.set(index, range);
}
range.urgent_ = item.urgent_;
range.urlOffset_ = segment.urlOffset_;
range.segmentId_ = segment.id_;
range.segmentSize_ = segment.size_;
if (range.url_ == "") {
// range.url_ = segment.mediaUrl_;
var backupIndex = this.nodeIndex_ - 1;
var isSameSource = (this.primary_ && globalMeta.sourceServer_ == "") || (globalMeta.sourceServer_ == this.metaData_.sourceServer_);
if (isSameSource || this.metaData_.directMetaMode_) {
range.url_ = segment.mediaUrl_;
} else if (p2p$.com.webp2p.core.common.META_DATA_TYPE.kMetaDataTypeLive == globalMeta.type_ && !globalMeta.directMetaMode_ && backupIndex >= 0
&& segment.moreMediaUrls_ && backupIndex < segment.moreMediaUrls_.length && segment.moreMediaUrls_[backupIndex]) {
range.url_ = segment.moreMediaUrls_[backupIndex];
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} [{1}]Using backup url from meta, index({2}), url({3})",this.tag_, p2p$.com.webp2p.core.common.Enum.getMetaTypeName_(this.manager_.getPool_().getMetaData_().type_), backupIndex, range.url_));
} else {
var newUrl = new p2p$.com.common.Url();
newUrl.fromString_(segment.mediaUrl_);
var isSamePort = newUrl.port_ == this.firstSegmentUrl_.port_ || (newUrl.port_ == 0 && this.firstSegmentUrl_.port_ == 80)
|| (newUrl.port_ == 80 && this.firstSegmentUrl_.port_ == 0);
if (newUrl.host_ != this.firstSegmentUrl_.host_ || !isSamePort) {
newUrl.host_ = this.firstSegmentUrl_.host_;
newUrl.port_ = this.firstSegmentUrl_.port_;

if (this.firstSegmentUrl_.params_.has("path")) {
newUrl.params_.set("path", this.firstSegmentUrl_.params_.get("path"));
}

if (this.firstSegmentUrl_.params_.has("proxy")) {
newUrl.params_.set("proxy", this.firstSegmentUrl_.params_.get("proxy"));
}

range.url_ = newUrl.toString();
} else {
range.url_ = segment.mediaUrl_;
}
}
}
if (!range.addPiece_(piece)) {
emptyResponseCount++;
}
}
this.downloadNextRange_(false);
return true;
},

getLastReceiveSpeed_ : function() {
return -1;
},

getUpdateReceiveSpeed_ : function(nowTime, waiting) {
if (this.pendingRanges_.isEmpty() && !this.downloadingRange_.downloading_ && !waiting) {
return this.lastReceiveSpeed_;
}

var timeUsed = this.lastStartReceiveTime_ > 0 ? (nowTime - this.lastStartReceiveTime_) : 0;
if (timeUsed > 1000) {
this.lastReceiveSpeed_ = this.lastTotalReceiveBytes_ * 1000 / timeUsed;
}
return this.lastReceiveSpeed_;
}
});
p2p$.ns('com.webp2p.protocol.webrtc');

p2p$.com.webp2p.protocol.webrtc.ManagerStatic = {
kTimerTypeTracker : 1,
kTimerTypeSession : 2,
kTimerTypeAsyncPeers : 3,
kTimerTypeOnRegister : 100,
kTimerTypeOnHeartBeat : 101,
kTimerTypeOnQueryPeerList : 102,
};

p2p$.com.webp2p.protocol.webrtc.Manager = p2p$.com.webp2p.protocol.base.Manager.extend_({
opened_ : false,
websocket_ : null,
queryWebrtcServerTimer_ : null,
heartBeatTimer_ : null,
queryPeerListTimer_ : null,
peers_ : null,
peerMaxConnectingTime_ : 0,
activeSessionCount_ : 0,
ip_:null,//"ws://10.75.227.140:3852",
tag_:"com::webp2p::protocol::webrtc::Manager",

init : function(pool, evt) {
this._super(pool, evt, p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeWebrtc);
this.peers_ = new p2p$.com.common.Map();
this.peerMaxConnectingTime_ = 100 * 1000;
this.activeSessionCount_ = 0;
this.webrtcRegisterEnabled_ = true;
this.webrtcRegistered_ = false;
},

open : function() {
this.close();
this.opened_ = true;
this.activeTime_ = this.global_.getMilliTime_();
this.id_ = this.strings_.format("{0}{1}{2}{3}", Math.floor(Math.random() * (1000 + 1)), Math.floor(Math.random() * (1000 + 1)),
Math.floor(Math.random() * (1000 + 1)), this.global_.getMilliTime_());

if (this.pool_.getContext_().p2pHeartbeatInterval_ > 0) {
this.heartbeatInterval_ = this.pool_.getContext_().p2pHeartbeatInterval_;
}
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::open id({1})",this.tag_,this.id_));
this.queryFromWebrtcServer_();
this.sessionTimer_ = this.setTimeout_(p2p$.com.webp2p.protocol.webrtc.ManagerStatic.kTimerTypeSession, this.sessionTimer_, 1 * 1000);
return true;
},

queryFromWebrtcServer_ : function() {
var _serverUrl = this.pool_.getContext_().webrtcServerHost_;
if(this.ip_!=null){
_serverUrl = this.ip_;
}
this.websocket_ = new WebSocket(_serverUrl);
var myFunName = this.strings_.getFunName(arguments.callee.toString());
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::{1} open webrtc server ({2}) ..."
,this.tag_
,myFunName
,this.pool_.getContext_().webrtcServerHost_));
var _me = this;
this.websocket_.onopen = function(evt) {
_me.onWebSocketOpen_(evt);
};
this.websocket_.onclose = function(evt) {
_me.onWebSocketClose_(evt);
};
this.websocket_.onerror = function(evt) {
_me.onWebSocketClose_(evt);
};
this.websocket_.onmessage = function(message) {
_me.onWebSocketMessage_(message);
};
},

onWebSocketOpen_ : function(evt) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::{1} Start register webrtc server ({1}) ...",this.tag_,this.pool_.getContext_().webrtcServerHost_));
this.registerWebrtcServer_();
},

onWebSocketClose_ : function(evt) {
var myFunName = this.strings_.getFunName(arguments.callee.toString());
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::{1} webrtc({1}) close ..."
,this.tag_
,myFunName
,this.pool_.getContext_().webrtcServerHost_));
},

onWebSocketMessage_ : function(evt) {
// var me = this;
var message = JSON.parse(evt.data);
var myFunname=this.strings_.getFunName(arguments.callee.toString());
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::{1} data->{2}",this.tag_,myFunname,evt.data));
switch (message.method) {
case 'registerResponse':
this.onRegisterResponse_(message);
break;
case 'heartbeatResponse':
this.onHeartbeatResponse_(message);
break;
case 'queryPeerListResponse':
this.onQueryPeerListResponse_(message);
break;
case 'proxyDataRequest':
this.onProxyDataRequest_(message);
break;
case 'proxyDataResponse':
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::{1} proxy data response code: {2}",this.tag_,myFunname,message.errorCode));
break;
default:
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::{1} unknown method: {3}",this.tag_,myFunname,message.method));
break;
}
},

onTimeout_ : function(tag, timer, errorCode) {
switch (tag) {
case p2p$.com.webp2p.protocol.webrtc.ManagerStatic.kTimerTypeTracker:
this.onTimeout_();
break;
case p2p$.com.webp2p.protocol.webrtc.ManagerStatic.kTimerTypeSession:
this.onSessionTimeout_();
break;
case p2p$.com.webp2p.protocol.webrtc.ManagerStatic.kTimerTypeAsyncPeers:
//onAsyncPeersTimeout();
break;
case p2p$.com.webp2p.protocol.webrtc.ManagerStatic.kTimerTypeOnRegister:
this.onRegisterTimeout_();
break;
case p2p$.com.webp2p.protocol.webrtc.ManagerStatic.kTimerTypeOnHeartBeat:
this.onHeartBeatTimeout_();
break;
case p2p$.com.webp2p.protocol.webrtc.ManagerStatic.kTimerTypeOnQueryPeerList:
this.onQueryPeerListTimeout_();
break;
default:
break;
}
},

getSelfInfo_ : function() {
var version = this.strings_.format("{0}.{1}.{2}", this.module_.kH5MajorVersion,this.module_.kH5MinorVersion, this.module_.kH5BuildNumber);
var client = {
clientId : this.id_,
clientModule : this.pool_.getEnviroment_().browserType_,
clientVersion : version,
protocolVersion : 1.0,
playType : this.pool_.getContext_().playType_,
p2pGroupId : this.pool_.getMetaData_().p2pGroupId_,
osPlatform : encodeURIComponent(this.pool_.getContext_().osType_),
hardwarePlatform : this.pool_.getEnviroment_().deviceType_ == "Unkonwn" ? encodeURIComponent(this.pool_.getContext_().osType_) : this.pool_
.getEnviroment_().deviceType_
};
return client;
},

onSessionTimeout_ : function() {
this.checkPeerSessions_();
this.sessionTimer_ = this.setTimeout_(p2p$.com.webp2p.protocol.webrtc.ManagerStatic.kTimerTypeSession, this.sessionTimer_, 1 * 1000);
},

onRegisterTimeout_ : function() {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Register timeout, try again ...",this.tag_));
},

onHeartBeatTimeout_ : function() {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::HeartBeat timeout, try again ...",this.tag_));
},

onQueryPeerListTimeout_ : function() {
//		P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Query peer list timeout, try again ...",this.tag_));
this.queryPeerList_();
},

onHeartbeatResponse_ : function(message) {
},

registerWebrtcServer_ : function() {
var req = {
method : "registerRequest",
streamId : this.pool_.getMetaData_().p2pGroupId_,
nodeInfo : {
ver : this.pool_.getContext_().moduleVersion_,
pos : (111 >= 0 ? 111 : 0),
neighbors : 0,
isp : this.pool_.getContext_().isp_,
country : this.pool_.getContext_().country_,
province : this.pool_.getContext_().province_,
city : this.pool_.getContext_().city_,
area : this.pool_.getContext_().area_,
protocol : p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeWebrtc
},
localTime : this.global_.getMilliTime_()
};
var mst = p2p$.com.webp2p.protocol.webrtc.ManagerStatic;
this.queryWebrtcServerTimer_ = this.setTimeout_(mst.kTimerTypeOnRegister, this.queryWebrtcServerTimer_, 5000);
this.beginRegisterTime_ = this.global_.getMilliTime_();
this.sendMessage_(req);
},

onRegisterResponse_ : function(message) {
var myFunName=this.strings_.getFunName(arguments.callee.toString());
if (message.errorCode !== 0) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::{1} response failed, errorCode({2})",this.tag_,myFunName,message.errorCode));
return;
}
// if register success, cancel timer
if (this.queryWebrtcServerTimer_) {
clearTimeout(this.queryWebrtcServerTimer_);
this.queryWebrtcServerTimer_ = null;
}
this.pool_.getContext_().webrtcServerConnectedTime_ = this.global_.getMilliTime_() - this.beginRegisterTime_;
this.pool_.getContext_().p2pWebrtcPeerId_ = message.peerId;

this.heartBeat_();
this.queryPeerList_();
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::{1} response success, peerid({2})",this.tag_,myFunName,message.peerId));
},

heartBeat_ : function() {
//		this.setTimeout_(p2p$.com.webp2p.protocol.webrtc.ManagerStatic.kTimerTypeOnHeartBeat, this.heartBeatTimer_, 5000);
},

queryPeerList_ : function() {
var userparam = {"root": { "langtype": "3" }};
userparam=this.strings_.base64Encode_(JSON.stringify(userparam));
var queryPeerListRequest = {
method : "queryPeerListRequest",
limit : 10,
userparam:userparam
};
this.queryPeerListTimer_ = this.setTimeout_(p2p$.com.webp2p.protocol.webrtc.ManagerStatic.kTimerTypeOnQueryPeerList, this.queryPeerListTimer_,10 * 1000);
this.sendMessage_(queryPeerListRequest);
},

onQueryPeerListResponse_ : function(message) {
var myfunname = this.strings_.getFunName(arguments.callee.toString());
var peerResponseCount = 0;
var newPeerCount = 0;
var itemId = "";
var _arr = message.items;
if (_arr.length == 0) {
P2P_ULOG_WARNING(P2P_ULOG_FMT("{0}::{1} Query peer list responsed, peerList.length = 0",this.tag_,myfunname));
}
for ( var i = 0; i < _arr.length; i++) {
var peerItem = _arr[i];
itemId = peerItem.peerId;
var isFind = this.peers_.find(itemId);
var info;
if (!isFind) {
if (this.peers_.size() >= this.maxActiveSession_ * 2) {
break;
}
info = new p2p$.com.webp2p.protocol.webrtc.Peer(this);
this.peers_.set(itemId, info);
newPeerCount++;
info.fromServer_ = true;
} else {
info = this.peers_.get(itemId);
}
if (info != null) {
info.load(peerItem);
}

}
peerResponseCount = _arr.length;
this.pool_.getContext_().webrtcTotalNodeCount_ = this.peers_.size();
if (this.webrtcRegisterEnabled_ && !this.webrtcRegistered_) {
this.webrtcRegistered_ = true;
this.eventListener_.onProtocolManagerOpen_(this, 0);
}

if (newPeerCount >= 0) {
this.checkPeerSessions_();
}

P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::{1} Query peer list successfully, load {2} peer(s), {3} peer(s) now, channel({4})"
,this.tag_
,myfunname
,peerResponseCount
,this.peers_.size()
,this.pool_.getMetaData_().storageId_));
},

checkPeerSessions_ : function() {
var nowTime = this.global_.getMilliTime_();
var updatedPeerCount = 0;

// clean connect failed peers
for ( var n = 0; n < this.peers_.length; n++) {
var elem = this.peers_.element(n);
var peer = elem.value;
if (!peer.isActive_(nowTime, this.peerMaxConnectingTime_) && (peer.totalConnectingTimes_ > 5 || peer.disconnectTimes_ > 3 || !peer.fromServer_)) {
if (peer.session_ != null) {
this.pool_.getContext_().webrtcTotalNodeCount_ = this.peers_.size();
}
peer.disconnect();
this.peers_.erase(elem.key);
updatedPeerCount++;
}
}
this.activeSessionCount_ = 0;
for ( var n = 0; n < this.peers_.length; n++) {
var elem = this.peers_.element(n);
var peer = elem.value;
if (peer.session_ == null) {
continue;
}
if (!peer.isActive_(nowTime, this.peerMaxConnectingTime_)) {
this.pool_.getContext_().webrtcTotalNodeCount_ = this.peers_.size();
peer.disconnect();
updatedPeerCount++;
} else {
this.activeSessionCount_++;
}
}

if (this.activeSessionCount_ >= this.maxActiveSession_) {
return;
}
var connectablePeers = [];
for ( var n = 0; n < this.peers_.length; n++) {
var elem = this.peers_.element(n);
var peer = elem.value;
if (peer.isActive_(nowTime, this.peerMaxConnectingTime_)) {
continue;
}
if (!peer.fromServer_) {
// passive peer
continue;
} else if (peer.lastConnectTime_ + 60 * 1000 > nowTime) {
// sleep
continue;
}
connectablePeers.push(peer);
}
for ( var n = 0; n < connectablePeers.length; n++) {
var peer = connectablePeers[n];

// try connect peer
if (!peer.connect()) {
// failed
continue;
}

this.activeSessionCount_++;
if (this.activeSessionCount_ >= this.maxActiveSession_) {
break;
}
}
},

onProxyDataRequest_ : function(message) {
if (typeof (message.data) == 'string') {
message.data = JSON.parse(message.data);
}
switch (message.data.action) {
case 'connectRequest':
this.onRemotePeerConnectRequest_(message.sourcePeerId, message.data);
break;
case 'connectResponse':
this.onRemotePeerConnectResponse_(message.sourcePeerId, message.data);
break;
default:
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Remote peer unknown action: {1}",this.tag_,message.data.action));
break;
}
},

onRemotePeerConnectResponse_ : function(peerId, message) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Recveive a connect response from {1}",this.tag_,peerId));
var itemId = peerId;
var isFind = this.peers_.find(itemId);
var info;
if (!isFind) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Receive a connect response from {1}, but not in the peers",this.tag_,peerId));
return;
} else {
info = this.peers_.get(itemId);
}
if (info != null) {
info.load2(message);
}
info.acceptAnswer_(message.iceCandidates, message.sdpDescriptions);
},

onRemotePeerConnectRequest_ : function(peerId, message) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Receive a connect request from {0}",this.tag_,peerId));
var itemId = peerId;
var isFind = this.peers_.find(itemId);
var info = null;
if (!isFind) {
info = new p2p$.com.webp2p.protocol.webrtc.Peer(this);
this.peers_.set(itemId, info);
info.fromServer_ = false;
} else {
info = this.peers_.get(itemId);
}
if (info != null) {
info.load2(message);
}
info.fromServer_ = false;
this.pool_.getContext_().webrtcTotalNodeCount_ = this.peers_.size();
info.remoteId_ = peerId;
info.iceServers_ = message.iceServers;
info.remoteIceCandidates_ = message.iceCandidates;
info.remoteSdpDescriptions_ = message.sdpDescriptions;
info.connect();
},
sendMessage_ : function(message) {
if (typeof (message) != 'string') {
message = JSON.stringify(message);
}
if (this.websocket_) {
this.websocket_.send(message);
}
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::Send message channel({1}), msg:{2}",this.tag_,this.pool_.getMetaData_().storageId_, message));
},

closeChannel_ : function(session) {
for ( var n = 0; n < this.peers_.length; n++) {
var elem = this.peers_.element(n);
var peer = elem.value;
if (session == peer.session_) {
this.pool_.getContext_().websocketTotalNodeCount_ = this.peers_.size();
this.eventListener_.onProtocolSessionClose_(session);
break;
}
}
},

close : function() {
this.opened_ = false;
if (this.websocket_) {
this.websocket_.close();
this.websocket_ = null;
}

if (this.queryPeerListTimer_) {
clearTimeout(this.queryPeerListTimer_);
this.queryPeerListTimer_ = null;
}

if (this.sessionTimer_) {
clearTimeout(this.sessionTimer_);
this.sessionTimer_ = null;
}
if (this.queryWebrtcServerTimer_) {
clearTimeout(this.queryWebrtcServerTimer_);
this.queryWebrtcServerTimer_ = null;
}
for ( var n = 0; n < this.peers_.length; n++) {
var elem = this.peers_.element(n);
var peer = elem.value;
peer.disconnect();
}
this.peers_.clear();
return true;
}
});
p2p$.ns('com.webp2p.protocol.webrtc');
p2p$.com.webp2p.protocol.webrtc.Packet = {
peerIds_ : [],

// encode
encode : function(message, peerIdsList, type) {
// this.sendrangNum++;
var _sendDataSct = [ {
"sequence_4" : 0
},// 0
{
"dataLength_4" : 0
},// 1
{
"rangeCount_4" : 0
},// 2
{
"rangeItems" : [ [ {
"type_2" : 123
}, {
"start_8" : 234
}, {
"end_4" : 345
} ] ]
},// 3
{
"requestCount_4" : 0
},// 4
{
"requestItems" : [ [ {
"type_2" : 0
}, {
"start_8" : 1411033199
}, {
"cks_4" : 57473
} ] ]
},// 5
{
"responseCount_4" : 0
},// 6
{
"responseItems" : [ [ {
"type_2" : 0
}, {
"start_8" : 1411033199
}, {
"streamLength_4" : 57473
}, {
"stream_d" : null
} ] ]
},// 7
{
"peerCount_4" : 1
},// 连接节点数
{
"peerItems" : [ [ {
"head_4" : 0
}, {
"URL_utf" : "ws://202.103.4.52:34567/*****"
} ] ]
} // 9
];

// 3
var _rangeItems = [];
var _start;
var _end;
for ( var n = 0; n < message.ranges_.length; n++) {
var item = message.ranges_[n];
_start = item.start_;
_end = item.count_;
_rangeItems.push([ {
"type_2" : item.type_
}, {
"start_8" : _start
}, {
"end_4" : (_end)
} ]);
}
_sendDataSct[3].rangeItems = _rangeItems;

// 5
var _requestItems = [];
for ( var n = 0; n < message.requests_.length; n++) {
var item = message.requests_[n];
_requestItems.push([ {
"type_2" : item.pieceType_
}, {
"start_8" : item.pieceId_
}, {
"cks_4" : item.checksum_
} ]);
}
_sendDataSct[5].requestItems = _requestItems;

// 7
var _responseItems = [];
for ( var n = 0; n < message.responses_.length; n++) {
var item = message.responses_[n];
_responseItems.push([ {
"type_2" : item.pieceType_
}, {
"start_8" : item.pieceId_
}, {
"streamLength_4" : item.data_.length
}, {
"stream_d" : item.data_
} ]);
}
_sendDataSct[7].responseItems = _responseItems;

// 9
var _peerItems = [];
if (typeof peerIdsList != 'undefined') {
for ( var n = 0; n < peerIdsList.length; n++) {
var item = peerIdsList[n];
_peerItems.push([ {
"head_4" : n
}, {
"URL_utf" : item
} ]);
}
_sendDataSct[9].peerItems = _peerItems;
}

_sendDataSct[2].rangeCount_4 = _sendDataSct[3].rangeItems.length;
_sendDataSct[4].requestCount_4 = _sendDataSct[5].requestItems.length;
_sendDataSct[6].responseCount_4 = _sendDataSct[7].responseItems.length;
_sendDataSct[8].peerCount_4 = _sendDataSct[9].peerItems.length;

// for(var _i = 0; _i < _sendDataSct[7].responseItems.length;_i++ )
// {
// _sendDataSct[7].responseItems[_i][2].streamLength_4 = _sendDataSct[7].responseItems[_i][3].stream_d.length;
// }

for ( var _i = 0; _i < _sendDataSct[9].peerItems.length; _i++) {
_sendDataSct[9].peerItems[_i][0].head_4 = _sendDataSct[9].peerItems[_i][1].URL_utf.length;
}

// /结算分享数据信息
// for(var _i=0;_i<_sendDataSct[7].responseItems.length;_i++)
// {
// this.shareNum++;
// this.shareSize+=Number(_sendDataSct[7].responseItems[_i][2].streamLength_4);
// }

// this.sendInfo(_sendDataSct);

var _arr = [];
if (type != p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeWebrtc) {
_sendDataSct.splice(1, 1);
}
this.processObject_(_sendDataSct, _arr);
var _size = 0;

for ( var _i = 0; _i < _arr.length; _i++) {
_size += _arr[_i].length;
}
var _sendData = new Uint8Array(_size);
var _count = 0;
for ( var _i = 0; _i < _arr.length; _i++) {
for ( var _j = 0; _j < _arr[_i].length; _j++) {
_sendData[_count++] = _arr[_i][_j];
}
}
// //
if (type == p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeWebrtc) {
var _sdatalen = _sendData.length;
_sendData[4] = (parseInt(_sdatalen) >> 24) & 0xff;
_sendData[5] = (parseInt(_sdatalen) >> 16) & 0xff;
_sendData[6] = (parseInt(_sdatalen) >> 8) & 0xff;
_sendData[7] = parseInt(_sdatalen) & 0xff;
}
// this.req++;
// this.dl++;
return _sendData;
},

decode : function(value, type) {
var _position = 0;
// var _sequnce = p2p$.com.webp2p.core.common.Number.convertToValue_('4', value, _position);
// var _time;
var _type;
// var _info;
var _i;
var message = new p2p$.com.webp2p.protocol.base.Message();
// ranges_:null,
// requests_:null,
// responses_:null,

_position += 4;
if (type == p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeWebrtc) {
_position += 4;// 跳过4个字节，这4个字节是说明数据长度的
}

var _rangeCount = p2p$.com.webp2p.core.common.Number.convertToValue_('4', value, _position);
_position += 4;
var rangeInfo = null;
if (_rangeCount !== 0) {
for (_i = 0; _i < _rangeCount; _i++) {
_type = p2p$.com.webp2p.core.common.Number.convertToValue_('2', value, _position);
_position += 2;
if (p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn === _type) {
// this.remoteTNList.push({"start":_start,"end":(_start+_end-1)});
rangeInfo = new p2p$.com.webp2p.protocol.base.PieceRangeItem();
rangeInfo.type_ = p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypeTn;
} else {
// this.remotePNList.push({"start":_start,"end":(_start+_end-1)});
rangeInfo = new p2p$.com.webp2p.protocol.base.PieceRangeItem();
rangeInfo.type_ = p2p$.com.webp2p.core.common.META_PIECE_TYPE.kMetaPieceTypePn;

}
rangeInfo.start_ = -1;
rangeInfo.count_ = 0;
var _start = p2p$.com.webp2p.core.common.Number.convertToValue_('8', value, _position);
_position += 8;
var _end = p2p$.com.webp2p.core.common.Number.convertToValue_('4', value, _position);
_position += 4;
rangeInfo.start_ = _start;
rangeInfo.count_ = _end;
message.ranges_.push(rangeInfo);
}
// 输出 range信息
// _info={};
// _info.code="P2P.Range.Info";
// _info.info={"TN":this.remoteTNList,"PN":this.remotePNList};
// this.statics.sendToJs(_info);
}

var _reqCount = p2p$.com.webp2p.core.common.Number.convertToValue_('4', value, _position);
_position += 4;
var requestInfo = null;
for (_i = 0; _i < _reqCount; _i++) {

requestInfo = new p2p$.com.webp2p.protocol.base.RequestDataItem();
_type = p2p$.com.webp2p.core.common.Number.convertToValue_('2', value, _position);
_position += 2;
var _pid = p2p$.com.webp2p.core.common.Number.convertToValue_('8', value, _position);
_position += 8;
var _sck = p2p$.com.webp2p.core.common.Number.convertToValue_('4', value, _position);
_position += 4;

requestInfo.pieceType_ = _type;
requestInfo.pieceId_ = _pid;
requestInfo.checksum_ = _sck;
message.requests_.push(requestInfo);
}

var _respCount = p2p$.com.webp2p.core.common.Number.convertToValue_('4', value, _position);
_position += 4;
var responseInfo = null;
// var _len = 1;// (requestArr?requestArr.length:1); && _i<_len
for (_i = 0; _i < _respCount; _i++) {
// _responseItems.push([{"type_2":item.pieceType_},
// {"start_8":item.pieceId_},
// {"streamLength_4":item.data_.length},
// {"stream_d":item.data_}]);
//
responseInfo = new p2p$.com.webp2p.protocol.base.ResponseDataItem();
// if(value.length > 50)
// {
// console.log("response");
// }
// _time = this.config.localTime - this.starttime;
_type = p2p$.com.webp2p.core.common.Number.convertToValue_('2', value, _position);
_position += 2;
var _pid2 = p2p$.com.webp2p.core.common.Number.convertToValue_('8', value, _position);
_position += 8;
var _DataL = p2p$.com.webp2p.core.common.Number.convertToValue_('4', value, _position);
_position += 4;

var _stream = p2p$.com.webp2p.core.common.Number.convertToValue_('d', value, _position, _DataL);
_position += _DataL;

responseInfo.pieceType_ = _type;
responseInfo.pieceId_ = _pid2;
responseInfo.data_ = _stream;
message.responses_.push(responseInfo);

// this.dealRemoteData({'pieceID':_pid2,'data':_stream});
// this.downNum++;
// this.downSize+=_stream.length;
// this.speed = Math.round(_stream.length*8/_time/10)/100;
// _info = {};
// _info.code = "P2P.Info.Debug";
// _info.info="p2p:["+this.remoteId_+"] "+_type+"_"+_pid2;
// this.statics.sendToJs(_info);
}

var _peerCount = p2p$.com.webp2p.core.common.Number.convertToValue_('4', value, _position);// sequnce
_position += 4;
var peersInfo = [];
for (_i = 0; _i < _peerCount; _i++) {
var _peerheadL = p2p$.com.webp2p.core.common.Number.convertToValue_('4', value, _position);// sequnce
_position += 4;
var _url = p2p$.com.webp2p.core.common.Number.convertToValue_('utf', value, _position, _peerheadL);
_position += _peerheadL;
peersInfo.push(_url);
}
// //接受完数据
// if(_rangeCount>0)
// {
// this.reqrangNum++;
// //防止发送太快，设置间隔
// this.peer.sendMessage_();
// }
return message;
},

processObject_ : function(obj, _array) {
switch (typeof (obj)) {
case "array":
for ( var i = 0; i < obj.length; i++) {
if (obj[i] instanceof Array) {
this.processObject_(obj[i], _array);
} else if (typeof (obj[i]) == "object") {
this.processObject_(obj[i], _array);
}
}
break;
case "object":
for ( var element in obj) {
var size = element.split("_")[1];
if (size) {
p2p$.com.webp2p.core.common.Number.convertToBit_(size, obj[element], _array);
}
if (!size && obj[element]) {
this.processObject_(obj[element], _array);
}
}
break;
default:
break;
}
}
};
p2p$.ns('com.webp2p.protocol.webrtc');

p2p$.com.webp2p.protocol.webrtc.Peer = p2p$.com.webp2p.protocol.base.Session.extend_({
peer_ : null,
dataChannel_ : null,
fromServer_ : false,
session_ : null,
lastConnectTime_ : 0,
manager_ : null,
properties_ : null,
remoteId_ : 0,
remoteConnectionId_ : 0,

localIceCandidates_ : null,
localSdpDescriptions_ : null,

remoteIceCandidates_ : null,
remoteSdpDescriptions_ : null,

iceOptions : null,
sdpOptions : null,
connectionId_ : "",
id_ : "",
connecting_ : false,
serverType_:false,//true为主动节点，false为被动节点
rate_ : 0,
rData_:null,
rData_len:0,
rTotalData_len:0,
tag_:"com::webp2p::protocol::webrtc::Peer",

init : function(manager) {
this._super(manager);
this.fromServer_ = false;
this.session_ = null;
this.lastConnectTime_ = 0;
this.manager_ = manager;
this.selfInfo_ = this.manager_.getSelfInfo_();
this.connectionId_ = "";
this.localIceCandidates_ = this.localIceCandidates_ || [];
this.remoteIceCandidates_ = this.remoteIceCandidates_ || [];
this.iceOptions = this.iceOptions || {
"optional" : []
};
this.sdpOptions = this.sdpOptions || {
'mandatory' : {
'OfferToReceiveAudio' : false,
'OfferToReceiveVideo' : false
}
};
this.id_ = "";
this.connecting_ = false;
},

load : function(peerItem) {
this.id_ = this.remoteId_ = peerItem.peerId;
},

load2 : function(message) {
for ( var n = 0; n < message.iceCandidates.length; n++) {
var peerInfo = message.iceCandidates[n];
var candidate = peerInfo.candidate;
if (candidate.indexOf("udp") != -1) {
var datas = candidate.split(" ");
if (!this.remoteIp_) {
this.remoteIp_ = datas[4] || "0.0.0.0";
}

if (this.remoteIp_.indexOf(":") != -1) {
continue;
}
if (!this.remotePort_) {
this.remotePort_ = datas[5] || "0";
}

if ((datas[7] || "").indexOf("srflx") == -1) {
continue;
} else {
this.remoteIp_ = datas[4] || "0.0.0.0";
this.remotePort_ = datas[5] || "0";
}
break;
}
}

if (!this.properties_) {
if (message.selfInfo) {
this.properties_ = message.selfInfo;
}

}
this.id_ = this.remoteId_;
},

connect : function() {
if (this.fromServer_) {
var _iceUrl = this.manager_.getPool_().getContext_().stunServerHost_;
this.iceServers_ = [ {
url : _iceUrl + '?transport=udp'
} ];
}
if (this.fromServer_) {
this.connectionId_ = this.remoteId_ + "-active";
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} active Try to connect to remote peer({1})  ...,stunServer({2})",this.tag_,this.remoteId_,
this.iceServers_[0].url));
} else {
this.connectionId_ = this.remoteId_ + "-passive";
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} passive Try to connect to remote peer({1})  ...,stunServer({2})",this.tag_,this.remoteId_,
this.iceServers_[0].url));
}

try {
this.peer_ = new RTCPeerConnection({
iceServers : this.iceServers_
}, this.iceOptions);
if (this.fromServer_) {
this.caller_ = this.peer_;
} else {
this.callee_ = this.peer_;
}
this.setPeerEvents_(this.peer_);
var me = this;
if (this.fromServer_) {
// caller
this.sendChannel_ = this.dataChannel_ = this.peer_.createDataChannel('peerChannel');
this.setChannelEvents_(this.dataChannel_);
} else {
// callee
this.peer_.setRemoteDescription(new RTCSessionDescription({
type : 'offer',
sdp : this.remoteSdpDescriptions_
}));
if (this.remoteIceCandidates_) {
this.addPeerIceCandidates_(this.remoteIceCandidates_);
}
this.callee_.createAnswer(function(description) {
me.callee_.setLocalDescription(description);
me.localSdpDescriptions_ = description.sdp;
},
function( err ){
P2P_ULOG_INFO(P2P_ULOG_FMT("{0},createAnswer error",scope_.tag_));
}, this.sdpOptions);
}
this.lastConnectTime_ = this.activeTime_ = this.global_.getMilliTime_();
} catch (e) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0}::Open failed, exception: {1}",this.tag_,(e || "").toString()));
}
},

onPeerOpen_ : function() {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onPeerOpen  create fromserver({1})",this.tag_,this.fromServer_));
var me=this;
this.caller_.createOffer(function( description )
{
me.caller_.setLocalDescription(description);
me.localSdpDescriptions_ = description.sdp;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onPeerOpen",me.tag_));
}, function( err )
{
P2P_ULOG_INFO(P2P_ULOG_FMT("{0},createOffer error",scope_.tag_));
}, this.sdpOptions);
},

sendConnectRequest_ : function() {
if (this.localIceCandidates_.length < 1) {
return;
}

var proxyData = {
action : 'connectRequest',
iceServers : this.iceServers_,
iceCandidates : this.localIceCandidates_,
sdpDescriptions : this.localSdpDescriptions_,
selfInfo : this.selfInfo_
};
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::sendConnectRequest ({1}) Send connect request ",this.tag_,this.connectionId_));
this.status = true;
this.manager_.sendMessage_({
method : 'proxyDataRequest',
destPeerId : this.remoteId_,
data : JSON.stringify(proxyData)
});
},

sendConnectResponse_ : function() {
if (this.status || this.localIceCandidates_.length < 1) {
return;
}
var proxyData = {
action : 'connectResponse',
iceCandidates : this.localIceCandidates_,
sdpDescriptions : this.localSdpDescriptions_,
selfInfo : this.selfInfo_
};
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::sendConnectResponse ({1}) Send connect response ",this.tag_,this.connectionId_));
this.status = true;
this.manager_.sendMessage_({
method : 'proxyDataRequest',
destPeerId : this.remoteId_,
data : JSON.stringify(proxyData)
});
},
onPeerIceCandidate_ : function(evt) {

if (evt.candidate) {
// both of caller and callee should save it first,waiting for switch candidate with Peer
this.localIceCandidates_.push(evt.candidate);
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onPeerIceCandidate ({2}) Receive PeerIceCandidate:({3})",this.tag_,this.connectionId_,evt.candidate.candidate));
if (!this.connecting_) {

}
} else {
if (this.fromServer_) {
this.sendConnectRequest_();
} else {
this.sendConnectResponse_();
}
}
},

onPeerDataChannel_ : function(evt) {
// callee open channel in this function
P2P_ULOG_TRACE(P2P_ULOG_FMT("{0}::onPeerDataChannel ({1}) Receive PeerDataChannel,channel name({2})",this.tag_,this.connectionId_,evt.channel.label));
this.dataChannel_ = evt.channel;
this.setChannelEvents_(evt.channel);
},
onChannelOpen_ : function(channel, evt) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}::onChannelOpen ({1}) Channel open success!!!!!!!!!!!!!!",this.tag_,this.connectionId_));
this.connecting_ = true;
this.session_ = new p2p$.com.webp2p.protocol.webrtc.Session(this.manager_, this.remoteId_, this.dataChannel_, this.remoteIp_, this.remotePort_);
this.session_.attchProperties_(this.properties_);
this.manager_.getEventListener_().onProtocolSessionOpen_(this.session_);
},

onChannelMessage_ : function(channel, evt) {
var type=evt.data.constructor.toString();
var _barry = new Uint8Array(evt.data);
if(type.indexOf("Blob")>-1)
{
var reader = new FileReader();
var me=this;
reader.readAsArrayBuffer(evt.data);
reader.onload = function (e) {
_barry = new Uint8Array(reader.result);
me.analyziseData_(_barry);
}
return;
}
this.analyziseData_(_barry);
},
analyziseData_:function(data)
{
// 提取前4位，如果前4位为0则为数据开始，然后
if (data[0] == 0 && data[1] == 0 && data[2] == 0 && data[3] == 0) {
this.rData_ = new CdeByteArray();
this.rData_len = data.length;
this.rTotalData_len = (data[4] << 24) + (data[5] << 16) + (data[6] << 8) + data[7];
} else {
this.rData_len = this.rData_len + data.length;
}
this.rData_.writeBytes(data);

if (this.rData_len >= this.rTotalData_len) {
//计算传输速度
var time = this.global_.getMilliTime_()-this.session_.sendTime_;
if(time>0&&this.session_.sendTime_>0&&this.rData_len>1000){
this.rate_ = this.rData_len/time;
console.log("rate=",this.rate_,this.rData_len,this.session_.sendTime_);
this.session_.sendTime_=-1;
}
this.rData_len = 0;
this.rTotalData_len = 0;
var message = p2p$.com.webp2p.protocol.webrtc.Packet.decode(this.rData_.uInt8Array, this.manager_.getType());
// console.log("protocol::webrtc::Peer::onChannelMessage_:",message);
this.manager_.getEventListener_().onProtocolSessionMessage_(this.session_, message);

} else {
// P2P_ULOG_TRACE(P2P_ULOG_FMT("protocol::webrtc::Peer::onChannelMessage ({0}) Channel open part of the message", this.connectionId_));
}
this.activeTime_ = this.global_.getMilliTime_();
},
acceptAnswer_ : function(candidates, sdpDescriptions) {
P2P_ULOG_TRACE(P2P_ULOG_FMT("{0}::acceptAnswer ({1}) Accept answer ",this.tag_,this.connectionId_));
this.remoteIceCandidates_ = candidates;
this.remoteSdpDescriptions_ = sdpDescriptions;
this.peer_.setRemoteDescription(new RTCSessionDescription({
type : 'answer',
sdp : sdpDescriptions
}));
this.addPeerIceCandidates_(candidates);
},
addPeerIceCandidates_ : function(candidates) {
if (Object.prototype.toString.call(candidates) == '[object Array]') {
for ( var i = 0; i < candidates.length; i++) {
this.peer_.addIceCandidate(new RTCIceCandidate(typeof (candidates[i]) != 'string' ? candidates[i] : {
sdpMLineIndex : 0,
sdpMid : 'data',
candidate : candidates[i]
}));
}
} else {
this.peer_.addIceCandidate(new RTCIceCandidate(candidates));
}
},
onChannelError_ : function(channel, evt) {
},

onChannelClose_ : function(channel, evt) {
// this.connecting_ = false;
// this.closeChannel_(evt);
},

closeChannel_ : function(evt) {
this.status = false;
// this.disconnect();
},

setPeerEvents_ : function(peer) {
var me = this;
peer.onnegotiationneeded = function() {
me.onPeerOpen_();
};
peer.onicecandidate = function(evt) {
me.onPeerIceCandidate_(evt);
};
peer.ondatachannel = function(evt) {
me.onPeerDataChannel_(evt);
};
},

setChannelEvents_ : function(channel) {
var me = this;
channel.onopen = function(evt) {
me.onChannelOpen_(channel, evt);
};
channel.onmessage = function(evt) {
me.onChannelMessage_(channel, evt);
};
channel.onerror = function(evt) {
me.onChannelError_(channel, evt);
};
channel.onclose = function(evt) {
me.onChannelClose_(channel, evt);
};
},

disconnect : function() {
P2P_ULOG_TRACE(P2P_ULOG_FMT("{0}::disconnect ({1}) disconnect... ",this.tag_,this.connectionId_));

if (this.dataChannel_) {
this.dataChannel_.close();
this.dataChannel_ = null;
}
if (this.peer_) {
this.peer_.close();
this.peer_ = null;
}

if (this.session_) {
this.manager_.closeChannel_(this.session_);
this.session_.close();
}
this.session_ = null;
this.connecting_ = false;
},

isActive_ : function(nowTime, maxConnectingTime) {
if (this.connecting_) {
if (!this.session_) {
return false;
}
if (this.session_.isActive_()) {
return (this.activeTime_ + 30 * 1000) > nowTime;
} else if (!this.connecting_) {
return false;
}
}
return this.activeTime_ + maxConnectingTime > nowTime;
},
clear : function() {
this.peer_ = null;
this.connectionId = 0;
this.remoteId_ = 0;
this.remoteConnectionId_ = 0;
this.dataChannel_ = null;
this.iceServers_ = null;
this.iceOptions = null;
this.sdpOptions = null;
this.localIceCandidates_ = null;
this.localSdpDescriptions_ = null;
this.remoteIceCandidates_ = null;
this.remoteSdpDescriptions_ = null;
this.status = false;
}
});
p2p$.ns('com.webp2p.protocol.webrtc');

p2p$.com.webp2p.protocol.webrtc.Session = p2p$.com.webp2p.protocol.base.Session.extend_({
channel_ : null,
sendTime_ : -1,
init : function(mgr, remoteId, dataChannel, remoteIp, remotePort) {
this._super(mgr, remoteId);
this.channel_ = dataChannel;
this.remoteIp_ = remoteIp;
this.remotePort_ = remotePort;
this.remoteAddress_ = this.strings_.format("{0}:{1}", this.remoteIp_, this.remotePort_);
},

send : function(message) {
if (!this.channel_) {
return;
}
// P2P_ULOG_TRACE(P2P_ULOG_FMT("com.webp2p.protocol.webrtc.Session::send message"));
var data = p2p$.com.webp2p.protocol.webrtc.Packet.encode(message, [], this.manager_.getType());
try {
this.sendTime_ = this.global_.getMilliTime_();
this.channel_.send(data);
} catch (e) {
this.close();
P2P_ULOG_INFO(P2P_ULOG_FMT("protocol::webrtc::Session::Send to channel failed, {0}, close channel({1})...", e.toString(), this.remoteAddress_));
}
},

attchProperties_ : function(properties) {
if (properties) {
// var clientModule = properties.clientModule;
// var clientVersion = properties.clientVersion;
// var protocolVersion = properties.protocolVersion;
// var playType = properties.playType;
// var p2pGroupId = properties.p2pGroupId;
// var osPlatform = properties.osPlatform;
// var hardwarePlatform = properties.hardwarePlatform;
this.name_ = this.remoteType_ = properties.hardwarePlatform + "/" + properties.clientModule + "-" + properties.clientVersion;
}
},

isActive_ : function() {
return (this.channel_ != null);
},

close : function() {
this.channel_ = null;
}
});
p2p$.ns('com.webp2p.protocol.websocket');
p2p$.com.webp2p.protocol.websocket.ManagerStatic = {
kTimerTypeTracker : 1,
kTimerTypeSession : 2,
kTimerTypeAsyncPeers : 3,
};

p2p$.com.webp2p.protocol.websocket.Manager = p2p$.com.webp2p.protocol.base.Manager.extend_({
http_ : null,
peers_ : null,
selfInnerIp_ : "",
selfInternetIp_ : "",
exchangePeerIdsData_ : "",

opened_ : false,
upnpMapResultReported_ : false,
upnpMapWaiting_ : false,
activeTime_ : 0,
protocolOpenedTime_ : 0,
peerMaxConnectingTime_ : 0,
trackerBeginQueryTime_ : 0,

trackerRegisterEnabled_ : false,
trackerRegistered_ : false,
activeSessionCount_ : 0,
trackerResponseStatus_ : 0,
shareServerPort_ : 0,
shareServerUpnpPort_ : 0,
heartbeatInterval_ : 0,
trackerTryTimes_ : 0,
upnpMapTryTimes_ : 0,
errorMap_:[],
tag_:"com::webp2p::protocol::websocket::Manager",

init : function(pool, evt) {
this._super(pool, evt, p2p$.com.webp2p.protocol.base.PROTOCOL_TYPES.kProtocolTypeWebSocket);
this.peers_ = new p2p$.com.common.Map();
this.heartbeatInterval_ = 30; // seconds
this.shareServerPort_ = 1443; // https port
this.shareServerUpnpPort_ = 0;
this.trackerTryTimes_ = 0;
this.upnpMapTryTimes_ = 0;
this.activeTime_ = 0;
this.trackerRegisterEnabled_ = true;
this.trackerRegistered_ = false;
this.upnpMapResultReported_ = false;
this.upnpMapWaiting_ = false;
this.activeSessionCount_ = 0;
this.trackerResponseStatus_ = 0;
this.trackerBeginQueryTime_ = 0;
this.peerMaxConnectingTime_ = 10 * 1000;
this.errorMap_=[];
this.http_ = null;
},

open : function() {
this.close();
this.opened_ = true;
this.activeTime_ = this.global_.getMilliTime_();
this.id_ = this.strings_.format("{0}{1}{2}{3}", Math.floor(Math.random() * (1000 + 1)), Math.floor(Math.random() * (1000 + 1)),
Math.floor(Math.random() * (1000 + 1)), this.global_.getMilliTime_());
if (this.pool_.getContext_().p2pHeartbeatInterval_ > 0) {
this.heartbeatInterval_ = this.pool_.getContext_().p2pHeartbeatInterval_;
}
this.pool_.getContext_().p2pWebsocketPeerId_ = this.id_;
this.sessionTimer_ = this.setTimeout_(p2p$.com.webp2p.protocol.websocket.ManagerStatic.kTimerTypeSession, this.sessionTimer_, 5000);
this.queryFromTracker_();
return true;
},

close : function() {
this.opened_ = false;
if (this.serverTimer_) {
clearTimeout(this.serverTimer_);
this.serverTimer_ = null;
}

if (this.sessionTimer_) {
clearTimeout(this.sessionTimer_);
this.sessionTimer_ = null;
}
if (this.http_ != null) {
this.http_ = null;
}
// shareServer_->stop();
// upnpService_->stop();
// for( protocol::base::SessionPtrList::iterator itr = sessions_.begin(); itr != sessions_.end(); itr ++ )
// {
// protocol::base::SessionPtr &session = (*itr);
// if( session.get() ) session->close();
// }
// sessions_.clear();
//
// asyncOpenPeers_.clear();
// asyncClosePeers_.clear();
for ( var n = 0; n < this.peers_.length; n++) {
var elem = this.peers_.element(n);
var peer = elem.value;
peer.disconnect();
}
this.peers_.clear();
//
// return true;
},

getXmtepHeaders_ : function() {
return "xMtepClientId="
+ this.id_
+ "&xMtepClientModule=h5"
+ "&xMtepClientVersion="
+ this.strings_.format("{0}.{1}.{2}", p2p$.com.selector.Module.kH5MajorVersion,
p2p$.com.selector.Module.kH5MinorVersion, p2p$.com.selector.Module.kH5BuildNumber) + "&xMtepProtocolVersion=1.0"
+ "&xMtepBusinessParams="
+ encodeURIComponent("playType=" + this.pool_.getContext_().playType_ + "&p2pGroupId=" + this.pool_.getMetaData_().p2pGroupId_)
+ "&xMtepOsPlatform=" + encodeURIComponent(this.pool_.getContext_().osType_) + "&xMtepHardwarePlatform=pc";
},

queryFromTracker_ : function() {
if (this.http_ != null) {
this.http_.log("cancel");
this.http_.close();
this.http_ = null;
}

this.activeTime_ = this.global_.getMilliTime_();

var context = this.pool_.getContext_();
// var terminalId = this.strings_.fromNumber(this.pool_.getContext_().terminalType_);
var operateCode = "3"; // get peer list
if (this.activeSessionCount_ >= this.pool_.getContext_().p2pMaxPeers_) {
operateCode = "1"; // heartbeat
}
var userparam = {"root": { "langtype": "3" }};
var url = new p2p$.com.common.Url();
url.protocol_ = "http";
url.host_ = this.pool_.getContext_().trackerServerHost_;
url.file_ = "/cde";
url.params_.set("termid", "2"); // terminalId;...
url.params_.set("format", "1");
url.params_.set("ver", context.playType_ + "." + context.moduleVersion_);
url.params_.set("op", operateCode);
url.params_.set("ckey", this.pool_.getMetaData_().p2pGroupId_);
url.params_.set("outip", "0.0.0.0");
url.params_.set("inip", "0.0.0.0");
url.params_.set("pid", this.strings_.format("33-{0}-0-0", this.id_));
url.params_.set("pos", this.strings_.fromNumber(this.pool_.getContext_().playingPosition_));
url.params_.set("ispId", this.strings_.fromNumber(context.isp_));
url.params_.set("neighbors", this.strings_.fromNumber(this.activeSessionCount_));
url.params_.set("arealevel1", context.countryCode_);
url.params_.set("arealevel2", this.strings_.fromNumber(context.province_));
url.params_.set("arealevel3", this.strings_.fromNumber(context.city_));
url.params_.set("expect", this.strings_.fromNumber(this.pool_.getContext_().p2pMaxPeers_ * 2));
url.params_.set("userparam",this.strings_.base64Encode_(JSON.stringify(userparam)));

var requestUrl = url.toString();
this.trackerBeginQueryTime_ = this.global_.getMilliTime_();
// set tracker timer
this.serverTimer_ = this.setTimeout_(p2p$.com.webp2p.protocol.websocket.ManagerStatic.kTimerTypeTracker, this.serverTimer_,
this.heartbeatInterval_ * 1000);
this.http_ = new p2p$.com.loaders.HttpDownLoader({url_:requestUrl, scope_:this, type_:"json", tag_:"websocket::tracker"});
this.http_.load_();
},

onHttpDownloadCompleted_ : function(downloader) {
var handled = false;

if (!this.opened_ || this.http_ != downloader) {
// expired
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} Expired http complete for tag({1}), channel({2}), ignore",this.tag_,downloader.tag_, this.pool_
.getMetaData_().storageId_));
return handled;
}

this.http_ = null;
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} Http complete for tag({1}), channel({2}), response code({3}), details({4}), size({5})",this.tag_,downloader.tag_, this.pool_.getMetaData_().storageId_, downloader.responseCode_, downloader.responseDetails_, downloader.responseLength_));

if (downloader.tag_ == "websocket::tracker") {
handled = true;
this.activeTime_ = this.global_.getMilliTime_();
if (!downloader.successed_ || downloader.responseCode_ < 200 || downloader.responseCode_ >= 300) {
// waiting for timeout and retry ...
return handled;
}

if (this.pool_.getContext_().trackerServerConnectedTime_ <= 0) {
this.pool_.getContext_().trackerServerConnectedTime_ = this.activeTime_ - this.trackerBeginQueryTime_;
}
// parse tracker data
this.parseTrackerResponse_(downloader);
}

return handled;
},

parseTrackerResponse_ : function(downloader) {
var peerResponseCount = 0;
var newPeerCount = 0;
// var previousSelfIp = this.selfInternetIp_;
var result = downloader.responseData_;
if (result == "" || result == null) {
// if( this.gslbServerErrorCode_ <= 0 ) gslbServerErrorCode_ = 52001;
return false;
}

if (!downloader.responseData_ == "") {

this.trackerResponseStatus_ = result["status"];
if (this.trackerResponseStatus_ != 200) {
P2P_ULOG_ERROR(P2P_ULOG_FMT("{0} Tracker response status({1}), not 200, channel({2})",this.tag_,this.trackerResponseStatus_,
this.pool_.getMetaData_().storageId_));
return false;
}

this.selfInternetIp_ = result["host"] || "";
var peerList = result["peerlist"] || [];
for ( var n = 0; n < peerList.length; n++) {
var peerItem = peerList[n];
var itemId = peerItem["peerid"];
var itemIp = peerItem["userip"];
var itemPort = peerItem["pport"];
if (itemPort == this.shareServerPort_ && itemIp == this.selfInnerIp_) {
// self
continue;
}
if (itemIp == "127.0.0.1" || itemIp == "0.0.0.0" || itemIp == "255.255.255.255") {
// invalid ip address
continue;
}
if(this.isDisabledIp_(itemIp))
{
//invalid ip address
continue;
}
itemId = this.strings_.toLower_(itemId);
var isFind = this.peers_.find(itemId);
var info;
if (!isFind) {
if (this.peers_.size() >= this.maxActiveSession_ * 2) {
break;
}
info = new p2p$.com.webp2p.protocol.websocket.Peer(this);
this.peers_.set(itemId, info);
newPeerCount++;
info.fromServer_ = true;
} else {
info = this.peers_.get(itemId);
}
if (info != null) {
info.fromServer_ = true;
info.load(peerItem);
}

}
peerResponseCount = peerList.length;
this.pool_.getContext_().websocketTotalNodeCount_ = this.peers_.length;
}

var registering = false;
if (this.trackerRegisterEnabled_ && !this.trackerRegistered_) {
registering = true;
this.trackerRegistered_ = true;
this.protocolOpenedTime_ = this.global_.getMilliTime_();
this.eventListener_.onProtocolManagerOpen_(this, 0);
}

if (newPeerCount > 0) {
this.checkPeerSessions_();
}
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} {1} tracker successfully, self internet ip({2}), load {3} peer(s), {4} peer(s) now, channel({5})",this.tag_,(registering ? "Register to" : "Query peer from"), this.selfInternetIp_, peerResponseCount, this.peers_.length,this.pool_.getMetaData_().storageId_));
},
isDisabledIp_:function(ip)
{
var exit_ = false;
for(var i=0;i<this.errorMap_.length;i++)
{
if(this.errorMap_[i]==ip){
exit_=true;
P2P_ULOG_WARNING(P2P_ULOG_FMT("{0} ip({1}) isDisable!",this.tag_,ip));
break;
}
}
return exit_;
},
checkPeerSessions_ : function() {
var nowTime = this.global_.getMilliTime_();
var updatedPeerCount = 0;

// clean connect failed peers
for ( var n = 0; n < this.peers_.length; n++) {
var elem = this.peers_.element(n);
var peer = elem.value;
if (!peer.isActive_(nowTime, this.peerMaxConnectingTime_) && (peer.totalConnectingTimes_ > 5 || peer.disconnectTimes_ > 3 || !peer.fromServer_)) {
if (peer.session_ != null) {
this.pool_.getContext_().websocketTotalNodeCount_ = this.peers_.size();
this.eventListener_.onProtocolSessionClose_(peer.session_);
}
peer.disconnect();
this.peers_.erase(elem.key);
n--;
updatedPeerCount++;
}
}

this.activeSessionCount_ = 0;
for ( var n = 0; n < this.peers_.length; n++) {
var elem = this.peers_.element(n);
var peer = elem.value;
if (peer.session_ == null) {
continue;
}
if (!peer.isActive_(nowTime, this.peerMaxConnectingTime_)) {
this.pool_.getContext_().websocketTotalNodeCount_ = this.peers_.size();
this.eventListener_.onProtocolSessionClose_(peer.session_);
peer.disconnect();
updatedPeerCount++;
} else {
this.activeSessionCount_++;
}
}

//
if (this.activeSessionCount_ >= this.maxActiveSession_) {
return;
}
//
var connectablePeers = [];
for ( var n = 0; n < this.peers_.length; n++) {
var elem = this.peers_.element(n);
var peer = elem.value;
if (peer.isActive_(nowTime, this.peerMaxConnectingTime_)) {
continue;
}
if (!peer.fromServer_) {
// passive peer
continue;
} else if (peer.lastConnectTime_ + 60 * 1000 > nowTime) {
// sleep
continue;
}
connectablePeers.push(peer);
}

for ( var n = 0; n < connectablePeers.length; n++) {
var peer = connectablePeers[n];
// try connect peer
if (!peer.connect(this)) {
// failed
continue;
}
this.activeSessionCount_++;
if (this.activeSessionCount_ >= this.maxActiveSession_) {
break;
}
}
},

onTimeout_ : function(tag, timer, errorCode) {
switch (tag) {
case p2p$.com.webp2p.protocol.websocket.ManagerStatic.kTimerTypeTracker:
this.onTrackerTimeout_();
break;
case p2p$.com.webp2p.protocol.websocket.ManagerStatic.kTimerTypeSession:
this.onSessionTimeout_();
break;
case p2p$.com.webp2p.protocol.websocket.ManagerStatic.kTimerTypeAsyncPeers:
//			this.onAsyncPeersTimeout();
break;
default:
break;
}
},

onTrackerTimeout_ : function() {
if (this.http_ != null) {
this.http_.log("timeout");
// http_->close();
this.http_ = null;
}

if (!this.opened_) {
return;
}
this.queryFromTracker_();
},

onSessionTimeout_ : function() {
this.checkPeerSessions_();
this.sessionTimer_ = this.setTimeout_(p2p$.com.webp2p.protocol.websocket.ManagerStatic.kTimerTypeSession, this.sessionTimer_, 5000);
},

onWebSocketOpen_ : function(evt, session) {
this.status = true;
},

onWebSocketMessage_ : function(message, session) {
if (!this.opened_) {
return false;
}
if (!this.status) {
return;
}

for ( var n = 0; n < this.peers_.length; n++) {
var elem = this.peers_.element(n);
var peer = elem.value;
var me = this;
if (session == peer.session_) {
P2P_ULOG_TRACE(P2P_ULOG_FMT("{0} Active session({1}, {2}:{3}) message arrive",this.tag_,peer.id_, peer.internetIp_,peer.internetPort_));

peer.activeTime_ = this.global_.getMilliTime_();

var data = message.data;
switch (typeof (data)) {
case "string":
if (false === session.openHashhand) {
session.openHashhand = true;
session.attchProperties_(JSON.parse(data));
this.eventListener_.onProtocolSessionOpen_(session);
}
break;
case "object":
var fileReader = new FileReader();
fileReader.onload = function() {
var messageDecode = p2p$.com.webp2p.protocol.webrtc.Packet.decode(new Uint8Array(this.result), me.getType());
me.getEventListener_().onProtocolSessionMessage_(session, messageDecode);
};
fileReader.readAsArrayBuffer(data);
break;
}
}

}
},

onWebSocketClose_ : function(evt, session) {
if (!this.opened_) {
return false;
}

for ( var n = 0; n < this.peers_.length; n++) {
var elem = this.peers_.element(n);
var peer = elem.value;
if (session == peer.session_) {
P2P_ULOG_TRACE(P2P_ULOG_FMT("{0} Session({1}, {2}:{3}) closed",this.tag_,peer.id_, peer.internetIp_, peer.internetPort_));
this.pool_.getContext_().websocketTotalNodeCount_ = this.peers_.size();
this.eventListener_.onProtocolSessionClose_(session);
peer.disconnect();
break;
}
}
return true;
},
onWebSocketError_ : function(evt,session){
if (!this.opened_) {
return false;
}
//把当前节点添加到已经连接过得节点
var exit_ = false;
for(var i=0;i<this.errorMap_.length;i++)
{
if(this.errorMap_[i]==session.remoteIp_){
exit_=true;
break;
}
}
if(!exit_){
P2P_ULOG_INFO(P2P_ULOG_FMT("{0} add Invalid ip（{1}）",this.tag_,session.remoteIp_));
this.errorMap_.push(session.remoteIp_);
}
this.onWebSocketClose_(evt,session);
}
});
p2p$.ns('com.webp2p.protocol.websocket');

p2p$.com.webp2p.protocol.websocket.PeerStatic = {
nextConnectionId_ : 0,
};

p2p$.com.webp2p.protocol.websocket.Peer = p2p$.com.webp2p.protocol.base.Session.extend_({
protocol_ : 0,
weight_ : 0,
terminalType_ : 0,
id_ : "",
internetIp_ : "",
innerIp_ : "",
internetPort_ : 0,
innerPort_ : 0,
fromServer_ : false,

// status
loadTime_ : 0,
activeTime_ : 0,
lastConnectTime_ : 0,
heartbeatTime_ : 0,
peerExchangeTime_ : 0,
usingParamsMode_ : false,
innerIpConnectingTimes_ : 0,
totalConnectingTimes_ : 0,
disconnectTimes_ : 0,
randomSeed_ : 0,
connecting_ : false,


init : function(manager) {
this._super(manager,"");
this.tag_="com::webp2p::protocol::websocket::Peer";
this.protocol_ = 0;
this.weight_ = 0;
this.terminalType_ = 0;
this.internetPort_ = 0;
this.innerPort_ = 0;

this.loadTime_ = 0;
this.activeTime_ = 0;
this.lastConnectTime_ = 0;
this.heartbeatTime_ = 0;
this.peerExchangeTime_ = 0;
this.innerIpConnectingTimes_ = 0;
this.totalConnectingTimes_ = 0;
this.disconnectTimes_ = 0;
this.randomSeed_ = Math.floor(Math.random() * (1000 + 1));
this.usingParamsMode_ = false;
this.connecting_ = false;
this.fromServer_ = false;
},

load : function(result) {
this.loadTime_ = this.global_.getMilliTime_();
this.id_ = result["peerid"];
this.protocol_ = result["protocol"];
this.weight_ = result["weight"];
this.terminalType_ = result["termid"];
this.internetIp_ = result["userip"];
this.internetPort_ = result["pport"];
this.innerIp_ = result["inip"];
this.innerPort_ = result["inport"];
},

loadFromUrl_ : function(url) {
var info = new p2p$.com.common.Url;
info.fromString_(url);

this.loadTime_ = this.global_.getMilliTime_();
this.id_ = this.strings_.makeLower_(info.params_.get("peerId"));
this.terminalType_ = this.strings_.parseNumber_(info.params_.get("terminalType"), 0);
this.internetIp_ = info.host_;
this.internetPort_ = info.port_;
this.innerIp_ = info.params_.get("inIp");
this.innerPort_ = this.strings_.parseNumber_(info.params_.get("inPort"), 0);
},

toStringUrl_ : function() {
return this.strings_.format("ws://{0}:{1}/mtep-exchange-connection?inIp={2}&inPort={3}&peerId={4}", this.internetIp_,
this.internetPort_, this.innerIp_, this.innerPort_, id_);
},

attach : function(mgr, conn) {
},

connect : function(mgr, selfInternetIp) {
// this.disconnect();
P2P_ULOG_TRACE(P2P_ULOG_FMT("{0} Try to connect to({1}), {2}:{3} ...",this.tag_,this.id_,this.internetIp_,this.internetPort_));

this.connecting_ = true;
this.totalConnectingTimes_++;
this.lastConnectTime_ = this.activeTime_ = this.global_.getMilliTime_();
this.session_ = new p2p$.com.webp2p.protocol.websocket.Session(mgr, this.id_, this.internetIp_, this.internetPort_);
return this.session_.open();
},

disconnect : function() {
this.connecting_ = false;
if (this.session_ != null) {
this.disconnectTimes_++;
this.session_.close();
}
this.session_ = null;
return true;
},

isActive_ : function(nowTime, maxConnectingTime) {
if (this.connecting_) {
if (this.session_ == null) {
return false;
}

if (this.session_.isActive_()) {
return (this.activeTime_ + 60 * 1000) > nowTime;
} else if (!this.connecting_) {
return false;
}
}
return this.activeTime_ + maxConnectingTime > nowTime;
}
});
p2p$.ns('com.webp2p.protocol.websocket');

p2p$.com.webp2p.protocol.websocket.Session = p2p$.com.webp2p.protocol.base.Session.extend_({

init : function(mgr, remoteId, remoteIp, remotePort) {
this._super(mgr, remoteId);
this.remoteIp_ = remoteIp;
this.remotePort_ = remotePort;
this.passive_ = false;
this.remoteAddress_ = this.strings_.format("{0}:{1}", this.remoteIp_, this.remotePort_);
this.openHashhand = false;
},

send : function(message) {
// console.log("com.webp2p.protocol.websocket.Peer::onWebSocketMessage_:send",message);
// P2P_ULOG_TRACE(P2P_ULOG_FMT("com.webp2p.protocol.websocket.Session::send message"));
var data = p2p$.com.webp2p.protocol.webrtc.Packet.encode(message, [], this.manager_.getType());
this.websocket.send(new Blob([ data ]));
},

open : function() {
if (this.passive_) {
return true;
}
var mgr = this.manager_;
var xmtepHeaders = mgr.getXmtepHeaders_();
var me = this;
this.uir = "ws://" + this.remoteIp_ + ":" + this.remotePort_ + "/mtep-exchange-connection?" + xmtepHeaders;
try {
this.websocket = new WebSocket(this.uir);
} catch (e) {
P2P_ULOG_INFO(P2P_ULOG_FMT("{0}open failed, exception: {1}",this.tag_,e.toString()|""));
return false;
}
this.websocket.onopen = function(evt) {
mgr.onWebSocketOpen_(evt, me);
};
this.websocket.onclose = function(evt) {
mgr.onWebSocketClose_(evt, me);
};
this.websocket.onmessage = function(message) {
mgr.onWebSocketMessage_(message, me);
};
this.websocket.onerror = function(evt) {
mgr.onWebSocketError_(evt, me);
};
return true;
},

close : function() {
this.websocket = null;
},

isActive_ : function() {
if (this.passive_) {
return false;
} else {
return this.websocket;
}
},

attchProperties_ : function(value) {
if (!value) {
return;
}

// var responseClientId_ = "";
var hardwarePlatform = "";
var strClientMode = "";
var strClientVersion = "";
// var businessParamString = "";
if (value.hasOwnProperty("x-mtep-client-id")) {
responseClientId_ = value["x-mtep-client-id"];
} else if (value.hasOwnProperty("xMtepClientId")) {
responseClientId_ = value["xMtepClientId"];
}

if (value.hasOwnProperty("x-mtep-hardware-platform")) {
hardwarePlatform = value["x-mtep-hardware-platform"];
} else if (value.hasOwnProperty("xMtepHardwarePlatform")) {
hardwarePlatform = value["xMtepHardwarePlatform"];
}

if (value.hasOwnProperty("x-mtep-client-module")) {
strClientMode = value["x-mtep-client-module"];
} else if (value.hasOwnProperty("xMtepClientModule")) {
strClientMode = value["xMtepClientModule"];
}

if (value.hasOwnProperty("x-mtep-client-version")) {
strClientVersion = value["x-mtep-client-version"];
} else if (value.hasOwnProperty("xMtepClientVersion")) {
strClientVersion = value["xMtepClientVersion"];
}
this.name_ = this.remoteType_ = hardwarePlatform + "/" + strClientMode + "-" + strClientVersion;

if (value.hasOwnProperty("x-mtep-business-params")) {
businessParamString = value["x-mtep-business-params"];
} else if (value.hasOwnProperty("xMtepBusinessParams")) {
businessParamString = value["xMtepBusinessParams"];
}
}
});
